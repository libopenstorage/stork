
// Tab size=2; Tabs as spaces; Clean up trailing whitepsace
//
// In vim add: au FileType proto setl sw=2 ts=2 expandtab list
//
// Note, the documentation provided here for can be created in
// markdown format plus the use of 'codetabs' are supported. The documentation
// will then be rendered by github.com/openstoreage/libopenstoreage.github.io and
// provided on https://libopenstorage.github.io
//
syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";

package openstorage.api;

option go_package = "api";
option java_multiple_files = true;
option java_package = "com.openstorage.api";

enum Status {
  STATUS_NONE = 0;
  STATUS_INIT = 1;
  STATUS_OK = 2;
  STATUS_OFFLINE = 3;
  STATUS_ERROR = 4;
  STATUS_NOT_IN_QUORUM = 5;
  STATUS_DECOMMISSION = 6;
  STATUS_MAINTENANCE = 7;
  STATUS_STORAGE_DOWN = 8;
  STATUS_STORAGE_DEGRADED = 9;
  STATUS_NEEDS_REBOOT = 10;
  STATUS_STORAGE_REBALANCE = 11;
  STATUS_STORAGE_DRIVE_REPLACE = 12;
  STATUS_NOT_IN_QUORUM_NO_STORAGE = 13;
  // Add statuses before MAX and update the number for MAX
  STATUS_MAX = 14;
}

enum DriverType {
  DRIVER_TYPE_NONE = 0;
  DRIVER_TYPE_FILE = 1;
  DRIVER_TYPE_BLOCK = 2;
  DRIVER_TYPE_OBJECT = 3;
  DRIVER_TYPE_CLUSTERED = 4;
  DRIVER_TYPE_GRAPH = 5;
}

enum FSType {
  FS_TYPE_NONE = 0;
  FS_TYPE_BTRFS = 1;
  FS_TYPE_EXT4 = 2;
  FS_TYPE_FUSE = 3;
  FS_TYPE_NFS = 4;
  FS_TYPE_VFS = 5;
  FS_TYPE_XFS = 6;
  FS_TYPE_ZFS = 7;
  FS_TYPE_XFSv2 = 8;
}

enum GraphDriverChangeType {
  GRAPH_DRIVER_CHANGE_TYPE_NONE = 0;
  GRAPH_DRIVER_CHANGE_TYPE_MODIFIED = 1;
  GRAPH_DRIVER_CHANGE_TYPE_ADDED = 2;
  GRAPH_DRIVER_CHANGE_TYPE_DELETED = 3;
}

enum SeverityType {
  SEVERITY_TYPE_NONE = 0;
  SEVERITY_TYPE_ALARM = 1;
  SEVERITY_TYPE_WARNING = 2;
  SEVERITY_TYPE_NOTIFY = 3;
}

enum ResourceType {
  RESOURCE_TYPE_NONE = 0;
  RESOURCE_TYPE_VOLUME = 1;
  RESOURCE_TYPE_NODE = 2;
  RESOURCE_TYPE_CLUSTER = 3;
  RESOURCE_TYPE_DRIVE = 4;
}

enum AlertActionType {
  ALERT_ACTION_TYPE_NONE = 0;
  ALERT_ACTION_TYPE_DELETE = 1;
  ALERT_ACTION_TYPE_CREATE = 2;
  ALERT_ACTION_TYPE_UPDATE = 3;
}

enum VolumeActionParam {
  VOLUME_ACTION_PARAM_NONE = 0;
  // Maps to the boolean value false
  VOLUME_ACTION_PARAM_OFF = 1;
  // Maps to the boolean value true.
  VOLUME_ACTION_PARAM_ON = 2;
}

enum CosType {
  NONE = 0;
  LOW = 1;
  MEDIUM = 2;
  HIGH = 3;
}

enum IoProfile {
  IO_PROFILE_SEQUENTIAL = 0;
  IO_PROFILE_RANDOM= 1;
  IO_PROFILE_DB = 2;
  IO_PROFILE_DB_REMOTE = 3;
  IO_PROFILE_CMS = 4;
}

// VolumeState represents the state of a volume.
enum VolumeState {
  VOLUME_STATE_NONE = 0;
  // Volume is transitioning to new state
  VOLUME_STATE_PENDING = 1;
  // Volume is ready to be assigned to a container
  VOLUME_STATE_AVAILABLE = 2;
  // Volume is attached to container
  VOLUME_STATE_ATTACHED = 3;
  // Volume is detached but associated with a container
  VOLUME_STATE_DETACHED = 4;
  // Volume detach is in progress
  VOLUME_STATE_DETATCHING = 5;
  // Volume is in error state
  VOLUME_STATE_ERROR = 6;
  // Volume is deleted, it will remain in this state
  // while resources are asynchronously reclaimed
  VOLUME_STATE_DELETED = 7;
  // Volume is trying to be detached
  VOLUME_STATE_TRY_DETACHING = 8;
  // Volume is undergoing restore
  VOLUME_STATE_RESTORE = 9;
}

// VolumeStatus represents a health status for a volume.
enum VolumeStatus {
  VOLUME_STATUS_NONE = 0;
  // Volume is not present
  VOLUME_STATUS_NOT_PRESENT = 1;
  // Volume is healthy
  VOLUME_STATUS_UP = 2;
  // Volume is in fail mode
  VOLUME_STATUS_DOWN = 3;
  // Volume is up but with degraded performance
  // In a RAID group, this may indicate a problem with one or more drives
  VOLUME_STATUS_DEGRADED = 4;
}

enum StorageMedium {
  // Magnetic spinning disk.
  STORAGE_MEDIUM_MAGNETIC = 0;
  // SSD disk
  STORAGE_MEDIUM_SSD = 1;
  // NVME disk
  STORAGE_MEDIUM_NVME = 2;
}

enum ClusterNotify {
 // Node is down
 CLUSTER_NOTIFY_DOWN = 0;
}

enum AttachState {
    // Attached and available externally
    ATTACH_STATE_EXTERNAL = 0;
    // Attached but only available internally
    ATTACH_STATE_INTERNAL = 1;
    // Switching from External to Internal
    ATTACH_STATE_INTERNAL_SWITCH = 2;
}

enum OperationFlags {
  OP_FLAGS_UNKNOWN = 0;
  OP_FLAGS_NONE = 1;
  // Perform a force_detach during detach operation
  OP_FLAGS_DETACH_FORCE = 2;
}



// StorageResource groups properties of a storage device.
// swagger:model
message StorageResource {
  // Id is the LUN identifier.
  string id = 1;
  // Path device path for this storage resource.
  string path = 2;
  // Storage medium.
  StorageMedium medium = 3;
  // True if this device is online.
  bool online = 4;
  // IOPS
  uint64 iops = 5;
  // SeqWrite
  double seq_write = 6;
  // SeqRead
  double seq_read = 7;
  // RandRW
  double randRW  = 8;
  // Total size in bytes.
  uint64 size = 9;
  // Physical Bytes used.
  uint64 used = 10;
  // True if this device is rotational.
  string rotation_speed = 11;
  // Timestamp of last time this device was scanned.
  google.protobuf.Timestamp last_scan = 12;
  // True if dedicated for metadata.
  bool metadata = 13;
}

// StoragePool groups different storage devices based on their CosType
message StoragePool {
  // ID pool ID
  int32 ID = 1;
  // Cos reflects the capabilities of this drive pool
  CosType Cos = 2;
  // Medium underlying storage type
  StorageMedium Medium = 3;
  // RaidLevel storage raid level
  string RaidLevel = 4;
  // TotalSize of the pool
  uint64 TotalSize = 7;
  // Used size of the pool
  uint64 Used = 8;
  // Labels is a list of user defined name-value pairs
  map<string, string> labels = 9;
}

// VolumeLocator is a structure that is attached to a volume
// and is used to carry opaque metadata.
// swagger:model
message VolumeLocator {
  // User friendly identifier
  string name = 1;
  // A set of name-value pairs that acts as search filters
  map<string, string> volume_labels = 2;
}

// Source is a structure that can be given to a volume
// to seed the volume with data.
// swagger:model
message Source {
  // A volume id, if specified will create a clone of the parent.
  string parent = 1;
  // Seed will seed the volume from the specified URI
  // Any additional config for the source comes from the labels in the spec
  string seed = 2;
}

// Group represents VolumeGroup / namespace
// All volumes in the same group share this object.
// swagger:model
message Group {
  // Id common identifier across volumes that have the same group.
  string id = 1;
}

// IoStrategy defines how I/O should be performed to backing storage media.
message IoStrategy {
  // AsyncIO enables kaio.
  bool async_io = 1;
  // EarlyAck enables acks for async I/O at the source.
  bool early_ack = 2;
}

// VolumeSpec has the properties needed to create a volume.
// swagger:model
message VolumeSpec {
  // Ephemeral storage
  bool ephemeral = 1;
  // Size specifies the thin provisioned volume size in bytes
  uint64 size = 2;
  // Format specifies the filesystem for this volume.
  FSType format = 3;
  // BlockSize for the filesystem.
  int64 block_size = 4;
  // HaLevel specifies the number of copies of data.
  int64 ha_level = 5;
  // Cos specifies the relative class of service.
  CosType cos = 6;
  // IoProfile provides a hint about application using this volume.
  IoProfile io_profile = 7;
  // Dedupe specifies if the volume data is to be de-duplicated.
  bool dedupe = 8;
  // SnapshotInterval in minutes, set to 0 to disable snapshots
  uint32 snapshot_interval = 9;
  // VolumeLabels configuration labels
  map<string, string> volume_labels = 10;
  // Shared is true if this volume can be concurrently accessed by multiple users.
  bool shared = 11;
  // ReplicaSet is the desired set of nodes for the volume data.
  ReplicaSet replica_set = 12;
  // Aggregatiokn level Specifies the number of parts the volume can be aggregated from.
  uint32 aggregation_level = 13;
  // Encrypted is true if this volume will be cryptographically secured.
  bool encrypted = 14;
  // Passphrase for an encrypted volume
  string passphrase = 15;
  // SnapshotSchedule a well known string that specifies when snapshots should be taken.
  string snapshot_schedule = 16;
  // Scale allows autocreation of volumes.
  uint32 scale = 17;
  // Sticky volumes cannot be deleted until the flag is removed.
  bool sticky = 18;
  // Group identifies a consistency group
  Group group = 21;
  // GroupEnforced is true if consistency group creation is enforced.
  bool group_enforced = 22;
  // Compressed is true if this volume is to be compressed.
  bool compressed = 23;
  // Cascaded is true if this volume can be populated on any node from an external source.
  bool cascaded = 24;
  // Journal is true if data for the volume goes into the journal.
  bool journal = 25;
  // Sharedv4 is true if this volume can be accessed via sharedv4.
  bool sharedv4 = 26;
  // QueueDepth defines the desired block device queue depth
  uint32 queue_depth = 27;
  // Use to force a file system type which is not recommended.
  // The driver may still refuse to use the file system type.
  bool force_unsupported_fs_type = 28;
  // Nodiscard specifies if the volume will be mounted with discard support disabled.
  // i.e. FS will not release allocated blocks back to the backing storage pool.
  bool nodiscard = 29;
  // IoStrategy preferred strategy for I/O.
  IoStrategy io_strategy = 30;
  // PlacementStrategy specifies a spec to indicate where to place the volume.
  VolumePlacementStrategy placement_strategy = 31;
}

// VolumeSpecUpdate provides a method to set any of the VolumeSpec of an existing volume
message VolumeSpecUpdate {
  // Size specifies the thin provisioned volume size in bytes
  oneof size_opt { uint64 size = 2; }
  // HaLevel specifies the number of copies of data.
  oneof ha_level_opt { int64 ha_level = 5; }
  // Cos specifies the relative class of service.
  oneof cos_opt { CosType cos = 6; }
  // IoProfile provides a hint about application using this volume.
  oneof io_profile_opt { IoProfile io_profile = 7; }
  // Dedupe specifies if the volume data is to be de-duplicated.
  oneof dedupe_opt { bool dedupe = 8; }
  // SnapshotInterval in minutes, set to 0 to disable snapshots
  oneof snapshot_interval_opt { uint32 snapshot_interval = 9; }
  // VolumeLabels configuration labels
  map<string, string> volume_labels = 10;
  // Shared is true if this volume can be remotely accessed.
  oneof shared_opt { bool shared = 11; }
  // ReplicaSet is the desired set of nodes for the volume data.
  ReplicaSet replica_set = 12;
  // Passphrase for an encrypted volume
  oneof passphrase_opt { string passphrase = 15; }
  // SnapshotSchedule a well known string that specifies when snapshots should be taken.
  oneof snapshot_schedule_opt { string snapshot_schedule = 16; }
  // Scale allows autocreation of volumes.
  oneof scale_opt { uint32 scale = 17; }
  // Sticky volumes cannot be deleted until the flag is removed.
  oneof sticky_opt { bool sticky = 18; }
  // Group identifies a consistency group
  oneof group_opt { Group group = 19; }
  // Journal is true if data for the volume goes into the journal.
  oneof journal_opt { bool journal = 23; }
  // Sharedv4 is true if this volume can be accessed via sharedv4.
  oneof sharedv4_opt { bool sharedv4 = 24; }
  // QueueDepth defines the desired block device queue depth
  oneof queue_depth_opt { uint32 queue_depth = 25; }
}

// ReplicaSet set of machine IDs (nodes) to which part of this volume is erasure
// coded - for clustered storage arrays
// swagger:model
message ReplicaSet {
  repeated string nodes = 1;
}

// RuntimeStateMap is a list of name value mapping of driver specific runtime
// information.
// swagger:model
message RuntimeStateMap {
  map<string, string> runtime_state = 1;
}

// Volume represents an abstract storage volume.
// swagger:model
message Volume {
  // Self referential volume ID.
  string id = 1;
  // Source specified seed data for the volume.
  Source source = 2;
  // Group volumes in the same group have the same group id.
  Group group = 3;
  // Readonly is true if this volume is to be mounted with readonly access.
  bool readonly = 4;
  // User specified locator
  VolumeLocator locator = 5;
  // Volume creation time
  google.protobuf.Timestamp ctime = 6;
  // User specified VolumeSpec
  VolumeSpec spec = 7;
  // Usage is bytes consumed by vtheis volume.
  uint64 usage = 8;
  // LastScan is the time when an integrity check was run.
  google.protobuf.Timestamp last_scan = 9;
  // Format specifies the filesytem for this volume.
  FSType format = 10;
  // Status is the availability status of this volume.
  VolumeStatus status = 11;
  // State is the current runtime state of this volume.
  VolumeState state = 12;
  // AttachedOn is the node instance identifier for clustered systems.
  string attached_on = 13;
  // AttachedState shows whether the device is attached for internal or external use.
  AttachState attached_state = 14;
  // DevicePath is the device exported by block device implementations.
  string device_path = 15;
  // SecureDevicePath is the device path for an encrypted volume.
  string secure_device_path = 16;
  // AttachPath is the mounted path in the host namespace.
  repeated string attach_path = 17;
  // AttachInfo is a list of name value mappings that provides attach information.
  map<string, string> attach_info = 18;
  // ReplicatSets storage for this volumefor clustered storage arrays.
  repeated ReplicaSet replica_sets = 19;
  // RuntimeState is a lst of name value mapping of driver specific runtime
  // information.
  repeated RuntimeStateMap runtime_state = 20;
  // Error is the Last recorded error.
  string error = 21;
  // VolumeConsumers are entities that consume this volume
  repeated VolumeConsumer volume_consumers = 22;
  // FsResizeRequired if an FS resize is required on the volume.
  bool fs_resize_required = 23;
}

// Stats is a structure that represents last collected stats for a volume
message Stats {
  // Reads completed successfully
  uint64 reads = 1;
  // Time spent in reads in ms
  uint64 read_ms = 2;
  // Number of bytes read
  uint64 read_bytes = 3;
  // Writes completed successfully
  uint64 writes = 4;
  // Time spent in writes in ms
  uint64 write_ms = 5;
  // Number of bytes written
  uint64 write_bytes = 6;
  // IOs curently in progress
  uint64 io_progress = 7;
  // Time spent doing IOs ms
  uint64 io_ms = 8;
  // BytesUsed
  uint64 bytes_used = 9;
  // Interval in ms during which stats were collected
  uint64 interval_ms = 10;
}

// Provides details on exclusive and shared storage used by
// snapshot/volume specifically for copy-on-write(COW) snapshots. Deletion
// of snapshots and overwirte of volume will affect the exclusive storage
// used by the other dependent snaps and parent volume.
message CapacityUsageInfo {
  // Storage consumed exclusively by this single snapshot. Deletion of this
  // snapshot may increase the free storage available by this amount.
  int64 exclusive_bytes = 1;
  // Storage consumed by this snapshot that is shared with parent and children
  int64 shared_bytes = 2;
  // TotalBytes used by this volume
  int64 total_bytes = 3;
}

// Alert is a structure that represents an alert object
message Alert {
  // Id for Alert
  int64 id = 1;
  // Severity of the Alert
  SeverityType severity = 2;
  // AlertType user defined alert type
  int64 alert_type = 3;
  // Message describing the Alert
  string message = 4;
  //Timestamp when Alert occured
  google.protobuf.Timestamp timestamp = 5;
  // ResourceId where Alert occured
  string resource_id = 6;
  // Resource where Alert occured
  ResourceType resource = 7;
  // Cleared Flag
  bool cleared = 8;
  // Time-to-live in seconds for this Alert
  uint64 ttl = 9;
  // UniqueTag helps identify a unique alert for a given resouce
  string unique_tag = 10;
  // Count of such alerts raised so far.
  int64 count = 11;
  // Timestamp when such alert was raised the very first time.
  google.protobuf.Timestamp first_seen = 12;
}

// SdkAlertsTimeSpan to store time window information.
message SdkAlertsTimeSpan {
    //Start timestamp when Alert occured
    google.protobuf.Timestamp start_time = 1;
    //End timestamp when Alert occured
    google.protobuf.Timestamp end_time = 2;
}

// SdkAlertsCountSpan to store count range information.
message SdkAlertsCountSpan {
    // Min count of such alerts raised so far.
    int64 min_count = 1;
    // Max count of such alerts raised so far.
    int64 max_count = 2;
}

// SdkAlertsOption contains options for filtering alerts.
message SdkAlertsOption {
    oneof opt {
        // Query using minimum severity type.
        SeverityType min_severity_type = 1;
        // Query using cleared flag.
        bool is_cleared = 2;
        // Query using a time span during which alert was last seen.
        SdkAlertsTimeSpan time_span = 3;
        // Query using a count span in which alert count exists.
        SdkAlertsCountSpan count_span = 4;
    }
}

// SdkAlertsResourceTypeQuery queries for alerts using only resource id.
message SdkAlertsResourceTypeQuery {
    // Resource type used to build query.
    ResourceType resource_type = 1;
}

// SdkAlertsAlertTypeQuery queries for alerts using alert type
// and it requires that resource type be provided as well.
message SdkAlertsAlertTypeQuery {
    // Resource type used to build query.
    ResourceType resource_type = 1;
    // Alert type used to build query.
    int64 alert_type = 2;
}

// SdkAlertsResourceIdQuery queries for alerts using resource id
// and it requires that both alert type and resource type be provided
// as well.
message SdkAlertsResourceIdQuery {
    // Resource type used to build query.
    ResourceType resource_type = 1;
    // Alert type used to build query.
    int64 alert_type = 2;
    // Resource ID used to build query.
    string resource_id = 3;
}

// SdkAlertsQuery is one of the query types and a list of options.
// Each query object is one of the three query types and a list of
// options.
message SdkAlertsQuery {
    // One of the query types can be used to build SdkAlertsQuery.
    oneof query {
        // Query only using resource type.
        SdkAlertsResourceTypeQuery resource_type_query = 1;
        // Query using alert type and resource type.
        SdkAlertsAlertTypeQuery alert_type_query = 2;
        // Query using resource id, alert type and resource type.
        SdkAlertsResourceIdQuery resource_id_query = 3;
    }
    // Opts is a list of options associated with one of the queries.
    repeated SdkAlertsOption opts = 4;
}

// SdkAlertsEnumerateRequest is a request message to enumerate alerts.
message SdkAlertsEnumerateWithFiltersRequest {
    // It is a list of queries to find matching alerts.
    // Output of each of these queries is added to a global pool
    // and returned as output of an RPC call.
    // In that sense alerts are fetched if they match any of the
    // queries.
    repeated SdkAlertsQuery queries = 1;
}

// SdkAlertsEnumerateResponse is a list of alerts.
message SdkAlertsEnumerateWithFiltersResponse {
    // Response contains a list of alerts.
    repeated Alert alerts = 1;
}

// SdkAlertsDeleteRequest is a request message to delete alerts.
message SdkAlertsDeleteRequest {
  // It takes a list of queries to find matching alerts.
  // Matching alerts are deleted.
  repeated SdkAlertsQuery queries = 1;
}

// SdkAlertsDeleteResponse is empty.
message SdkAlertsDeleteResponse {}

// OpenStorageAlerts defines rpc's for alerts.
service OpenStorageAlerts {
    // Allows querying alerts.
    //
    // EnumerateWithFilters allows 3 different types of queries as defined below:
    //
    // * Query that takes only resource type as input
    // * Query that takes resource type and alert type as input and
    // * Query that takes resource id, alert type and resource type as input.
    //
    // #### Input
    // SdkAlertsEnumerateRequest takes a list of such queries and the returned
    // output is a collective ouput from each of these queries. In that sense,
    // the filtering of these queries has a behavior of OR operation.
    // Each query also has a list of optional options. These options allow
    // narrowing down the scope of alerts search. These options have a
    // behavior of an AND operation.
    //
    // #### Examples
    // To search by a resource type in a given time window would require
    // initializing SdkAlertsResourceTypeQuery query and pass in
    // SdkAlertsTimeSpan option into SdkAlertsQuery struct and finally
    // packing any other such queries into SdkAlertsEnumerateRequest object.
    // Alternatively, to search by both resource type and alert type, use
    // SdkAlertsAlertTypeQuery as query builder.
    // Finally to search all alerts of a given resource type and some
    // alerts of another resource type but with specific alert type,
    // use two queries, first initialized with SdkAlertsResourceTypeQuery
    // and second initialized with SdkAlertsAlertTypeQuery and both
    // eventually packed as list in SdkAlertsEnumerateRequest.
    rpc EnumerateWithFilters(SdkAlertsEnumerateWithFiltersRequest)
      returns (stream SdkAlertsEnumerateWithFiltersResponse) {
        option(google.api.http) = {
          post: "/v1/alerts/filters"
          body: "*"
        };
    }

    // Delete alerts
    //
    // #### Delete
    // Delete allows 3 different types of queries as defined below:
    //
    // * Query that takes only resource type as input
    // * Query that takes resource type and alert type as input and
    // * Query that takes resource id, alert type and resource type as input.
    //
    // #### Input
    // SdkAlertsDeleteRequest takes a list of such queries and all alerts
    // that match at least one of the queries are deleted.
    rpc Delete(SdkAlertsDeleteRequest)
      returns (SdkAlertsDeleteResponse) {
        option(google.api.http) = {
          post: "/v1/alerts"
          body: "*"
        };
    }
}

// Define a schedule policy request
message SdkSchedulePolicyCreateRequest {
    // Schedule Policy
    SdkSchedulePolicy schedule_policy = 1;
}

// Alerts is an array of Alert objects
// swagger:model
message Alerts {
  repeated Alert alert = 1;
}

// ObjectstoreInfo is a structure that has current objectstore info
// swagger:model
message ObjectstoreInfo {
    // UUID of objectstore
    string uuid = 1;
    // VolumeID of volume used by object store
    string volume_id = 2;
    // Enable/Disable created objectstore
    bool enabled = 3;
    // Status of objectstore running/failed
    string status = 4;
    // Action being taken on this objectstore
    int64 action = 5;
    // AccessKey for login into objectstore
    string access_key = 6;
    // SecretKey for login into objectstore
    string secret_key = 7;
    // Endpoints for accessing objectstore
    repeated string endpoints = 8;
    // CurrentEndpoint on which objectstore server is accessible
    string current_endpoint = 9;
    // AccessPort is objectstore server port
    int64 access_port = 10;
    // Region for this objectstore
    string region = 11;
}

// VolumeCreateRequest is a structure that has the locator, source and spec
// to create a volume
// swagger:model
message VolumeCreateRequest {
  // User specified volume name and labels
  VolumeLocator locator = 1;
  // Source to create volume
  Source source = 2;
  // The storage spec for the volume
  VolumeSpec spec = 3;
}

// VolumeResponse is a structure that wraps an error.
// swagger:response volumeResponse
message VolumeResponse {
  // Error message
  //
  // in: body
  // Required: true
  string error = 1;
}

// VolumeCreateResponse
// swagger:response volumeCreateResponse
message VolumeCreateResponse {
  // ID of the newly created volume
  //
  // in: body
  // Required: true
  string id = 1;
  // Volume Response
  //
  // in: body
  // Required: true
  VolumeResponse volume_response = 2;
}

// VolumeStateAction specifies desired actions.
// swagger:model
message VolumeStateAction {
  // Attach or Detach volume
  VolumeActionParam attach = 1;
  // Mount or unmount volume
  VolumeActionParam mount = 2;
  // MountPath Path where the device is mounted
  string mount_path = 3;
  // DevicePath Path returned in attach
  string device_path = 4;
}

// VolumeSet specifies a request to update a volume.
// swagger:model
message VolumeSetRequest {
  // User specified volume name and labels
  VolumeLocator locator = 1;
  // The storage spec for the volume
  VolumeSpec spec = 2;
  // State modification on this volume.
  VolumeStateAction action = 3;
  // additional options
  // required for the Set operation.
  map<string, string> options = 4;
}

// VolumeSetResponse
// swagger:response volumeSetResponse
message VolumeSetResponse {
  // Volume
  //
  // in: body
  // Required: true
  Volume volume = 1;
  //VolumeResponse
  //
  // in: body
  // Required: true
  VolumeResponse volume_response = 2;
}

// SnapCreateRequest specifies a request to create a snapshot of given volume.
// swagger:parameters snapVolume
message SnapCreateRequest {
  // volume id
  string id = 1;
  VolumeLocator locator = 2;
  bool readonly = 3;
  // NoRetry indicates not to retry snapshot creation in the background.
  bool no_retry = 4;
}

// SnapCreateRequest specifies a response that get's returned when creating a snapshot.
// swagger:response snapCreateResponse
message SnapCreateResponse {
  // VolumeCreateResponse
  //
  // in: body
  // Required: true
  VolumeCreateResponse volume_create_response = 1;
}

// VolumeInfo
// swagger:model
message VolumeInfo {
  string volume_id = 1;
  string path = 2;
  VolumeSpec storage = 3;
}

// VolumeConsumer identifies a consumer for a Volume. An example of a VolumeConsumer
// would be a Pod in Kubernetes who has mounted the PersistentVolumeClaim for the
// Volume
// swagger: model
message VolumeConsumer {
  // Name is the name of the volume consumer
  string name = 1;
  // Namespace is the namespace of the volume consumer
  string namespace = 2;
  // Type is the type of the consumer. E.g a Kubernetes pod
  string type = 3;
  // NodeID is the identifier of the node on which the consumer is running. This
  // identifier would be from the perspective of the container runtime or
  // orchestrator under which the volume consumer resides. For example, NodeID
  //  can be name of a minion in Kubernetes.
  string node_id = 4;
  // OwnerName is the name of the entity who owns this volume consumer
  string owner_name = 5;
  // OwnerType is the type of the entity who owns this volume consumer. The type would
  // be from the perspective of the container runtime or the orchestrator under which
  // the volume consumer resides. For e.g OwnerType can be a Deployment in Kubernetes.
  string owner_type = 6;
}

// GraphDriverChanges represent a list of changes between the filesystem layers
// specified by the ID and Parent.  // Parent may be an empty string, in which
// case there is no parent.
// Where the Path is the filesystem path within the layered filesystem
// swagger:model
message GraphDriverChanges {
  string path = 1;
  GraphDriverChangeType kind = 2;
}

// ClusterResponse specifies a response that gets returned when requesting the cluster
// swagger:response clusterResponse
message ClusterResponse {
  // Error code
  //
  // in: body
  string error = 1;
}

// Active Request
// swagger:model
message ActiveRequest {
  map<int64, string> ReqestKV = 1;
}

// Active Requests
// swagger:model
message ActiveRequests {
  int64 RequestCount = 1;
  repeated ActiveRequest ActiveRequest = 2;
}

// GroupSnapCreateRequest specifies a request to create a snapshot of given group.
// swagger:model
message GroupSnapCreateRequest {
  string id = 1;
  map<string, string> Labels = 2;
  repeated string volume_ids = 3;
}

// GroupSnapCreateRequest specifies a response that get's returned when creating a group snapshot.
// swagger:response groupSnapCreateResponse
message GroupSnapCreateResponse {
  // Created snapshots
  //
  // in: body
  // Required: true
  map<string, SnapCreateResponse> snapshots = 1;
  // Error message
  //
  // in: body
  // Required: true
  string error = 2;
}

// StorageNode describes the state of the node
message StorageNode {
  // Id of the node
  string id = 1;
  // Cpu usage of the node
  double cpu = 2;
  // Total memory of the node
  uint64 mem_total = 3;
  // Used memory of the node
  uint64 mem_used = 4;
  // Free memory of the node
  uint64 mem_free = 5;
  // Average load (percentage)
  int64 avg_load = 6;
  // Node status
  Status status = 7;
  // List of disks on the node
  map<string, StorageResource> disks = 9;
  // List of storage pools this node supports
  repeated StoragePool pools = 10;
  // Management IP
  string mgmt_ip = 11;
  // Data IP
  string data_ip = 12;
  // Hostname of the node
  string hostname = 15;
  // User defined labels for the node
  map<string, string> node_labels = 16;
  // SchedulerNodeName is name of the node in scheduler context. It can be
  // empty if unable to get the name from the scheduler.
  string scheduler_node_name = 17;
}

// StorageCluster represents the state and information about the cluster
message StorageCluster {
  // Status of the cluster
  Status status = 1;
  // Id of the cluster
  string id = 2;
  // Name of the cluster
  string name = 3;
}

// OpenStorageIdentity service provides methods to obtain information
// about the cluster
service OpenStorageIdentity {

  // Capabilities returns the supported services by the cluster.
  // This allows SDK implementations to advertise their supported
  // services as the API matures. With this information, clients
  // can determine supported services from storage clusters at
  // different versions.
  rpc Capabilities(SdkIdentityCapabilitiesRequest)
    returns (SdkIdentityCapabilitiesResponse) {
      option(google.api.http) = {
        get: "/v1/identities/capabilities"
      };
    }

  // Version returns version information about the system.
  rpc Version(SdkIdentityVersionRequest)
    returns (SdkIdentityVersionResponse) {
      option(google.api.http) = {
        get: "/v1/identities/version"
      };
    }

}

// OpenStorageCluster service provides the methods to manage the cluster
service OpenStorageCluster {
  // InspectCurrent returns information about the current cluster
  rpc InspectCurrent(SdkClusterInspectCurrentRequest)
    returns (SdkClusterInspectCurrentResponse) {
      option(google.api.http) = {
        get: "/v1/clusters/inspectcurrent"
      };
    }
}

// OpenStorageClusterPair service provides the methods to manage a cluster pair
service OpenStorageClusterPair{
  // Creates Pair with a remote cluster and returns details about the remote cluster
  //
  // ##### Example
  // {% codetabs name="Golang", type="go" -%}
  // id, err := client.Create(context.Background(), &api.SdkClusterPairCreateRequest {
  //   Request : &api.ClusterPairCreateRequest {
  //                  RemoteClusterIp: "127.0.0.1",
  //                  RemoteClusterPort: 12345,
  //                  RemoteClusterToken: "<Auth-Token>",
  //                  SetDefault: true,
  //              }
  //        })
  // {%- endcodetabs %}
  rpc Create(SdkClusterPairCreateRequest)
    returns (SdkClusterPairCreateResponse){
      option(google.api.http) = {
        post: "/v1/clusterpairs"
        body: "*"
      };
    }

  // Inspect information about a cluster pair
  rpc Inspect(SdkClusterPairInspectRequest)
    returns (SdkClusterPairInspectResponse){
      option(google.api.http) = {
        get: "/v1/clusterpairs/inspect/{id}"
      };
    }

  // Enumerate returns list of cluster pairs
  rpc Enumerate(SdkClusterPairEnumerateRequest)
    returns (SdkClusterPairEnumerateResponse){
      option(google.api.http) = {
        get: "/v1/clusterpairs"
      };
    }

  // GetToken returns a auth token
  rpc GetToken(SdkClusterPairGetTokenRequest)
    returns(SdkClusterPairGetTokenResponse){
      option(google.api.http)={
        get: "/v1/clusterpairs/token"
      };
    }

  // ResetToken returns a auth token
  rpc ResetToken(SdkClusterPairResetTokenRequest)
    returns(SdkClusterPairResetTokenResponse){
      option(google.api.http)={
        post: "/v1/clusterpairs/token"
        body: "*"
      };
    }

  // Delete a cluster pair
  rpc Delete(SdkClusterPairDeleteRequest)
    returns (SdkClusterPairDeleteResponse){
      option(google.api.http) = {
        delete: "/v1/clusterpairs/{cluster_id}"
      };
    }
}

// OpenStorageNode is a service used to manage nodes in the cluster
service OpenStorageNode {
  // Inspect returns information about the specified node
  rpc Inspect(SdkNodeInspectRequest)
    returns (SdkNodeInspectResponse) {
      option(google.api.http) = {
        get: "/v1/nodes/inspect/{node_id}"
      };
    }

  // InspectCurrent returns information about the storage node
  // where the client is currently connected to.
  rpc InspectCurrent(SdkNodeInspectCurrentRequest)
    returns (SdkNodeInspectCurrentResponse) {
      option(google.api.http) = {
        get: "/v1/nodes/inspectcurrent"
      };
    }

  // Enumerate returns the ids of all the nodes in the current cluster
  rpc Enumerate(SdkNodeEnumerateRequest)
    returns (SdkNodeEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/nodes"
      };
    }
}

// OpenStorageVolume is a service used to manage the volumes of a storage system
service OpenStorageVolume {

  // Create creates a volume according to the specification provided
  //
  // ##### Example
  // {% codetabs name="Golang", type="go" -%}
  // id, err := client.Create(context.Background(), &api.SdkVolumeCreateRequest{
  //   Name: "volume-12345-east",
  //   Spec: &api.VolumeSpec {
  //     Size: 1234567,
  //   },
  // })
  // {%- language name="Python", type="py" -%}
  // en_resp = client.Create(api_pb2.SdkVolumeCreateRequest(
  //   name="volume-12345-east",
  //   spec=api_pb2.VolumeSpec(size=1234567)))
  // {%- endcodetabs %}
  rpc Create(SdkVolumeCreateRequest)
    returns (SdkVolumeCreateResponse) {
      option(google.api.http) = {
        post: "/v1/volumes"
        body: "*"
      };
    }

  // Clone creates a new writable volume cloned from an existing volume
  rpc Clone(SdkVolumeCloneRequest)
    returns (SdkVolumeCloneResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/clone"
        body: "*"
      };
    }

  // Delete deletes the provided volume
  rpc Delete(SdkVolumeDeleteRequest)
    returns (SdkVolumeDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/volumes/{volume_id}"
      };
    }

  // Inspect returns information about a volume
  rpc Inspect(SdkVolumeInspectRequest)
    returns (SdkVolumeInspectResponse) {
      option(google.api.http) = {
        get: "/v1/volumes/inspect/{volume_id}"
      };
    }

  // Update provides a method for manipulating the specification and attributes of a volume.
  // Set can be used to resize a volume, update labels, change replica count, and much more.
  rpc Update(SdkVolumeUpdateRequest)
    returns (SdkVolumeUpdateResponse) {
      option(google.api.http) = {
        put: "/v1/volumes/{volume_id}"
        body: "*"
      };
    }

  // Stats returns the statistics for the requested volume
  rpc Stats(SdkVolumeStatsRequest)
    returns (SdkVolumeStatsResponse) {
      option(google.api.http) = {
        get: "/v1/volumes/stats/{volume_id}"
      };
    }

  // CapacityUsage returns volume/snapshot's capacity usage details
  //
  // ##### Error codes:
  //
  // * codes.Aborted : Command was aborted and only total_bytes field is valid
  // * code.Unimmplemented : Command is not suported this kernel.Only total_bytes
  // field is valid;
  rpc CapacityUsage(SdkVolumeCapacityUsageRequest)
    returns (SdkVolumeCapacityUsageResponse) {
      option(google.api.http) = {
        get: "/v1/volumes/usage/{volume_id}"
      };
    }

  // Enumerate returns a list of volume ids
  rpc Enumerate(SdkVolumeEnumerateRequest)
    returns (SdkVolumeEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/volumes"
      };
    }

  // Enumerate returns a list of volume ids that match the labels if any are provided.
  rpc EnumerateWithFilters(SdkVolumeEnumerateWithFiltersRequest)
    returns (SdkVolumeEnumerateWithFiltersResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/filters"
        body: "*"
      };
    }

  // SnapshotCreate creates a snapshot of a volume. This creates an immutable (read-only),
  // point-in-time snapshot of a volume. To create a new writable volume from
  // a snapshot, please use OpenStorageVolume.Clone().
  rpc SnapshotCreate(SdkVolumeSnapshotCreateRequest)
    returns (SdkVolumeSnapshotCreateResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/snapshots"
        body: "*"
      };
    }

  // SnapshotRestore restores a volume to a specified snapshot
  rpc SnapshotRestore(SdkVolumeSnapshotRestoreRequest)
    returns (SdkVolumeSnapshotRestoreResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/snapshots/restore"
        body: "*"
      };
    }

  // SnapshotEnumerate returns a list of snapshots for a specific volume
  rpc SnapshotEnumerate(SdkVolumeSnapshotEnumerateRequest)
    returns (SdkVolumeSnapshotEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/volumes/snapshots/{volume_id}"
      };
    }

  // SnapshotEnumerate returns a list of snapshots.
  // To filter all the snapshots for a specific volume which may no longer exist,
  // specifiy a volume id.
  // Labels can also be used to filter the snapshot list.
  // If neither are provided all snapshots will be returned.
  rpc SnapshotEnumerateWithFilters(SdkVolumeSnapshotEnumerateWithFiltersRequest)
    returns (SdkVolumeSnapshotEnumerateWithFiltersResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/snapshots/{volume_id}/filters"
        body: "*"
      };
    }

  // Sets the snapshot schedules. This information is saved in the VolumeSpec.snapshot_schedule
  // as `policy=<name>,...`. This function will overwrite any policy values
  // in the volume. To delete the policies in the volume send no policies.
  rpc SnapshotScheduleUpdate(SdkVolumeSnapshotScheduleUpdateRequest)
    returns (SdkVolumeSnapshotScheduleUpdateResponse) {
      option(google.api.http) = {
        post: "/v1/volumes/snapshot/schedules/{volume_id}"
        body: "*"
      };
    }
}

// OpenStorageMountAttach is a service used to manage node access to a volume.
// Note, these APIs are here for testing or diagnostics purposes only. In normal
// operations, the Container Orchestration (CO) system is managing all mount
// and attach calls through the CSI interface. The normal usage is once volumes
// are created, to let the CO manage the node access functions to the volume.
service OpenStorageMountAttach {

  // Attach attaches device to the host that the client is communicating with.
  rpc Attach(SdkVolumeAttachRequest)
    returns (SdkVolumeAttachResponse) {
      option(google.api.http) = {
        post: "/v1/mountattach/attach"
        body: "*"
      };
    }

  // Detaches a the volume from the host
  rpc Detach(SdkVolumeDetachRequest)
    returns (SdkVolumeDetachResponse) {
      option(google.api.http) = {
        post: "/v1/mountattach/detach"
        body: "*"
      };
    }

  // Mount mounts an attached volume in the host that the client is communicating with
  rpc Mount(SdkVolumeMountRequest)
    returns(SdkVolumeMountResponse) {
      option(google.api.http) = {
        post: "/v1/mountattach/mount"
        body: "*"
      };
    }

  // Unmount unmounts a mounted volume in the host that the client is communicating with
  rpc Unmount(SdkVolumeUnmountRequest)
      returns(SdkVolumeUnmountResponse) {
      option(google.api.http) = {
        post: "/v1/mountattach/unmount"
        body: "*"
      };
    }
}

// OpenStorageMigrate is a service used to manage migration of volumes
service OpenStorageMigrate {
  // Start a migration operation
  rpc Start(SdkCloudMigrateStartRequest)
    returns (SdkCloudMigrateStartResponse) {
      option(google.api.http) = {
        post: "/v1/volumemigrate"
        body: "*"
      };
    }

  // Cancel a migration operation
  rpc Cancel(SdkCloudMigrateCancelRequest)
    returns (SdkCloudMigrateCancelResponse) {
      option(google.api.http) = {
        post: "/v1/volumemigrate/cancel"
        body: "*"
      };
    }

  // Inspect the status of migration operation
  rpc Status(SdkCloudMigrateStatusRequest)
    returns (SdkCloudMigrateStatusResponse) {
      option(google.api.http) = {
        get: "/v1/volumemigrate"
      };
    }
}

// OpenStorageObjectstore is a service used to manage object store services on volumes
service OpenStorageObjectstore {

  // Inspect returns information about the object store endpoint
  rpc Inspect(SdkObjectstoreInspectRequest)
    returns(SdkObjectstoreInspectResponse){
      option(google.api.http) = {
        get: "/v1/objectstores/inspect/{objectstore_id}"
      };
    }

  // Creates creates an object store endpoint on specified volume
  rpc Create(SdkObjectstoreCreateRequest)
    returns(SdkObjectstoreCreateResponse){
      option(google.api.http) = {
        post: "/v1/objectstores"
        body: "*"
      };
    }

  // Delete destroys the object store endpoint on the volume
  rpc Delete(SdkObjectstoreDeleteRequest)
    returns(SdkObjectstoreDeleteResponse){
      option(google.api.http) = {
        delete: "/v1/objectstores/{objectstore_id}"
      };
    }

  // Updates provided objectstore status.
  // This call can be used to stop and start the server while maintaining the same
  // object storage id.
  rpc Update(SdkObjectstoreUpdateRequest)
    returns(SdkObjectstoreUpdateResponse){
      option(google.api.http) ={
        put: "/v1/objectstores/{objectstore_id}"
        body: "*"
      };
  }
}

// OpenStorageCredentials is a service used to manage the cloud credentials
// which can then be used by the OpenStorageCloudBackup service
service OpenStorageCredentials {

  // Create is used to submit cloud credentials. It will return an
  // id of the credentials once they are verified to work.
  //
  // ##### Example
  // {% codetabs name="Golang", type="go" -%}
  // id, err := client.Create(context.Background(), &api.SdkCredentialCreateRequest{
  //     Name: "awscred",
  //     CredentialType: &api.SdkCredentialCreateRequest_AwsCredential{
  //       AwsCredential: &api.SdkAwsCredentialRequest{
  //       AccessKey: "dummy-access",
  //       SecretKey: "dummy-secret",
  //       Endpoint:  "dummy-endpoint",
  //       Region:    "dummy-region",
  //     },
  //   },
  // })
  // {%- language name="Python", type="py" -%}
  // en_resp = client.Create(api_pb2.SdkCredentialCreateRequest(
  //   name='awscred',
  //   aws_credential=api_pb2.SdkAwsCredentialRequest(
  //     access_key='dummy-access',
  //     secret_key='dumm-secret',
  //     endpoint='dummy-endpoint',
  //     region='dummy-region')))
  // {%- endcodetabs %}
  rpc Create(SdkCredentialCreateRequest)
    returns (SdkCredentialCreateResponse) {
      option(google.api.http) = {
        post: "/v1/credentials"
        body: "*"
      };
    }

  // Enumerate returns a list of credential ids
  rpc Enumerate(SdkCredentialEnumerateRequest)
    returns (SdkCredentialEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/credentials"
      };
    }

  // Inspect returns the information about a credential, but does not return the secret key.
  rpc Inspect(SdkCredentialInspectRequest)
    returns (SdkCredentialInspectResponse) {
      option(google.api.http) = {
        get: "/v1/credentials/inspect/{credential_id}"
      };
    }

  // Delete a specified credential
  rpc Delete(SdkCredentialDeleteRequest)
    returns (SdkCredentialDeleteResponse){
      option(google.api.http) = {
        delete: "/v1/credentials/{credential_id}"
      };
    }

  // Validate is used to validate credentials
  rpc Validate(SdkCredentialValidateRequest)
    returns (SdkCredentialValidateResponse) {
      option(google.api.http) = {
        get: "/v1/credentials/validate/{credential_id}"
      };
    }
}

// OpenStorageSchedulePolicy service is used to manage the automated
// snapshots for a volume
service OpenStorageSchedulePolicy {

  // Create creates a new snapshot schedule. They can be setup daily,
  // weekly, or monthly.
  rpc Create(SdkSchedulePolicyCreateRequest)
    returns (SdkSchedulePolicyCreateResponse) {
      option(google.api.http) = {
        post: "/v1/schedulepolicies"
        body: "*"
      };
    }

  // Update a snapshot schedule
  rpc Update(SdkSchedulePolicyUpdateRequest)
    returns (SdkSchedulePolicyUpdateResponse) {
      option(google.api.http) = {
        put: "/v1/schedulepolicies"
        body: "*"
      };
    }

  // Enumerate returns a list of schedules
  rpc Enumerate(SdkSchedulePolicyEnumerateRequest)
    returns (SdkSchedulePolicyEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/schedulepolicies"
      };
    }

  // Inspect returns information about a specified schedule
  rpc Inspect(SdkSchedulePolicyInspectRequest)
  returns (SdkSchedulePolicyInspectResponse) {
    option(google.api.http) = {
      get: "/v1/schedulepolicies/inspect/{name}"
    };
  }

  // Delete removes a snapshot schedule
  rpc Delete(SdkSchedulePolicyDeleteRequest)
    returns (SdkSchedulePolicyDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/schedulepolicies/{name}"
      };
    }
}

// OpenStorageCloudBackup service manages backing up volumes to a cloud
// location like Amazon, Google, or Azure.
//
// #### Backup
// To create a backup, you must first call the Create() call for a specified
// volume. To see the status of this request, use Status() which returns
// a map where the keys are the source volume id.
//
// #### Restore
// To restore, you would pass a `backup_id` of a successful backup.
// `backup_id` can be retreived by calling Enumerate() for a specified volume.
// Pass this `backup_id` and a new volume name to Restore() to start
// restoring a new volume from an existing backup. To see the status of this
// restore, pass volume id returned by Restore() to input to Status()
//
service OpenStorageCloudBackup {

  // Creates a backup request for a specified volume. Use
  // OpenStorageCloudBackup.Status() to get the current status of the
  // backup request.
  rpc Create(SdkCloudBackupCreateRequest)
    returns (SdkCloudBackupCreateResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups"
        body: "*"
      };
    }

  // Restore creates a new volume from a backup id. The newly created volume
  // has an ha_level (number of replicas) of only 1. To increase the number of
  // replicas, use OpenStorageVolume.Set() to change the ha_level.
  rpc Restore(SdkCloudBackupRestoreRequest)
    returns (SdkCloudBackupRestoreResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/restore"
        body: "*"
      };
    }

  // Deletes a backup stored in the cloud. If the backup is an incremental
  // backup and other backups are dependent on it, it will not be able to be deleted.
  rpc Delete(SdkCloudBackupDeleteRequest)
    returns (SdkCloudBackupDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/cloudbackups/backup/{backup_id}"
      };
    }

  // DeleteAll deletes all the backups in the cloud for the specified volume.
  rpc DeleteAll(SdkCloudBackupDeleteAllRequest)
    returns (SdkCloudBackupDeleteAllResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/deleteall"
        body: "*"
      };
    }

  // Return a list of backups for the specified volume
  rpc EnumerateWithFilters(SdkCloudBackupEnumerateWithFiltersRequest)
    returns (SdkCloudBackupEnumerateWithFiltersResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/enumerate/filters"
        body: "*"
      };
    }

  // Status returns the status of any cloud backups of a volume
  rpc Status(SdkCloudBackupStatusRequest)
    returns (SdkCloudBackupStatusResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/status"
        body: "*"
      };
    }

  // Catalog returns a list of the contents in the backup
  rpc Catalog(SdkCloudBackupCatalogRequest)
    returns (SdkCloudBackupCatalogResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/catalog"
        body: "*"
      };
    }

  // History returns a list of backups for a specified volume
  rpc History(SdkCloudBackupHistoryRequest)
    returns (SdkCloudBackupHistoryResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackups/history/{src_volume_id}"
      };
    }

  // StateChange can be used to stop, pause, and restart a backup
  rpc StateChange(SdkCloudBackupStateChangeRequest)
    returns (SdkCloudBackupStateChangeResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/statechange"
        body: "*"
      };
    }

  // Create cloud backup schedule
  rpc SchedCreate(SdkCloudBackupSchedCreateRequest)
    returns (SdkCloudBackupSchedCreateResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackups/schedules"
        body: "*"
      };
    }

  // Delete cloud backup schedule
  rpc SchedDelete(SdkCloudBackupSchedDeleteRequest)
    returns (SdkCloudBackupSchedDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/cloudbackups/schedules/{backup_schedule_id}"
      };
    }

  // Enumerate cloud backup schedules
  rpc SchedEnumerate(SdkCloudBackupSchedEnumerateRequest)
    returns (SdkCloudBackupSchedEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackups/schedules"
      };
    }
}

// Empty response
message SdkSchedulePolicyCreateResponse {
}

// Define a request to update a schedule policy
message SdkSchedulePolicyUpdateRequest {
  // Schedule Policy
  SdkSchedulePolicy schedule_policy = 1;
}

// Empty response
message SdkSchedulePolicyUpdateResponse {
}

// Empty request
message SdkSchedulePolicyEnumerateRequest {
}

// Defines a schedule policy enumerate response
message SdkSchedulePolicyEnumerateResponse {
  // List of Schedule Policy
  repeated SdkSchedulePolicy policies = 1;
}

// Define a schedule policy inspection request
message SdkSchedulePolicyInspectRequest {
  // Name of the schedule Policy
  string name = 1;
}

// Defines a schedule policy inspection response
message SdkSchedulePolicyInspectResponse {
  // List of Schedule Policy
  SdkSchedulePolicy policy = 1;
}

// Define schedule policy deletion request
message SdkSchedulePolicyDeleteRequest {
  // Name of the schedule policy
  string name = 1;
}

// Empty response
message SdkSchedulePolicyDeleteResponse {
}

// Defines times of day
enum SdkTimeWeekday {
  // Sunday
  SdkTimeWeekdaySunday = 0;
  // Monday
  SdkTimeWeekdayMonday = 1;
  // Tuesday
  SdkTimeWeekdayTuesday = 2;
  // Wednesday
  SdkTimeWeekdayWednesday = 3;
  // Thursday
  SdkTimeWeekdayThursday = 4;
  // Friday
  SdkTimeWeekdayFriday = 5;
  // Saturday
  SdkTimeWeekdaySaturday = 6;
}

// Defines a daily schedule
message SdkSchedulePolicyIntervalDaily {
  // Range: 0-23
  int32 hour = 1;
  // Range: 0-59
  int32 minute = 2;
}

// Defines a weekly schedule
message SdkSchedulePolicyIntervalWeekly{
  SdkTimeWeekday day = 1;
  // Range: 0-23
  int32 hour = 2;
  // Range: 0-59
  int32 minute = 3;
}

// Defines a monthly schedule
message SdkSchedulePolicyIntervalMonthly{
  // Range: 1-28
  int32 day = 1;
  // Range: 0-59
  int32 hour = 2;
  // Range: 0-59
  int32 minute = 3;
}

// Defines a periodic schedule
message SdkSchedulePolicyIntervalPeriodic{
  // Specify the number of seconds between intervals
  int64 seconds = 1;
}

// Defines a schedule policy interval
message SdkSchedulePolicyInterval {
  // Number of instances to retain
  int64 retain = 1;

  // Start oneof at field number 200 to allow for expansion
  oneof period_type {
    // Daily policy
    SdkSchedulePolicyIntervalDaily daily = 200;
    // Weekly policy
    SdkSchedulePolicyIntervalWeekly weekly = 201;
    // Monthly policy
    SdkSchedulePolicyIntervalMonthly monthly = 202;
    // Periodic policy
    SdkSchedulePolicyIntervalPeriodic periodic = 203;
  }
}

// Defines a schedule policy
message SdkSchedulePolicy {
  // Name of the schedule policy
  string name = 1;
  // Schedule policies
  repeated SdkSchedulePolicyInterval schedules = 2;
}

// Defines a request to create credentials
message SdkCredentialCreateRequest {
  // Name of the credential
  string name = 1;
  // (optional) Name of bucket
  string bucket = 2;
  // (optional) Key used to encrypt the data
  string encryption_key = 3;

  // Start at field number 200 to allow for expansion
  oneof credential_type {
    // Credentials for AWS/S3
    SdkAwsCredentialRequest aws_credential = 200;
    // Credentials for Azure
    SdkAzureCredentialRequest azure_credential = 201;
    // Credentials for Google
    SdkGoogleCredentialRequest google_credential = 202;
  }
}

// Defines a response from creating a credential
message SdkCredentialCreateResponse {
  // Id of the credentials
  string credential_id = 1;
}

// Defines credentials for Aws/S3 endpoints
message SdkAwsCredentialRequest {
  // Access key
  string access_key = 1;
  // Secret key
  string secret_key = 2;
  // Endpoint
  string endpoint = 3;
  // Region
  string region = 4;
  // (optional) Disable SSL connection
  bool disable_ssl = 5;
}

// Defines credentials for Azure
message SdkAzureCredentialRequest {
  // Account name
  string account_name = 1;
  // Account key
  string account_key = 2;
}

// Defines credentials for Google
message SdkGoogleCredentialRequest {
  // Project ID
  string project_id = 1;
  // JSON Key
  string json_key = 2;
}

// Defines the response for AWS/S3 credentials
message SdkAwsCredentialResponse {
  // Access key
  string access_key = 2;
  // Endpoint
  string endpoint = 3;
  // Region
  string region = 4;
  // (optional) Disable SSL connection
  bool disable_ssl = 5;
}

// Defines the response for Azure credentials
message SdkAzureCredentialResponse {
  // Account name
  string account_name = 2;
}

// Defines the response for Google credentials
message SdkGoogleCredentialResponse {
  // Project ID
  string project_id = 2;
}

// Empty request
message SdkCredentialEnumerateRequest {
}

// Defines response for a enumeration of credentials
message SdkCredentialEnumerateResponse {
  // List of credentials
  repeated string credential_ids = 1;
}

// Defines the request to inspection for credentials
message SdkCredentialInspectRequest {
  // Id of the credential
  string credential_id = 1;
}

// Defines the response to an inspection of a credential.
// This response uses OneOf proto style. Depending on your programming language
// you will need to check if the value of credential_type is one of the ones below.
message SdkCredentialInspectResponse {
  // Credential id
  string credential_id = 1;
  // Name of the credential
  string name = 2;
  // (optional) Name of bucket
  string bucket = 3;

  // Start at field number 200 for expansion support
  oneof credential_type {
    // Aws credentials
    SdkAwsCredentialResponse aws_credential = 200;
    // Azure credentials
    SdkAzureCredentialResponse azure_credential = 201;
    // Google credentials
    SdkGoogleCredentialResponse google_credential = 202;
  }
}

// Defines the request to delete credentials
message SdkCredentialDeleteRequest {
  // Id for credentials
  string credential_id = 1;
}

// Empty response
message SdkCredentialDeleteResponse {
}

// Defines a request to validate credentials
message SdkCredentialValidateRequest {
  // Id of the credentials
  string credential_id = 1;
}

// Empty response
message SdkCredentialValidateResponse {
}

// Defines a request to mount a volume to the node receiving this request
message SdkVolumeMountRequest {
  // Id of the volume
  string volume_id = 1;
  // Mount path for mounting the volume.
  string mount_path = 2;
}

// Empty response
message SdkVolumeMountResponse {
}

// Defines a request to unmount a volume on the node receiving this request
message SdkVolumeUnmountRequest {
  // Id of volume
  string volume_id = 1;
  // MountPath for device
  string mount_path = 2;
  // Options to unmount device
  message Options {
    // Delete the mount path on the node after unmounting
    bool delete_mount_path = 1;
    // Do not wait for a delay before deleting path.
    // Normally a storage driver may delay before deleting the mount path,
    // which may be necessary to reduce the risk of race conditions. This
    // choice will remove that delay. This value is only usable when
    // `delete_mount_path` is set.
    bool no_delay_before_deleting_mount_path = 2;
  }
  // Options to unmount device
  Options options = 3;
}

// Empty response
message SdkVolumeUnmountResponse {
}

// Defines a request to attach a volume to the node receiving this request
message SdkVolumeAttachRequest {
  // Id of volume
  string volume_id = 1;
  // Options to attach device
  message Options {
    // Indicates the name of the secret stored in a secret store
    // In case of Hashicorp's Vault, it will be the key from the key-value pair stored in its kv backend.
    // In case of Kubernetes secret, it is the name of the secret object itself
    string secret_name = 1;
    // In case of Kubernetes, this will be the key stored in the Kubernetes secret
    string secret_key = 2;
    // It indicates the additional context which could be used to retrieve the secret.
    // In case of Kubernetes, this is the namespace in which the secret is created.
    string secret_context = 3;
  }
  // Options to attach device
  Options options = 2;
}

// Defines a response from the node which received the request to attach
message SdkVolumeAttachResponse {
  // Device path where device is exported
  string device_path = 1;
}

// Defines a request to detach a volume
message SdkVolumeDetachRequest {
  // Id of the volume
  string volume_id = 1;
  // Options to detach device
  message Options {
    // Forcefully detach device from the kernel
    bool force = 1;
    // Unmount the volume before detaching
    bool unmount_before_detach = 2;
  }
  Options options = 2;
}

// Empty response
message SdkVolumeDetachResponse {
}

// Defines a request to create a volume. Use OpenStorageVolume.Update()
// to update any labels on the volume.
message SdkVolumeCreateRequest {
  // Unique name of the volume. This will be used for idempotency.
  string name = 1;
  // Volume specification
  VolumeSpec spec = 2;
}

// Defines a response to the creation of a volume
message SdkVolumeCreateResponse {
  // Id of new volume
  string volume_id = 1;
}

// Defines a request to clone a volume or create a volume from a snapshot
message SdkVolumeCloneRequest {
  // Unique name of the volume. This will be used for idempotency.
  string name = 1;
  // Parent volume id or snapshot id will create a new volume as a clone of the parent.
  string parent_id = 2;
}

// Defines the response when creating a clone from a volume or a snapshot
message SdkVolumeCloneResponse {
  // Id of new volume
  string volume_id = 1;
}

// Defines the request to delete a volume
message SdkVolumeDeleteRequest {
  // Id of volume to delete
  string volume_id = 1;
}

// Empty response
message SdkVolumeDeleteResponse {
}

// Defines the request to inspect a volume
message SdkVolumeInspectRequest {
  // Id of volume to inspect
  string volume_id = 1;
}

// Defines the response when inspecting a volume
message SdkVolumeInspectResponse {
  // Information about the volume
  Volume volume = 1;
}

// This request is used to adjust or set new values in the volume
message SdkVolumeUpdateRequest {
  // Id of the volume to update
  string volume_id = 1;
  // Change locator values. Some of these values may not be able to be changed.
  // New labels will be added to the current volume labels. To delete a label, set the
  // value of the label to an empty string.
  VolumeLocator locator = 2;
  // VolumeSpecUpdate provides a method to request that certain values
  // in the VolumeSpec are changed. This is necessary as a separate variable
  // because values like int and bool in the VolumeSpec cannot be determined
  // if they are being requested to change in gRPC proto3. Some of these
  // values may not be able to be changed.
  // Here are a few examples of actions that can be accomplished using the VolumeSpec.
  // To resize the volume: Set a new value in spec.size.
  // To change number of replicas: Adjust spec.ha_level.
  // To change the I/O Profile: Adjust spec.io_profile.
  VolumeSpecUpdate spec = 4;
}

// Empty response
message SdkVolumeUpdateResponse {
}

// Defines a request to retreive volume statistics
message SdkVolumeStatsRequest {
  // Id of the volume to get statistics
  string volume_id = 1;
  // When set to false the stats are in /proc/diskstats style stats.
  // When set to true the stats are stats for a specific duration.
  bool not_cumulative = 2;
}


// Defines a response containing drive statistics
message SdkVolumeStatsResponse {
  // Statistics for a single volume
  Stats stats = 1;
}

// Defines request to retrieve volume/snapshot capacity usage details
message SdkVolumeCapacityUsageRequest {
  // Id of the snapshot/volume to get capacity usage details
  string volume_id = 1;
}

// Defines response containing volume/snapshot capacity usage details
message SdkVolumeCapacityUsageResponse {
  // CapacityUsage details
  CapacityUsageInfo capacity_usage_info = 1;
}

// Defines a request to list volumes
message SdkVolumeEnumerateRequest {
}

// Defines the response when listing volumes
message SdkVolumeEnumerateResponse {
  // List of volumes matching label
  repeated string volume_ids = 1;
}

// Defines a request to list volumes
message SdkVolumeEnumerateWithFiltersRequest {
  // Volumes to match to this locator.
  // If not provided, all volumes will be returned.
  VolumeLocator locator = 1;
}

// Defines the response when listing volumes
message SdkVolumeEnumerateWithFiltersResponse {
  // List of volumes matching label
  repeated string volume_ids = 1;
}

// Defines the request when creating a snapshot from a volume.
message SdkVolumeSnapshotCreateRequest {
  // Id of volume to take the snapshot from
  string volume_id = 1;
  // Name of the snapshot.
  string name = 2;
  // Labels to apply to snapshot
  map<string, string> labels = 3;
}

// Defines a response after creating a snapshot of a volume
message SdkVolumeSnapshotCreateResponse {
  // Id of immutable snapshot
  string snapshot_id = 1;
}

// Defines a request to restore a volume to a snapshot
message SdkVolumeSnapshotRestoreRequest {
  // Id of volume
  string volume_id = 1;
  // Snapshot id to apply to `volume_id`
  string snapshot_id = 2;
}

// Empty response
message SdkVolumeSnapshotRestoreResponse {
}

// Defines a request to list the snaphots
message SdkVolumeSnapshotEnumerateRequest {
  // Get the snapshots for this volume id
  string volume_id = 1;
}

// Defines a response when listing snapshots
message SdkVolumeSnapshotEnumerateResponse {
  // List of immutable snapshots
  repeated string volume_snapshot_ids = 1;
}

// Defines a request to list the snaphots
message SdkVolumeSnapshotEnumerateWithFiltersRequest {
  // (optional) Get the snapshots for this volume id
  string volume_id = 1;
  // (optional) Get snapshots that match these labels
  map<string, string> labels = 2;
}

// Defines a response when listing snapshots
message SdkVolumeSnapshotEnumerateWithFiltersResponse {
  // List of immutable snapshots
  repeated string volume_snapshot_ids = 1;
}

// Defines a request to update the snapshot schedule of a volume
message SdkVolumeSnapshotScheduleUpdateRequest {
  // Id of volume
  string volume_id = 1;
  // Names of schedule policies
  repeated string snapshot_schedule_names = 2;
}

// Empty response
message SdkVolumeSnapshotScheduleUpdateResponse {
}

// Empty request
message SdkClusterInspectCurrentRequest {
}

// Defines a response when inspecting the current cluster
message SdkClusterInspectCurrentResponse {
  // Cluster information
  StorageCluster cluster = 1;
}

// Defines a request when inspecting a node
message SdkNodeInspectRequest {
  // Id of node to inspect
  string node_id = 1;
}

// Defines a response when inspecting a node
message SdkNodeInspectResponse {
  // Node information
  StorageNode node = 1;
}

// Empty request
message SdkNodeInspectCurrentRequest {
}

// Defines a response when inspecting a node
message SdkNodeInspectCurrentResponse {
  // Node information
  StorageNode node = 1;
}

// Empty request
message SdkNodeEnumerateRequest {
}

// Defines a response with a list of nodes
message SdkNodeEnumerateResponse {
  // List of all the node ids in the cluster
  repeated string node_ids = 1;
}

// Defines a request to get information about an object store endpoint
message SdkObjectstoreInspectRequest {
  // Id of the object store
  string objectstore_id = 1;
}

// Defines a response when inspecting an object store endpoint
message SdkObjectstoreInspectResponse {
  // Contains information about the object store requested
  ObjectstoreInfo objectstore_status = 1;
}

// Defines a request to create an object store
message SdkObjectstoreCreateRequest {
  // Volume on which objectstore will be running
  string volume_id = 1;
}

// Defines a response when an object store has been created for a
// specified volume
message SdkObjectstoreCreateResponse {
  // Created objecstore status
  ObjectstoreInfo objectstore_status = 1;
}

// Defines a request to delete an object store service from a volume
message SdkObjectstoreDeleteRequest {
  // Id of the object store to delete
  string objectstore_id = 1;
}

// Empty response
message SdkObjectstoreDeleteResponse {
}

// Defines a request to update an object store
message SdkObjectstoreUpdateRequest {
  // Objectstore Id to update
  string objectstore_id = 1;
  // enable/disable objectstore
  bool enable = 2;
}

// Empty response
message SdkObjectstoreUpdateResponse {
}

// Defines a request to create a backup of a volume to the cloud
message SdkCloudBackupCreateRequest {
  // VolumeID of the volume for which cloudbackup is requested
  string volume_id = 1;
  // Credential id refers to the cloud credentials needed to backup
  string credential_id = 2;
  // Full indicates if full backup is desired even though incremental is possible
  bool full = 3;
  // TaskId of the task performing this backup. This value can be used for
  // idempotency.
  string task_id = 4;
  // Labels are list of key value pairs to tag the cloud backup. These labels
  // are stored in the metadata associated with the backup.
  map<string, string> labels = 5;
}

// Empty response
message SdkCloudBackupCreateResponse {
  // TaskId of the task performing the backup
  string task_id = 1;
}

// Defines a request to restore a volume from an existing backup stored by
// a cloud provider
message SdkCloudBackupRestoreRequest {
  // Backup ID being restored
  string backup_id = 1;
  // Optional volume Name of the new volume to be created
  // in the cluster for restoring the cloudbackup
  string restore_volume_name = 2;
  // The credential to be used for restore operation
  string credential_id = 3;
  // Optional for provisioning restore
  // volume (ResoreVolumeName should not be specified)
  string node_id = 4;
  // TaskId of the task performing this restore
  string task_id = 5;
}

// Defines a response when restoring a volume from a backup stored by
// a cloud provider
message SdkCloudBackupRestoreResponse {
  // VolumeID to which the backup is being restored
  string restore_volume_id = 1;
  // TaskId of the task performing the restore
  string task_id = 2;
}

// Defines a request to delete a single backup stored by a cloud provider
message SdkCloudBackupDeleteRequest {
  // ID is the ID of the cloud backup
  string backup_id = 1;
  // Credential id is the credential for cloud to be used for the request
  string credential_id = 2;
  // Force Delete cloudbackup even if there are dependencies. This may be
  // needed if the backup is an incremental backup and subsequent backups
  // depend on this backup specified by `backup_id`.
  bool force = 3;
}

// Empty response
message SdkCloudBackupDeleteResponse {
}

// Defines a request to delete all the backups stored by a cloud provider
// for a specified volume
message SdkCloudBackupDeleteAllRequest {
  // id of the volume for the request
  string src_volume_id = 1;
  // Credential id is the credential for cloud to be used for the request
  string credential_id = 2;
}

// Empty response
message SdkCloudBackupDeleteAllResponse {
}

// Defines a request to list the backups stored by a cloud provider.
// The following combinations can be used to get cloud backup information:
//
// * For a specific volume in current cluster: Set `src_volume_id` to your desired volume id
// and do not provide `cluster_id` and `all`.
// * For a specific volume in a specific cluster: Set `src_volume_id` to your desired volume id
// and specify `cluster_id`.
// * For a specific volume in all clusters: Set `src_volume_id` to your desired volume id
// and set `all` to true, do not provide `cluster_id`.
// * For all volumes in current cluster: do not provide `cluster_id`, `volume_id` and `all`.
// * For all volumes in a specific cluster: Set `cluster_id` to your desired cluster id
// and do not provide `volume_id` and `all`.
// * For all volumes in all clusters: Set `all` to true do not provide `volume_id` and `cluster_id`.
message SdkCloudBackupEnumerateWithFiltersRequest {
  // (optional) Source id of the volume for the request.
  string src_volume_id = 1;
  // (optional) Cluster id specifies the cluster for the request
  string cluster_id = 2;
  // Credential id is the credential for cloud to be used for the request
  string credential_id = 3;
  // (optional) All indicates if the request should show cloud backups for all clusters or the current cluster.
  bool all = 4;
}

// SdkCloudBackupInfo has information about a backup stored by a cloud provider
message SdkCloudBackupInfo {
  // This is the id as represented by the cloud provider
  string id = 1;
  // Source volumeID of the backup
  string src_volume_id = 2;
  // Name of the sourceVolume of the backup
  string src_volume_name = 3;
  // Timestamp is the timestamp at which the source volume
  // was backed up to cloud
  google.protobuf.Timestamp timestamp = 4;
  // Metadata associated with the backup
  map<string, string> metadata = 5;
  // Status indicates the status of the backup
  SdkCloudBackupStatusType status = 6;
}

// Defines a response which lists all the backups stored by a cloud provider
message SdkCloudBackupEnumerateWithFiltersResponse {
  repeated SdkCloudBackupInfo backups = 1;
}

// CloudBackup operations types
enum SdkCloudBackupOpType {
  // Unknown
  SdkCloudBackupOpTypeUnknown = 0;
  // Backup
  SdkCloudBackupOpTypeBackupOp = 1;
  // Restore
  SdkCloudBackupOpTypeRestoreOp = 2;
}

// CloudBackup status types
enum SdkCloudBackupStatusType {
  // Unkonwn
  SdkCloudBackupStatusTypeUnknown = 0;
  // Not started
  SdkCloudBackupStatusTypeNotStarted = 1;
  // Done
  SdkCloudBackupStatusTypeDone = 2;
  // Aborted
  SdkCloudBackupStatusTypeAborted = 3;
  // Paused
  SdkCloudBackupStatusTypePaused = 4;
  // Stopped
  SdkCloudBackupStatusTypeStopped = 5;
  // Active
  SdkCloudBackupStatusTypeActive = 6;
  // Failed
  SdkCloudBackupStatusTypeFailed = 7;
}

// SdkCloudBackupStatus defines the status of a backup stored by a cloud provider
message SdkCloudBackupStatus {
  // This is the id as represented by the cloud provider
  string backup_id = 1;
  // OpType indicates if this is a backup or restore
  SdkCloudBackupOpType optype = 2;
  // State indicates if the op is currently active/done/failed
  SdkCloudBackupStatusType status = 3;
  // BytesDone indicates total Bytes uploaded/downloaded
  uint64 bytes_done = 4;
  // StartTime indicates Op's start time
  google.protobuf.Timestamp start_time = 5;
  // CompletedTime indicates Op's completed time
  google.protobuf.Timestamp completed_time = 6;
  // NodeID is the ID of the node where this Op is active
  string node_id = 7;
  // SourceVolumeID is the the volume that is either being backed up to cloud
  // or target volume to which a backup is being restored
  string src_volume_id = 8;
  // Info currently indicates the failure cause for failed backup/restore
  repeated string info = 9;
  // CredentialId is the credential used for cloud with this backup/restore op
  string credential_id  = 10;
  // BytesTotal is the total number of bytes being transferred
  uint64 bytes_total = 11;
  // ETASeconds is the number of seconds for cloud backup completion
  int64 eta_seconds = 12;
}

// Defines a request to retreive the status of a backup or restore for a
// specified volume
message SdkCloudBackupStatusRequest {
  // (optional) VolumeId is a value which is used to get information on the
  // status of a backup for the specified volume. If no volume id and task_id
  // is provided, then status for all volumes is returned.
  string volume_id = 1;
  // Local indicates if only those backups/restores that are
  // active on current node must be returned
  bool local = 2;
  // TaskId of the backup/restore task, if this is specified,
  // volume_id is ignored.
  string task_id = 3;
}

// Defines a response containing the status of the backups for a specified volume
message SdkCloudBackupStatusResponse {
  // Statuses is list of currently active/failed/done backup/restores where
  // the key is the id of the task performing backup/restore.
  map<string, SdkCloudBackupStatus> statuses = 1;
}

// Defines a request to get catalog of a backup stored by a cloud provider
message SdkCloudBackupCatalogRequest {
  // Id of the backup
  string backup_id = 1;
  // Credential id describe the credentials for the cloud
  string credential_id = 2;
}

// Defines a response containing the contents of a backup stored by a cloud provider
message SdkCloudBackupCatalogResponse {
  // Contents is listing of backup contents
  repeated string contents = 1;
}

// SdkCloudBackupHistoryItem contains information about a backup for a
// specific volume
message SdkCloudBackupHistoryItem {
  // SrcVolumeID is volume ID which was backedup
  string src_volume_id = 1;
  // TimeStamp is the time at which either backup completed/failed
  google.protobuf.Timestamp timestamp = 2;
  // Status indicates whether backup was completed/failed
  SdkCloudBackupStatusType status = 3;
}

// Defines a request to retreive the history of the backups for
// a specific volume to a cloud provider
message SdkCloudBackupHistoryRequest {
  // This optional value defines which history of backups is being
  // requested. If not provided, it will return the history for all volumes.
  string src_volume_id = 1;
}

// Defines a response containing a list of history of backups to a cloud provider
message SdkCloudBackupHistoryResponse {
  // HistoryList is list of past backups on this volume
  repeated SdkCloudBackupHistoryItem history_list = 1;
}

// SdkCloudBackupRequestedState defines states to set a specified backup or restore
// to or from a cloud provider
enum SdkCloudBackupRequestedState {
  // Unknown state
  SdkCloudBackupRequestedStateUnknown = 0;
  // Pause the backup or restore
  SdkCloudBackupRequestedStatePause = 1;
  // Resume the backup or restore
  SdkCloudBackupRequestedStateResume = 2;
  // Stop a backup or restore
  SdkCloudBackupRequestedStateStop = 3;
}

// Defines a request to change the state of a backup or restore to or
// from a cloud provider
message SdkCloudBackupStateChangeRequest {
  // Describes the backup/restore task
  // state change is being requested
  string task_id = 1;
  // The desired state of the operation
  SdkCloudBackupRequestedState requested_state = 2;
}

// Empty response
message SdkCloudBackupStateChangeResponse {
}

// SdkCloudBackupScheduleInfo describes a schedule for volume backups to
// a cloud provider
message SdkCloudBackupScheduleInfo{
  // The schedule's source volume
  string src_volume_id = 1;
  // The cloud credential used with this schedule
  string credential_id = 2;
  // Schedules are the frequencies of the backup
  repeated SdkSchedulePolicyInterval schedules = 3;
  // MaxBackups are the maximum number of backups retained
  // in cloud.Older backups are deleted
  uint64 max_backups = 4;
  // Full indicates if scheduled backups should always be full and never incremental.
  bool full = 5;
}

// Defines a request to create a schedule for volume backups to a
// cloud provider
message SdkCloudBackupSchedCreateRequest{
  // Cloud Backup Schedule info
  SdkCloudBackupScheduleInfo cloud_sched_info = 1;
}

// Defines a response containing the id of a schedule for a volume backup
// to a cloud provider
message SdkCloudBackupSchedCreateResponse{
   // Id of newly created backup schedule
   string backup_schedule_id = 1;
}

// Defines a request to delete a backup schedule
message SdkCloudBackupSchedDeleteRequest{
  // Id of cloud backup to delete
  string backup_schedule_id = 1;
}

// Empty response
message SdkCloudBackupSchedDeleteResponse{
}

// Empty request
message SdkCloudBackupSchedEnumerateRequest{
}

// Defines a response containing a map listing the schedules for volume
// backups to a cloud provider
message SdkCloudBackupSchedEnumerateResponse{
  // Returns list of backup schedules
  map<string, SdkCloudBackupScheduleInfo> cloud_sched_list = 1;
}

// Empty request
message SdkIdentityCapabilitiesRequest {
}

// Defines a response containing the capabilites of the cluster
message SdkIdentityCapabilitiesResponse {
  // Provides all the capabilites supported by the cluster
  repeated SdkServiceCapability capabilities = 1;
}

// Empty request
message SdkIdentityVersionRequest {
}

// Defines a response containing version information
message SdkIdentityVersionResponse {
  // OpenStorage SDK version used by the server
  SdkVersion sdk_version = 1;
  // Version information about the storage system
  StorageVersion version = 2;
}

// Defines a capability of he cluster
message SdkServiceCapability {
  message OpenStorageService {
    enum Type {
      // Unknown service
      UNKNOWN = 0;
      // Cluster management
      CLUSTER = 1;
      // Cloud backup of volumes management
      CLOUD_BACKUP = 2;
      // Credentials management
      CREDENTIALS = 3;
      // Node management
      NODE = 4;
      // Object Storage management
      OBJECT_STORAGE = 5;
      // Schedule policy management
      SCHEDULE_POLICY = 6;
      // Volume management
      VOLUME = 7;
      // Alert enumeration
      ALERTS = 8;
      // Mount/Attach Support
      MOUNT_ATTACH = 9;
    }

    // Type of service supported
    Type type = 1;
  }

  // Use oneof to have only one type of service defined making it
  // future proof to add other types.
  oneof type {
    // service type supported by this cluster
    OpenStorageService service = 1;
  }
}

// SDK version in Major.Minor.Patch format. The goal of this
// message is to provide clients a method to determine the SDK
// version run by an SDK server.
message SdkVersion {

  // These values are constants that can be used by the
  // client and server applications
  enum Version {
    // Allows multiple values to be set to the same integer
    // Set when needed
    option allow_alias = true;

    // Must be set in the proto file; ignore.
    MUST_HAVE_ZERO_VALUE = 0;

    // SDK version major value of this specification
    Major = 0;
    // SDK version minor value of this specification
    Minor = 22;
    // SDK version patch value of this specification
    Patch = 9;
  }

  // The following cannot be set to use the enum Version because the REST
  // Gateway would then return the string value of the enum.

  // SDK version major number
  int32 major = 1;
  // SDK version minor number
  int32 minor = 2;
  // SDK version patch number
  int32 patch = 3;
  // String representation of the SDK version. Must be
  // in `major.minor.patch` format.
  string version = 4;
}

// Version information about the storage system
message StorageVersion {
   // OpenStorage driver name
   string driver = 1;
   // Version of the server
   string version = 2;
   // Extra information provided by the storage system
   map<string, string> details = 3;
}

message CloudMigrate {
    enum OperationType {
        InvalidType = 0;
        // Migrate all volumes in the cluster
        MigrateCluster = 1;
        // Migrate a single volume
        MigrateVolume = 2;
        // Migrate a group of volumes
        MigrateVolumeGroup = 3;
    }

    enum Stage {
        InvalidStage = 0;
        Backup = 1;
        Restore = 2;
        VolumeUpdate = 3;
        Done = 4;
    }

    enum Status {
        InvalidStatus = 0;
        Queued = 1;
        Initialized = 2;
        InProgress = 3;
        Failed = 4;
        Complete = 5;
        Canceled = 6;
    }
}

// Request to start a cloud migration
message CloudMigrateStartRequest {
    // The type of operation to start
    CloudMigrate.OperationType operation = 1;
    // ID of the cluster to which volumes are to be migrated
    string cluster_id = 2;
    // Depending on the operation type this can be a VolumeID or VolumeGroupID
    string target_id = 3;
    // (Optional) Unique TaskId assocaiated with this migration. If not provided one will
    // be generated and returned in the response
    string task_id = 4;
}

// Defines a migration request
message SdkCloudMigrateStartRequest {
  // Defines a migration request for a volume
  message MigrateVolume {
    string volume_id = 1;
  }

  // Defines a migration request for a volume group
  message MigrateVolumeGroup {
    string group_id = 1;
  }

  // Defines a migration request for all volumes in a cluster
  message MigrateAllVolumes {
  }

  // ID of the cluster to which volumes are to be migrated
  string cluster_id = 1;

  // Unique name assocaiated with this migration.
  // This is a Optional field for idempotency
  string task_id = 2;

  oneof opt {
    // Request to migrate a volume
    MigrateVolume volume = 200;

    // Request to migrate a volume group
    MigrateVolumeGroup volume_group = 201;

    // Request to migrate all volumes
    MigrateAllVolumes all_volumes = 202;
  }
}

// Response to start a cloud migration
message CloudMigrateStartResponse {
    // TaskId assocaiated with the migration that was started
    string task_id = 1;
}

// Defines a response for the migration that was started
message SdkCloudMigrateStartResponse {
    // Result assocaiated with the migration that was started
    CloudMigrateStartResponse result = 1;
}

// Request to stop a cloud migration
message CloudMigrateCancelRequest {
    // The id of the task to cancel
    string task_id = 1;
}

// Defines a request to stop a cloud migration
message SdkCloudMigrateCancelRequest {
    // Request containing the task id to be cancelled
    CloudMigrateCancelRequest request = 1;
}

// Empty Response
message SdkCloudMigrateCancelResponse {
}

message CloudMigrateInfo {
    // Task id associated with this migration
    string task_id = 1;
    // ID of the cluster where the volume is being migrated
    string cluster_id = 2;
    // ID of the volume on the local cluster
    string local_volume_id = 3;
    // Name of the volume on the local cluster
    string local_volume_name = 4;
    // ID of the volume on the remote cluster
    string remote_volume_id = 5;
    // ID of the cloudbackup used for the migration
    string cloudbackup_id = 6;
    // Current stage of the volume migration
    CloudMigrate.Stage current_stage = 7;
    // Status of the current stage
    CloudMigrate.Status status = 8;
    // Last time the status was updated
    google.protobuf.Timestamp last_update = 9;
    // Contains the reason for the migration error
    string error_reason = 10;
    // StartTime indicates Op's start time
    google.protobuf.Timestamp start_time = 11;
    // CompletedTime indicates Op's completed time
    google.protobuf.Timestamp completed_time = 12;
    // BytesTotal is the number of bytes being transferred
    uint64 bytes_total = 13;
    // BytesDone is the number of bytes already transferred
    uint64 bytes_done = 14;
    // ETASeconds the time duration in seconds for cloud migration completion
    int64 eta_seconds = 15;
}

message CloudMigrateInfoList {
    repeated CloudMigrateInfo list = 1;
}

// Request for cloud migration operation status
message SdkCloudMigrateStatusRequest {
    // Request contains the task id and cluster id for which status should be
    // returned
    CloudMigrateStatusRequest request = 1;
}

// Request for cloud migration operation status
message CloudMigrateStatusRequest {
    // Task id for which to return status
    string task_id = 1;
    // ID of the cluster for which to return migration statuses
    string cluster_id = 2;
}

// Response with a status of the cloud migration operations
message CloudMigrateStatusResponse {
    // Map of cluster id to the status of volumes being migrated
    map<string, CloudMigrateInfoList> info = 1;
}

// Defines a response for the status request
message SdkCloudMigrateStatusResponse {
  // Status of all migration requests
  CloudMigrateStatusResponse result = 1;
}

// Used to send a request to create a cluster pair
message ClusterPairCreateRequest {
  // IP of the remote cluster
  string remote_cluster_ip = 1;
  // Port for the remote cluster
  uint32 remote_cluster_port = 2;
  // Token used to authenticate with the remote cluster
  string remote_cluster_token = 3;
  // Set the new pair as the default
  bool set_default = 4;
}

// Response for a pair request
message ClusterPairCreateResponse {
  // ID of the remote cluster
  string remote_cluster_id = 1;
  // Name of the remote cluster
  string remote_cluster_name = 2;
}

// Defines a request for creating a cluster pair
message SdkClusterPairCreateRequest {
  ClusterPairCreateRequest request = 1;
}

// Defines a result of the cluster pair
message SdkClusterPairCreateResponse {
  // Contains the information about cluster pair
  ClusterPairCreateResponse result = 1;
}

// Used to process a pair request from a remote cluster
message ClusterPairProcessRequest {
    // ID of the cluster requesting the pairing
    string source_cluster_id = 1;
    // Token used to authenticate with the remote cluster
    string remote_cluster_token = 2;
}

// Response after a pairing has been processed
message ClusterPairProcessResponse {
    // ID of the cluster which processed the pair request
    string remote_cluster_id = 1;

    // Name of the cluster which processed the pair request
    string remote_cluster_name = 2;

    // List of endpoints that can be used to communicate with the cluster
    repeated string remote_cluster_endpoints = 3;

    // Key/value pair of options returned on successful pairing.
    // Opaque to openstorage and interpreted by the drivers
    map<string, string> options = 4;
}

// Defines a delete request for a cluster pair
message SdkClusterPairDeleteRequest {
  // ID of the cluster pair to be deleted
  string cluster_id = 1;
}

// Empty response
message SdkClusterPairDeleteResponse{
}

// Response to get the cluster token
message ClusterPairTokenGetResponse {
    // Token used to authenticate clusters
    string token = 1;
}

// Empty request
message SdkClusterPairGetTokenRequest {
}

// Defines a response for the token request
message SdkClusterPairGetTokenResponse {
  // Contains authentication token for the cluster
  ClusterPairTokenGetResponse result = 1;
}

// Empty request
message SdkClusterPairResetTokenRequest {
}

// Defines a response for the token request
message SdkClusterPairResetTokenResponse {
  // Contains authentication token for the cluster
  ClusterPairTokenGetResponse result = 1;
}

// Information about a cluster pair
message ClusterPairInfo {
    // ID of the cluster
    string id = 1;
    // Name of the cluster
    string name = 2;
    // The endpoint used for creating the pair
    string endpoint = 3;
    // Current endpoints of the cluster
    repeated string current_endpoints = 4;
    // Flag used to determine if communication is over a secure channel
    bool secure = 5;
    // Token associated with cluster
    string token = 6;
    // Key/value pair of options associated with the cluster
    // Opaque to openstorage and interpreted by the drivers
    map<string, string> options = 7;
}

// Defines a cluster pair inspect request
message SdkClusterPairInspectRequest{
    // ID of the cluster, if empty gets the default pair
    string id = 1;
}

// Reponse to get a cluster pair
message ClusterPairGetResponse {
    // Info about the cluster pair
    ClusterPairInfo pair_info = 1;
}

// Defines a cluster pair inspect response
message SdkClusterPairInspectResponse {
  // Information about cluster pair
  ClusterPairGetResponse result = 1;
}

// Empty Request
message SdkClusterPairEnumerateRequest{
}

// Response to enumerate all the cluster pairs
message ClusterPairsEnumerateResponse {
    // ID of the default cluster pair
    string default_id = 1;

    // Pairs Info about the cluster pairs
    map<string, ClusterPairInfo> pairs = 2;
}

// Defines a list of cluster pair
message SdkClusterPairEnumerateResponse {
  // List of all the cluster pairs
  ClusterPairsEnumerateResponse result = 1;
}

message Catalog {
    // Name of the Directory/File
    string name = 1;
    // Full Path of the Directory/File
    string path = 2;
    // Type Directory or File
    string type = 3;
    // File or Directory Size
    uint64 size = 4;
    // Last Modified
    google.protobuf.Timestamp LastModified = 5;
    // Children
    repeated Catalog children = 6;
}

message Report {
    // Directory count
    int64 directories = 2;
    // File count
    int64 files = 3;
}

message CatalogResponse {
    // Root Catalog
    Catalog root = 1;
    // Report of total directories and files count
    Report report = 2;
}


// Locate response would be used to return a set of mounts
// and/or Container IDs and their mount paths
message LocateResponse {
    // Map of mounts
    // <host>: /var/lib/osd/<volumemount>
    map<string, string> mounts = 1;
    // Map of docker id's and their mounts
    // <containerid>: /var/www
    map<string, string> dockerids = 2;
}

// VolumePlacementStrategy defines a strategy for placing volumes in the cluster which will be a series of rules
message VolumePlacementStrategy {
  // Rules defines a list of rules as part of the placement spec. All the rules specified will
  // be applied for volume placement.
  // Rules that have enforcement as "required" are strictly enforced while "preferred" are best effort.
  // In situations, where 2 or more rules conflict, the weight of the rules will dictate which wins.
  repeated VolumePlacementRule rules = 1;
}

// VolumePlacementRule defines a single placement rule
message VolumePlacementRule {
  // AffectedReplicas defines the number of volume replicas affected by this rule. If not provided,
  // rule would affect all replicas
  // (optional)
  int32 affected_replicas = 1;
  // Weight defines the weight of the rule which allows to break the tie with other matching rules. A rule with
  // higher weight wins over a rule with lower weight.
  // (optional)
  int64 weight = 2;

  // Defines the types of enforcement on the given rules
  enum EnforcementType {
    // This specifies that the rule is required and must be strictly enforced
    Required = 0;
    // This specifies that the rule is preferred and can be best effort
    Preferred = 1;
  }

  // Enforcement specifies the rule enforcement policy. Can take values: required or preferred.
  // (optional)
  EnforcementType enforcement = 3;

  // This specifies the type an affinity rule can take
  enum AffinityRuleType {
    // Affinity means the rule specifies an affinity to objects that match the below label selector requirements
    Affinity = 0;
    // AntiAffinity means the rule specifies an anti-affinity to objects that match the below label selector requirements
    AntiAffinity = 1;
  }

  // Type is the type of the affinity rule
  AffinityRuleType type = 4;

  // MatchExpressions is a list of label selector requirements. The requirements are ANDed.
  repeated LabelSelectorRequirement match_expressions = 5;
}


// LabelSelectorRequirement is a selector that contains values, a key, and an operator that
// relates the key and values.
message LabelSelectorRequirement {
  // Key is the label key that the selector applies to.
  string key = 1;

  // This defines operator types used in a label matching rule
  enum Operator {
    // In means the value for 'key' should be in one of the given value(s)
    In = 0;
    // NotIn means the value for 'key' should NOT be in one of the given value(s)
    NotIn = 1;
    // Exists means the 'key' should just exist regardless of the value
    Exists = 2;
    // DoesNotExist means the 'key' should NOT exist
    DoesNotExist = 3;
    // Gt means the 'key' should be greater than the value(s)
    Gt = 4;
    // Lt means the 'key' should be less than the value(s)
    Lt = 5;
  }

  // Operator represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists and DoesNotExist.
  Operator operator = 2;

  // Values is an array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. This array is replaced during a strategic
  // merge patch.
  repeated string values = 3;
}

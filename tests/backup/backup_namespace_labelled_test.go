package tests

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/sched-ops/k8s/core"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// NamespaceLabelledBackupSharedWithDifferentAccessMode takes namespace labelled backup and share with users having different access mode
var _ = Describe("{NamespaceLabelledBackupSharedWithDifferentAccessMode}", func() {
	var (
		srcClusterUid            string
		backupLocationUID        string
		cloudCredName            string
		cloudCredUID             string
		bkpLocationName          string
		backupNames              []string
		listOfLabelledNamespaces []string
		scheduledAppContexts     []*scheduler.Context
		srcClusterStatus         api.ClusterInfo_StatusInfo_Status
		destClusterStatus        api.ClusterInfo_StatusInfo_Status
	)
	numberOfUsers := 3
	bkpNamespaces := make([]string, 0)
	users := make([]string, 0)
	backupLocationMap := make(map[string]string)
	labels := make(map[string]string)
	userContextsList := make([]context.Context, 0)
	userRestoreContext := make(map[context.Context]string)
	accessUserBackupContext := make(map[userAccessContext]string)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("NamespaceLabelledBackupSharedWithDifferentAccessMode",
			"Take namespace labelled backup and share with users having different access mode", nil, 85040, Sagrawal, Q3FY24)
		log.Infof("Deploy applications needed for backup")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		// Here we have deployed 2*numberOfUsers namespaces/application
		for i := 0; i < 2*numberOfUsers; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("List of all namespaces deployed are %v", bkpNamespaces)
	})
	It("Take namespace labelled backup and share with users having different access mode", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.Infof("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Generating multiple labels", func() {
			log.InfoD("Generating multiple labels")
			labels = GenerateRandomLabels(numberOfUsers)
			log.InfoD("Generated labels are %v", labels)
		})
		// Labelled only half of the namespaces
		Step("Adding labels to only few namespaces", func() {
			log.InfoD("Adding labels to only few namespaces")
			for i := 0; i < numberOfUsers; i++ {
				err := Inst().S.AddNamespaceLabel(bkpNamespaces[i], labels)
				log.FailOnError(err, "Failed to add labels %v to namespace %s", labels, bkpNamespaces[i])
				listOfLabelledNamespaces = append(listOfLabelledNamespaces, bkpNamespaces[i])
			}
			log.InfoD("List of labels applied namespaces are %v", listOfLabelledNamespaces)
		})
		Step("Create multiple users", func() {
			log.InfoD("Creating %d users", numberOfUsers)
			users = createUsers(numberOfUsers)
			log.Infof("Created %v users and users list is %v", numberOfUsers, users)
		})
		Step("Creating backup location and cloud setting", func() {
			log.InfoD("Creating backup location and cloud setting")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, provider := range providers {
				cloudCredName = fmt.Sprintf("%s-%s-%v", "cred", provider, time.Now().Unix())
				bkpLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				backupLocationMap[backupLocationUID] = bkpLocationName
				err := CreateCloudCredential(provider, cloudCredName, cloudCredUID, orgID, ctx)
				log.FailOnError(err, fmt.Sprintf("Verifying creation of cloud credential named [%s] for org [%s] with [%s] as provider", cloudCredName, orgID, provider))
				err = CreateBackupLocation(provider, bkpLocationName, backupLocationUID, cloudCredName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				log.FailOnError(err, fmt.Sprintf("Creating backup location %s", bkpLocationName))
			}
		})
		Step("Register source and destination cluster for backup", func() {
			log.InfoD("Register source and destination cluster for backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			log.FailOnError(err, "Creating source and destination cluster")
			srcClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			destClusterStatus, err = Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		// While taking namespace labelled backup, we are expecting that backup will be taken of only labelled namespaces, not all
		Step("Taking namespace labelled backup for each user", func() {
			log.InfoD("Taking namespace labelled backup for each user")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			var wg sync.WaitGroup
			for i := 0; i < numberOfUsers; i++ {
				backupName := fmt.Sprintf("%s-%v", BackupNamePrefix, users[i])
				backupNames = append(backupNames, backupName)
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, listOfLabelledNamespaces)
					err := CreateBackupWithNamespaceLabelWithValidation(ctx, backupName, SourceClusterName, bkpLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, srcClusterUid, "", "", "", "", MapToKeyValueString(labels))
					dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled backup [%s] of namespaces (scheduled contexts) [%v]", backupName, listOfLabelledNamespaces))
				}(backupName)
			}
			wg.Wait()
			log.InfoD("List of namespace labelled backups- %v", backupNames)
		})
		Step("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup", func() {
			log.InfoD("Verifying that correct namespaces are backed up for the namespace labelled backup taken and correct labels are applied to the backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range backupNames {
				err = NamespaceLabelBackupSuccessCheck(backupName, ctx, listOfLabelledNamespaces, MapToKeyValueString(labels))
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if only the labeled namespaces: [%v] are backed up and correct  labels [%s] are applied to backup [%s]", listOfLabelledNamespaces, MapToKeyValueString(labels), backupName))
			}
		})
		Step("Share backup with users with different access level", func() {
			log.InfoD("Share backup with users with different access level")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			accessUserBackupContext, err = ShareBackupWithUsersAndAccessAssignment(backupNames, users, ctx)
			log.FailOnError(err, fmt.Sprintf("Sharing backup %s with users %v", backupNames, users))
		})
		Step("Validate if the users with different access level can restore/delete backup as per their access mode", func() {
			log.InfoD("Validate if the users with different access level can restore/delete backup as per their access mode")
			for key, val := range accessUserBackupContext {
				restoreName := fmt.Sprintf("%s-%s-%v", key.user, RestoreNamePrefix, time.Now().Unix())
				access := key.accesses
				if access != ViewOnlyAccess {
					log.Infof("Adding the restores %v which will be created while validating %v access", restoreName, backupAccessKeyValue[access])
					userRestoreContext[key.context] = restoreName
				}
				ValidateSharedBackupWithUsers(key.user, key.accesses, val, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		var wg sync.WaitGroup
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting labels from namespaces - %v", listOfLabelledNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(labels, listOfLabelledNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] to namespaces [%v]", labels, listOfLabelledNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.Infof("Generating user context")
		for _, userName := range users {
			ctxNonAdmin, err := backup.GetNonAdminCtx(userName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			userContextsList = append(userContextsList, ctxNonAdmin)
		}
		log.Infof("Deleting restore created by users")
		for userContext, restoreName := range userRestoreContext {
			err = DeleteRestore(restoreName, orgID, userContext)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting Restore %s", restoreName))
		}
		log.Infof("Deleting registered clusters for non-admin context")
		for _, ctxNonAdmin := range userContextsList {
			CleanupCloudSettingsAndClusters(make(map[string]string), "", "", ctxNonAdmin)
		}
		log.Infof("Cleaning up users")
		for _, userName := range users {
			wg.Add(1)
			go func(userName string) {
				defer wg.Done()
				err := backup.DeleteUser(userName)
				dash.VerifySafely(err, nil, fmt.Sprintf("Deleting user %v", userName))
			}(userName)
		}
		wg.Wait()
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredName, cloudCredUID, ctx)
	})
})

// BackupScheduleForOldAndNewNS Schedule backup using namespace label for old namespace and new namespace
var _ = Describe("{BackupScheduleForOldAndNewNS}", func() {
	var (
		initialNSCount         int
		newNSCount             int
		scheduleInterval       int64
		err                    error
		backupLocationUID      string
		cloudCredUID           string
		clusterUid             string
		credName               string
		backupLocationName     string
		restoreName            string
		periodicSchPolicyName  string
		periodicSchPolicyUid   string
		scheduleName           string
		nsLabelString          string
		schBackupAfterAddingNS string
		bkpNamespaces          []string
		newNamespaces          []string
		cloudCredUidList       []string
		allScheduleBackupNames []string
		restoreNames           []string
		nsLabelsMap            map[string]string
		contexts               []*scheduler.Context
		appContexts            []*scheduler.Context
	)
	labelSelectors := make(map[string]string)
	backupLocationMap := make(map[string]string)
	namespaceMapping := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	initialNSCount = 3
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("BackupScheduleForOldAndNewNS", "Schedule backup with old and new namespace using namespace label", nil, 84852, Vpinisetti, Q2FY24)
		log.InfoD("Deploy applications")
		contexts = make([]*scheduler.Context, 0)
		for i := 0; i < initialNSCount; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts = ScheduleApplications(taskName)
			contexts = append(contexts, appContexts...)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Schedule backup using namespace label for old and new namespaces", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(contexts)
		})
		Step("Adding labels to namespaces", func() {
			log.InfoD("Adding labels to namespaces")
			nsLabelsMap = GenerateRandomLabels(20)
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%v]", nsLabelsMap, bkpNamespaces))
		})
		Step("Generating namespace label string from label map for namespaces", func() {
			log.InfoD("Generating namespace label string from label map for namespaces")
			nsLabelString = MapToKeyValueString(nsLabelsMap)
			log.Infof("label string for namespaces %s", nsLabelString)
		})
		Step("Adding labels to resources", func() {
			log.InfoD("Adding labels to resources")
			labelKey := uuid.New()
			labelValue := uuid.New()
			labelSelectors[labelKey] = labelValue
			for _, namespace := range bkpNamespaces {
				pvcList, err := core.Instance().GetPersistentVolumeClaims(namespace, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc list [%v] from namespace [%s]", pvcList, namespace))
				for _, pvc := range pvcList.Items {
					pvcItem, err := core.Instance().GetPersistentVolumeClaim(pvc.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc pointer %v for pvc %v", pvcItem, pvc))
					err = AddLabelToResource(pvcItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, pvcItem))
				}
				cmList, err := core.Instance().ListConfigMap(namespace, metav1.ListOptions{})
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap list [%v] from namespace [%s]", cmList, namespace))
				for _, cm := range cmList.Items {
					cmItem, err := core.Instance().GetConfigMap(cm.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap pointer %v from namespace %s", cmItem, namespace))
					err = AddLabelToResource(cmItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, cmItem))
				}
			}
		})
		Step("Creating cloud credentials and backup location", func() {
			log.InfoD("Creating cloud credentials and registering backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err := CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credentials %s with provider %s", credName, provider))
				log.InfoD("Created cloud credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err = CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Add source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Adding source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of source [%s] and destination [%s] clusters", SourceClusterName, destinationClusterName))
			appClusterName := destinationClusterName
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, appClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", appClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", appClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, appClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", appClusterName))
			log.InfoD("Uid of [%s] cluster is %s", appClusterName, clusterUid)
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			scheduleInterval = 15
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			periodicSchPolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchPolicyUid = uuid.New()
			periodicSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, scheduleInterval, 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchPolicyName, periodicSchPolicyUid, orgID, periodicSchedulePolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval 15 minutes named [%s]", periodicSchPolicyName))
			periodicSchPolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchPolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchPolicyName))
		})
		Step("Creating a schedule backup using namespace label and resource label", func() {
			log.InfoD("Creating a schedule backup using namespace label and resource label")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			scheduleName = fmt.Sprintf("%s-schedule-%v", BackupNamePrefix, time.Now().Unix())
			err = CreateScheduleBackupWithNamespaceLabel(scheduleName, SourceClusterName, backupLocationName, backupLocationUID,
				labelSelectors, orgID, "", "", "", "", nsLabelString, periodicSchPolicyName, periodicSchPolicyUid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of schedule backup with schedule name [%s]", scheduleName))
			firstSchBackupName, err := GetFirstScheduleBackupName(ctx, scheduleName, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the first schedule backup [%s]", firstSchBackupName))
			err = NamespaceLabelBackupSuccessCheck(firstSchBackupName, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespaces [%v] are backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, firstSchBackupName))
			log.InfoD("Waiting for %v minutes for the next schedule backup to be triggered", scheduleInterval)
			time.Sleep(time.Duration(scheduleInterval) * time.Minute)
			secondSchBackupName, err := GetOrdinalScheduleBackupName(ctx, scheduleName, 2, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", secondSchBackupName))
			err = NamespaceLabelBackupSuccessCheck(secondSchBackupName, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespace [%v] is backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, secondSchBackupName))
		})
		Step("Schedule applications to create new namespaces", func() {
			log.InfoD("Scheduling applications to create new namespaces")
			contexts = make([]*scheduler.Context, 0)
			newNSCount = 2
			for i := 0; i < newNSCount; i++ {
				taskName := fmt.Sprintf("%s-%d", "new-namespace", i)
				appContexts := ScheduleApplications(taskName)
				contexts = append(contexts, appContexts...)
				for _, ctx := range appContexts {
					ctx.ReadinessTimeout = appReadinessTimeout
					namespace := GetAppNamespace(ctx, taskName)
					log.InfoD("Scheduled application with namespace [%s]", namespace)
					newNamespaces = append(newNamespaces, namespace)
				}
			}
		})
		Step("Validate new namespaces", func() {
			log.InfoD("Validating new namespaces")
			ValidateApplications(contexts)
		})
		Step("Apply same namespace labels to new namespaces", func() {
			log.InfoD("Apply same namespace labels to new namespaces")
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, newNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Applying same namespace labels %v to new namespace %v", nsLabelsMap, newNamespaces))
		})
		Step("Verify new application namespaces with same namespace label are included in next schedule backup", func() {
			log.InfoD("Verifying new applications namespace new application namespaces with same namespace label are included in next schedule backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			schBackupAfterAddingNS, err = GetNextPeriodicScheduleBackupName(scheduleName, time.Duration(scheduleInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup success for %s schedule backup", schBackupAfterAddingNS))
			bkpNamespaces = append(bkpNamespaces, newNamespaces...)
			log.InfoD("Total namespaces are [%v]", bkpNamespaces)
			err = NamespaceLabelBackupSuccessCheck(schBackupAfterAddingNS, ctx, bkpNamespaces, nsLabelString)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the labeled namespace [%v] is backed up and checks for labels [%s] applied to the backup [%s]", bkpNamespaces, nsLabelString, schBackupAfterAddingNS))
		})
		Step("Restoring scheduled backups", func() {
			log.InfoD("Restoring scheduled backups")
			ctx, err := backup.GetAdminCtxFromSecret()
			dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
			allScheduleBackupNames, err = Inst().Backup.GetAllScheduleBackupNames(ctx, scheduleName, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching names of all schedule backups of schedule named [%s]", scheduleName))
			for _, backupName := range allScheduleBackupNames {
				restoreName = fmt.Sprintf("%s-%s-%v", restoreNamePrefix, scheduleName, time.Now().Unix())
				err = CreateRestore(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, ctx, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups - %s", restoreName))
				restoreNames = append(restoreNames, restoreName)
			}
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(contexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		dash.VerifySafely(err, nil, "Fetching px-central-admin ctx")
		err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchPolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchPolicyName}))
		for _, restoreName := range restoreNames {
			err = DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting restore [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces- %v", bkpNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsMap, bkpNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsMap, bkpNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(contexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// ManualAndScheduledBackupUsingNamespaceAndResourceLabel performs manual backup, schedule backup and restore, using namespace label and resource label
var _ = Describe("{ManualAndScheduledBackupUsingNamespaceAndResourceLabel}", func() {
	var (
		err                     error
		schPolicyInterval       int64
		backupLocationUID       string
		cloudCredUID            string
		srcClusterUid           string
		backupName              string
		credName                string
		namespaceLabel          string
		backupLocationName      string
		restoreName             string
		periodicSchPolicyName   string
		periodicSchPolicyUid    string
		firstScheduleBackupName string
		scheduleBackupName      string
		bkpNamespaces           []string
		cloudCredUidList        []string
		restoreNames            []string
		nsLabels                map[string]string
		labelSelector           map[string]string
		scheduledAppContexts    []*scheduler.Context
	)
	backupLocationMap := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("ManualAndScheduledBackupUsingNamespaceAndResourceLabel", "Manual, schedule backup and restore, using namespace label and resource label", nil, 84850, Vpinisetti, Q2FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < 3; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces : %v", bkpNamespaces)
	})
	It("Manual, schedule backup and restore using namespace label and resource label", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Generate and add labels to namespaces", func() {
			log.InfoD("Generate and add labels to namespaces")
			nsLabels = GenerateRandomLabels(1)
			err = AddLabelsToMultipleNamespaces(nsLabels, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%s]", nsLabels, bkpNamespaces))
		})
		Step("Adding labels to resources", func() {
			log.InfoD("Adding labels to resources")
			labelKey := uuid.New()
			labelValue := uuid.New()
			for _, namespace := range bkpNamespaces {
				pvcList, err := core.Instance().GetPersistentVolumeClaims(namespace, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc list from namespace [%s]", namespace))
				for _, pvc := range pvcList.Items {
					pvcItem, err := core.Instance().GetPersistentVolumeClaim(pvc.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc pointer %v for pvc %v", pvcItem, pvc))
					err = AddLabelToResource(pvcItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, pvcItem))
				}
				cmList, err := core.Instance().ListConfigMap(namespace, metav1.ListOptions{})
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap list from namespace [%s]", namespace))
				for _, cm := range cmList.Items {
					cmItem, err := core.Instance().GetConfigMap(cm.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap pointer %v from namespace %s", cmItem, namespace))
					err = AddLabelToResource(cmItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, cmItem))
				}
			}
		})
		Step("Generating namespace label string from label map", func() {
			log.InfoD("Generating namespace label string from label map")
			namespaceLabel = MapToKeyValueString(nsLabels)
			log.Infof("Generated labels [%s]", namespaceLabel)
		})
		Step("Creating cloud credentials and backup location", func() {
			log.InfoD("Creating cloud credentials and registering backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err := CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credentials %s with provider %s", credName, provider))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err = CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Add source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Adding source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying addition of source [%s] and destination [%s] clusters", SourceClusterName, destinationClusterName))
			srcClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			log.InfoD("UID of [%s] cluster is %s", SourceClusterName, srcClusterUid)
			destClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		Step("Taking manual backup of applications with namespace label", func() {
			log.InfoD("Taking manual backup of applications with namespace label")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			backupName = fmt.Sprintf("%s-%v", "backup", time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				labelSelector, orgID, srcClusterUid, "", "", "", "", namespaceLabel)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup [%s] creation with labels [%s]", backupName, namespaceLabel))
		})
		Step("Restoring manual backup", func() {
			log.InfoD("Restoring manual backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreName = fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
			err = CreateRestore(restoreName, backupName, nil, SourceClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration of backup %s", restoreName))
			restoreNames = append(restoreNames, restoreName)
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			periodicSchPolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchPolicyUid = uuid.New()
			schPolicyInterval = 15
			periodicSchPolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, schPolicyInterval, 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchPolicyName, periodicSchPolicyUid, orgID, periodicSchPolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", schPolicyInterval, periodicSchPolicyName))
			periodicSchPolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchPolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchPolicyName))
		})
		Step("Creating schedule backup with namespace label", func() {
			log.InfoD("Creating schedule backup with namespace label")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			scheduleBackupName = fmt.Sprintf("%s-%v", BackupNamePrefix, time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			firstScheduleBackupName, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, scheduleBackupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, "", "", "", "", namespaceLabel, periodicSchPolicyName, periodicSchPolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of creating first schedule backup %s with labels [%v]", scheduleBackupName, namespaceLabel))
		})
		Step("Restoring first scheduled backup", func() {
			log.InfoD("Restoring first scheduled backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreName = fmt.Sprintf("%s-%s", restoreNamePrefix, scheduleBackupName)
			err = CreateRestore(restoreName, firstScheduleBackupName, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups - %s", restoreName))
			restoreNames = append(restoreNames, restoreName)
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Unable to fetch px-central-admin ctx")
		err = DeleteSchedule(scheduleBackupName, SourceClusterName, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleBackupName))
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchPolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchPolicyName}))
		for _, restoreName := range restoreNames {
			err := DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verifying the deletion of the restore named [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces - %v", bkpNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(nsLabels, bkpNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabels, bkpNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(scheduledAppContexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// ScheduleBackupWithAdditionAndRemovalOfNS perform schedule backup during which remove and add namespace and verify restoration of removed namespace
var _ = Describe("{ScheduleBackupWithAdditionAndRemovalOfNS}", func() {
	var (
		err                      error
		schPolicyInterval        int
		backupLocationUID        string
		cloudCredUID             string
		srcClusterUid            string
		credName                 string
		backupLocationName       string
		periodicSchPolicyName    string
		periodicSchPolicyUid     string
		scheduleName             string
		namespaceLabel           string
		firstScheduleBackupName  string
		secondScheduleBackupName string
		restoreBeforeNSRemoval   string
		schBackupAfterNSRemoval  string
		newNamespaces            []string
		removedNamespace         []string
		bkpNamespaces            []string
		cloudCredUidList         []string
		restoreNames             []string
		nsLabelsMap              map[string]string
		scheduledAppContexts     []*scheduler.Context
	)
	backupLocationMap := make(map[string]string)
	namespaceMapping := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("ScheduleBackupWithAdditionAndRemovalOfNS", "Perform schedule backup during which remove and add namespace and verify restoration of removed namespace", nil, 84848, Vpinisetti, Q2FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < 5; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces : %v", bkpNamespaces)
	})
	It("Perform schedule backup during which remove and add namespace and verify restoration of removed namespace", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Generate and add labels to namespaces", func() {
			log.InfoD("Generate and add labels to namespaces")
			nsLabelsMap = GenerateRandomLabels(3)
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%s]", nsLabelsMap, bkpNamespaces))
		})
		Step("Generating namespace label string from label map", func() {
			log.InfoD("Generating namespace label string from label map")
			namespaceLabel = MapToKeyValueString(nsLabelsMap)
			log.Infof("Generated labels [%s]", namespaceLabel)
		})
		Step("Creating cloud credentials and backup location", func() {
			log.InfoD("Creating cloud credentials and backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err := CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credentials %s with provider %s", credName, provider))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err = CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Configure source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Adding source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying addition of source [%s] and destination [%s] clusters", SourceClusterName, destinationClusterName))
			srcClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			log.InfoD("UID of [%s] cluster is %s", SourceClusterName, srcClusterUid)
			destClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			periodicSchPolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchPolicyUid = uuid.New()
			schPolicyInterval = 15
			periodicSchPolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, int64(schPolicyInterval), 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchPolicyName, periodicSchPolicyUid, orgID, periodicSchPolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", schPolicyInterval, periodicSchPolicyName))
			periodicSchPolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchPolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchPolicyName))
		})
		Step("Creating schedule backup with namespace label", func() {
			log.InfoD("Creating schedule backup with namespace label")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			scheduleName = fmt.Sprintf("%s-schedule-%v", BackupNamePrefix, time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			firstScheduleBackupName, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, scheduleName, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, "", "", "", "", namespaceLabel, periodicSchPolicyName, periodicSchPolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of first schedule backup [%s]", firstScheduleBackupName))
			log.InfoD("Waiting for %d minutes for the next schedule backup to be triggered", schPolicyInterval)
			secondScheduleBackupName, err = GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of second schedule backup [%s]", secondScheduleBackupName))
		})
		Step("Remove namespace label from namespace and check backup success of next schedule backup", func() {
			log.InfoD("Remove namespace label from namespace and check backup success of next schedule backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			removedNamespace = bkpNamespaces[:3]
			err = DeleteLabelsFromMultipleNamespaces(nsLabelsMap, removedNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Removing labels [%v] from namespaces [%v]", nsLabelsMap, removedNamespace))
			schBackupAfterNSRemoval, err = GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup success for %s schedule backup after nmaespace removal %v", schBackupAfterNSRemoval, removedNamespace))
		})
		Step("Restore the backup which was taken before the namespace removal and the namespace should be recovered", func() {
			log.InfoD("Restore the backup which was taken before the namespace removal and the namespace should be recovered")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreBeforeNamespaceIsRemoved := fmt.Sprintf("%s-%v", restoreNamePrefix, time.Now().Unix())
			err = CreateRestore(restoreBeforeNamespaceIsRemoved, secondScheduleBackupName, namespaceMapping, destinationClusterName, orgID, ctx, make(map[string]string))
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore for %s", restoreBeforeNamespaceIsRemoved))
			restoreNames = append(restoreNames, restoreBeforeNamespaceIsRemoved)
			restoreInspectRequest := &api.RestoreInspectRequest{
				Name:  restoreBeforeNamespaceIsRemoved,
				OrgId: orgID,
			}
			resp, err := Inst().Backup.InspectRestore(ctx, restoreInspectRequest)
			log.FailOnError(err, "Unable to fetch restore response")
			namespaceMap := resp.GetRestore().NamespaceMapping
			isRestored := NamespaceExistsInNamespaceMapping(namespaceMap, removedNamespace)
			dash.VerifyFatal(isRestored, true, fmt.Sprintf("Verifying if deleted namespaces %v are restored in schedule backup %s", removedNamespace, secondScheduleBackupName))
		})
		Step("Schedule applications to create new namespaces", func() {
			log.InfoD("Scheduling applications to create new namespaces")
			scheduledAppContexts = make([]*scheduler.Context, 0)
			for i := 0; i < 2; i++ {
				taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
				appContexts := ScheduleApplications(taskName)
				scheduledAppContexts = append(scheduledAppContexts, appContexts...)
				for _, ctx := range appContexts {
					ctx.ReadinessTimeout = appReadinessTimeout
					namespace := GetAppNamespace(ctx, taskName)
					log.InfoD("Scheduled application with namespace [%s]", namespace)
					newNamespaces = append(newNamespaces, namespace)
				}
			}
		})
		Step("Validate new namespaces", func() {
			log.InfoD("Validating new namespaces")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Apply same namespace labels to new namespace", func() {
			log.InfoD("Apply same namespace labels to new namespace")
			err = AddLabelsToMultipleNamespaces(nsLabelsMap, newNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to new namespaces [%s]", nsLabelsMap, newNamespaces))
		})
		Step("Continue next schedule backups", func() {
			log.InfoD("Continue next schedule backups")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			scheduleBkpAfterNSRemovalTwo, err := GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup success for %s schedule backup %s", scheduleBkpAfterNSRemovalTwo, scheduleName))
			scheduleBkpAfterNSRemovalThree, err := GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup success for %s schedule backup %s", scheduleBkpAfterNSRemovalThree, scheduleName))
		})
		Step("Restore the backup which was taken with less namespaces", func() {
			log.InfoD("Restore the backup which was taken with less namespaces")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreAfterNamespaceIsRemoved := fmt.Sprintf("%s-%v", restoreNamePrefix, time.Now().Unix())
			err = CreateRestore(restoreAfterNamespaceIsRemoved, schBackupAfterNSRemoval, namespaceMapping, destinationClusterName, orgID, ctx, make(map[string]string))
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore for %s", restoreBeforeNSRemoval))
			restoreNames = append(restoreNames, restoreAfterNamespaceIsRemoved)
			restoreInspectRequest := &api.RestoreInspectRequest{
				Name:  restoreAfterNamespaceIsRemoved,
				OrgId: orgID,
			}
			resp, err := Inst().Backup.InspectRestore(ctx, restoreInspectRequest)
			log.FailOnError(err, "Unable to fetch restore response")
			namespaceMap := resp.GetRestore().NamespaceMapping
			isRestored := NamespaceExistsInNamespaceMapping(namespaceMap, bkpNamespaces[3:])
			dash.VerifyFatal(isRestored, true, fmt.Sprintf("Verifying restoration of schedule backup %s which was taken with less namespaces %v", secondScheduleBackupName, bkpNamespaces[3:]))
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		time.Sleep(1 * time.Minute)
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchPolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchPolicyName}))
		for _, restoreName := range restoreNames {
			err := DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verifying the deletion of the restore named [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces- %v", bkpNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsMap, bkpNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsMap, bkpNamespaces))
		bkpNamespaces = append(bkpNamespaces, newNamespaces...)
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(scheduledAppContexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// ManualAndScheduleBackupUsingNSLabelWithMaxCharLimit Perform manual, schedule backup and restore of single, multiple and all namespaces with namespace labeled as max character limit
var _ = Describe("{ManualAndScheduleBackupUsingNSLabelWithMaxCharLimit}", func() {
	var (
		err                            error
		backupLocationUID              string
		cloudCredUID                   string
		clusterUid                     string
		credName                       string
		backupLocationName             string
		restoreName                    string
		periodicSchPolicyName          string
		periodicSchPolicyUid           string
		labelForSingleNamespace        string
		labelForMultipleNamespace      string
		schBackupSingleNS              string
		schBackupMultipleNS            string
		schBackupAllNS                 string
		manualBackupSingleNS           string
		manualBackupMultipleNS         string
		manualBackupAllNS              string
		firstSchBackupForSingleNS      string
		firstSchBackupForMultipleNS    string
		firstSchBackupForAllNS         string
		incrementalRestoreSingleNS     string
		incrementalRestoreMultipleNS   string
		incrementalRestoreAllNS        string
		singleNamespace                string
		labelForAllNamespace           string
		multipleNamespace              []string
		cloudCredUidList               []string
		restoreNames                   []string
		bkpNamespaces                  []string
		scheduleNames                  []string
		scheduleAllNSRestoreMapping    map[string]string
		scheduleMultipleRestoreMapping map[string]string
		scheduleRestoreMapping         map[string]string
		nsLabelsGroup1                 map[string]string
		nsLabelsGroup2                 map[string]string
		nsLabelsGroup3                 map[string]string
		scheduledAppContexts           []*scheduler.Context
	)
	backupLocationMap := make(map[string]string)
	labelSelectors := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("ManualAndScheduleBackupUsingNSLabelWithMaxCharLimit", "Manual, schedule backup and restore of single, multiple and all namespaces with namespace labeled as max character limit", nil, 84853, Vpinisetti, Q2FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < 3; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Manual, schedule backup and restore of single, multiple and all namespaces with namespace labeled as max character limit", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Adding labels to resources", func() {
			log.InfoD("Adding labels to resources")
			labelKey := uuid.New()
			labelValue := uuid.New()
			labelSelectors[labelKey] = labelValue
			for _, namespace := range bkpNamespaces {
				pvcList, err := core.Instance().GetPersistentVolumeClaims(namespace, nil)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc list from namespace [%s]", namespace))
				for _, pvc := range pvcList.Items {
					pvcItem, err := core.Instance().GetPersistentVolumeClaim(pvc.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching pvc pointer %v for pvc %v", pvcItem, pvc))
					err = AddLabelToResource(pvcItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, pvcItem))
				}
				cmList, err := core.Instance().ListConfigMap(namespace, metav1.ListOptions{})
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap list from namespace [%s]", namespace))
				for _, cm := range cmList.Items {
					cmItem, err := core.Instance().GetConfigMap(cm.Name, namespace)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching configmap pointer %v from namespace %s", cmItem, namespace))
					err = AddLabelToResource(cmItem, labelKey, labelValue)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels %s=%s to resource %v", labelKey, labelValue, cmItem))
				}
			}
		})
		Step("Adding labels to namespaces", func() {
			log.InfoD("Adding labels to namespaces")
			singleNamespace = bkpNamespaces[0]
			multipleNamespace = bkpNamespaces[1:]
			nsLabelsGroup1 = GenerateRandomLabelsWithMaxChar(3, 63)
			err = AddLabelsToMultipleNamespaces(nsLabelsGroup1, multipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to multiple namespaces [%v]", nsLabelsGroup1, multipleNamespace))
			nsLabelsGroup2 = GenerateRandomLabelsWithMaxChar(3, 63)
			err = Inst().S.AddNamespaceLabel(singleNamespace, nsLabelsGroup2)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to single namespaces [%s]", nsLabelsGroup2, singleNamespace))
			nsLabelsGroup3 = GenerateRandomLabelsWithMaxChar(3, 63)
			err = AddLabelsToMultipleNamespaces(nsLabelsGroup3, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to all namespaces [%v]", nsLabelsGroup3, bkpNamespaces))

		})
		Step("Generating namespace label string from label map for single and multiple namespace", func() {
			log.InfoD("Generating namespace label string from label map for single and multiple namespace")
			labelForSingleNamespace = MapToKeyValueString(nsLabelsGroup2)
			log.Infof("Labels for single namespace [%s]", labelForSingleNamespace)
			labelForMultipleNamespace = MapToKeyValueString(nsLabelsGroup1)
			log.Infof("Labels for multiple namespace [%s]", labelForMultipleNamespace)
			labelForAllNamespace = MapToKeyValueString(nsLabelsGroup3)
			log.Infof("Labels for all namespaces [%s]", labelForAllNamespace)
		})
		Step("Creating cloud credentials and backup location", func() {
			log.InfoD("Creating cloud credentials and backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credential named %s", credName))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err := CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Add source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Adding source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying addition of source [%s] and destination [%s] clusters", SourceClusterName, destinationClusterName))
			srcClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(srcClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			log.InfoD("UID of [%s] cluster is %s", SourceClusterName, clusterUid)
			destClusterStatus, err := Inst().Backup.GetClusterStatus(orgID, destinationClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", destinationClusterName))
			dash.VerifyFatal(destClusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", destinationClusterName))
		})
		Step("Taking manual backup of single application with namespace label filter", func() {
			log.InfoD("Taking manual backup of single application with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			manualBackupSingleNS = fmt.Sprintf("%s-%v", "single-namespace-backup", time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{singleNamespace})
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, manualBackupSingleNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, clusterUid, "", "", "", "", labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying status of backup [%s] creation with label [%s]", manualBackupSingleNS, labelForSingleNamespace))
			err = NamespaceLabelBackupSuccessCheck(manualBackupSingleNS, ctx, []string{singleNamespace}, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", singleNamespace, labelForSingleNamespace, manualBackupSingleNS))
		})
		Step("Taking manual backup of multiple applications with namespace label filter", func() {
			log.InfoD("Taking manual backup of multiple applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			manualBackupMultipleNS = fmt.Sprintf("%s-%v", "multiple-namespace-backup", time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, multipleNamespace)
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, manualBackupMultipleNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, clusterUid, "", "", "", "", labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup [%s] creation with labels [%s]", manualBackupMultipleNS, labelForMultipleNamespace))
			err = NamespaceLabelBackupSuccessCheck(manualBackupMultipleNS, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", multipleNamespace, labelForMultipleNamespace, manualBackupMultipleNS))
		})
		Step("Taking manual backup of all applications with namespace label filter", func() {
			log.InfoD("Taking manual backup of all applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			manualBackupAllNS = fmt.Sprintf("%s-%v", "all-namespace-backup", time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, manualBackupAllNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, clusterUid, "", "", "", "", labelForAllNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup [%s] creation with labels [%v]", manualBackupAllNS, labelForAllNamespace))
			err = NamespaceLabelBackupSuccessCheck(manualBackupAllNS, ctx, bkpNamespaces, labelForAllNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", bkpNamespaces, labelForAllNamespace, manualBackupAllNS))
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			periodicSchPolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchPolicyUid = uuid.New()
			periodicSchPolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, 15, 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchPolicyName, periodicSchPolicyUid, orgID, periodicSchPolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval 15 minutes named [%s]", periodicSchPolicyName))
			periodicSchPolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchPolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchPolicyName))
		})
		Step("Creating a schedule backup for single namespace with namespace label filter", func() {
			log.InfoD("Creating a schedule backup for single namespace with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			schBackupSingleNS = fmt.Sprintf("%s-%v", BackupNamePrefix, time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{singleNamespace})
			firstSchBackupForSingleNS, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, schBackupSingleNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, "", "", "", "", labelForSingleNamespace, periodicSchPolicyName, periodicSchPolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of first scheduled backup [%s] for single namespace with labels [%v]", firstSchBackupForSingleNS, labelForSingleNamespace))
			err = NamespaceLabelBackupSuccessCheck(firstSchBackupForSingleNS, ctx, []string{singleNamespace}, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", singleNamespace, labelForSingleNamespace, firstSchBackupForSingleNS))
			scheduleNames = append(scheduleNames, schBackupSingleNS)
		})
		Step("Creating a schedule backup for multiple applications with namespace label filter", func() {
			log.InfoD("Creating a schedule backup for multiple applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			schBackupMultipleNS = fmt.Sprintf("%s-%v", BackupNamePrefix, time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, multipleNamespace)
			firstSchBackupForMultipleNS, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, schBackupMultipleNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, "", "", "", "", labelForMultipleNamespace, periodicSchPolicyName, periodicSchPolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of first scheduled backup [%s] for multiple namespaces with labels [%v]", firstSchBackupForMultipleNS, labelForMultipleNamespace))
			err = NamespaceLabelBackupSuccessCheck(firstSchBackupForMultipleNS, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", multipleNamespace, labelForMultipleNamespace, firstSchBackupForMultipleNS))
			scheduleNames = append(scheduleNames, schBackupMultipleNS)
		})
		Step("Creating a schedule backup for all applications with namespace label filter", func() {
			log.InfoD("Creating a schedule backup for all applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			schBackupAllNS = fmt.Sprintf("%s-%v", BackupNamePrefix, time.Now().Unix())
			appContextsExpectedInBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			firstSchBackupForAllNS, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, schBackupAllNS, SourceClusterName, backupLocationName, backupLocationUID, appContextsExpectedInBackup,
				nil, orgID, "", "", "", "", labelForAllNamespace, periodicSchPolicyName, periodicSchPolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of first schedule backup [%s] for all namespaces with labels [%v]", firstSchBackupForAllNS, labelForAllNamespace))
			err = NamespaceLabelBackupSuccessCheck(firstSchBackupForAllNS, ctx, bkpNamespaces, labelForAllNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", bkpNamespaces, labelForAllNamespace, firstSchBackupForAllNS))
			scheduleNames = append(scheduleNames, schBackupAllNS)
		})
		Step("Restoring backup of single application", func() {
			log.InfoD("Restoring backup of single application")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreName = fmt.Sprintf("%s-%v", manualBackupSingleNS, time.Now().Unix())
			err = CreateRestore(restoreName, manualBackupSingleNS, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore with name [%s] in default namespace", restoreName))
			restoreNames = append(restoreNames, restoreName)
		})
		Step("Restoring multiple applications backup", func() {
			log.InfoD("Restoring multiple applications backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreName = fmt.Sprintf("%s-%v", manualBackupMultipleNS, time.Now().Unix())
			err = CreateRestore(restoreName, manualBackupMultipleNS, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying multiple backups [%s] restore in default namespace", restoreName))
			restoreNames = append(restoreNames, restoreName)
		})
		Step("Restoring all applications backup", func() {
			log.InfoD("Restoring all applications backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreName = fmt.Sprintf("%s-%v", manualBackupAllNS, time.Now().Unix())
			err = CreateRestore(restoreName, manualBackupAllNS, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying all backups [%s] restore in default namespace", restoreName))
			restoreNames = append(restoreNames, restoreName)
		})
		Step("Restoring the incremental scheduled backup of single application", func() {
			log.InfoD("Restoring the incremental scheduled backup of single application")
			scheduleRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			log.InfoD("Waiting for the incremental scheduled backup for single namespace to be triggered")
			_, err = GetNextPeriodicScheduleBackupName(schBackupSingleNS, 15, ctx)
			incrementalRestoreSingleNS, err = GetOrdinalScheduleBackupName(ctx, schBackupSingleNS, 2, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", incrementalRestoreSingleNS))
			err = NamespaceLabelBackupSuccessCheck(incrementalRestoreSingleNS, ctx, []string{singleNamespace}, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", singleNamespace, labelForSingleNamespace, incrementalRestoreSingleNS))
			// Restore to custom namespace
			backupScheduleNamespace, err := FetchNamespacesFromBackup(ctx, incrementalRestoreSingleNS, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %s from schedule backup %s", backupScheduleNamespace, incrementalRestoreSingleNS))
			restoredNameSpace := fmt.Sprintf("%s-%v", backupScheduleNamespace[0], time.Now().Unix())
			scheduleRestoreMapping[backupScheduleNamespace[0]] = restoredNameSpace
			customRestoreName := fmt.Sprintf("%s-%v", schBackupSingleNS, time.Now().Unix())
			err = CreateRestore(customRestoreName, incrementalRestoreSingleNS, scheduleRestoreMapping, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups %s in custom namespace %v", customRestoreName, scheduleRestoreMapping))
			restoreNames = append(restoreNames, customRestoreName)
		})
		Step("Restoring the incremental scheduled backup of multiple applications", func() {
			log.InfoD("Restoring the incremental scheduled backup of multiple applications")
			scheduleMultipleRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			log.InfoD("Waiting for the incremental scheduled backup for multiple namespace to be triggered")
			_, err = GetNextPeriodicScheduleBackupName(schBackupMultipleNS, 15, ctx)
			incrementalRestoreMultipleNS, err = GetOrdinalScheduleBackupName(ctx, schBackupMultipleNS, 2, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", incrementalRestoreMultipleNS))
			err = NamespaceLabelBackupSuccessCheck(incrementalRestoreMultipleNS, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", multipleNamespace, labelForMultipleNamespace, incrementalRestoreMultipleNS))
			// Restore to custom namespace
			multipleBackupScheduleNamespace, err := FetchNamespacesFromBackup(ctx, incrementalRestoreMultipleNS, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %v from schedule backup %v", multipleBackupScheduleNamespace, incrementalRestoreMultipleNS))
			for _, namespace := range multipleBackupScheduleNamespace {
				restoredNameSpace := fmt.Sprintf("%s-%v", RestoreNamePrefix, time.Now().Unix())
				scheduleMultipleRestoreMapping[namespace] = restoredNameSpace
			}
			customRestoreName := fmt.Sprintf("%s-%v", schBackupMultipleNS, time.Now().Unix())
			err = CreateRestore(customRestoreName, incrementalRestoreMultipleNS, scheduleMultipleRestoreMapping, SourceClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups for multiple application [%s] in custom namespace [%v]", customRestoreName, scheduleMultipleRestoreMapping))
			restoreNames = append(restoreNames, customRestoreName)
		})
		Step("Restoring the incremental scheduled backup of all applications", func() {
			log.InfoD("Restoring the incremental scheduled backup of all applications")
			scheduleAllNSRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			log.InfoD("Waiting for the incremental scheduled backup for all namespace to be triggered")
			_, err = GetNextPeriodicScheduleBackupName(schBackupAllNS, 15, ctx)
			incrementalRestoreAllNS, err = GetOrdinalScheduleBackupName(ctx, schBackupAllNS, 2, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", incrementalRestoreAllNS))
			err = NamespaceLabelBackupSuccessCheck(incrementalRestoreAllNS, ctx, bkpNamespaces, labelForAllNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", bkpNamespaces, labelForAllNamespace, incrementalRestoreAllNS))
			// Restore to custom namespace
			allNSBackupScheduleNamespace, err := FetchNamespacesFromBackup(ctx, incrementalRestoreAllNS, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %v from schedule backup %v", allNSBackupScheduleNamespace, incrementalRestoreAllNS))
			for _, namespace := range allNSBackupScheduleNamespace {
				restoredNameSpace := fmt.Sprintf("%s-%v", RestoreNamePrefix, time.Now().Unix())
				scheduleAllNSRestoreMapping[namespace] = restoredNameSpace
			}
			customRestoreName := fmt.Sprintf("%s-%v", schBackupAllNS, time.Now().Unix())
			err = CreateRestore(customRestoreName, incrementalRestoreAllNS, scheduleAllNSRestoreMapping, SourceClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups for all application [%s] in custom namespace [%v]", customRestoreName, scheduleAllNSRestoreMapping))
			restoreNames = append(restoreNames, customRestoreName)
		})
	})
	JustAfterEach(func() {
		log.InfoD("Deleting test data generated during test execution")
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for _, scheduleName := range scheduleNames {
			err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		}
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchPolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchPolicyName}))
		for _, restoreName := range restoreNames {
			err := DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verifying the deletion of the restore named [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces- %v", bkpNamespaces)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsGroup3, bkpNamespaces)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsGroup3, bkpNamespaces))
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(scheduledAppContexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// ManualAndScheduleBackupUsingNamespaceLabel Perform Namespace labeled manual and schedule backup of single and multiple namespaces along with default and custom restore
var _ = Describe("{ManualAndScheduleBackupUsingNamespaceLabel}", func() {
	var (
		err                               error
		backupLocationUID                 string
		cloudCredUID                      string
		clusterUid                        string
		manualBkpSingleNS                 string
		credName                          string
		backupLocationName                string
		restoreName                       string
		periodicSchedulePolicyName        string
		periodicSchedulePolicyUid         string
		labelForSingleNamespace           string
		labelForMultipleNamespace         string
		scheduleBkpSingleNs               string
		firstScheduleBackupName           string
		manualBkpMultipleNS               string
		scheduleBkpMultipleNs             string
		firstScheduleBackupForMultipleNs  string
		secondScheduleBackupForMultipleNs string
		secondScheduleBackupName          string
		singleNamespace                   []string
		multipleNamespace                 []string
		cloudCredUidList                  []string
		restoreNames                      []string
		bkpNamespaces                     []string
		scheduleNames                     []string
		nsLabelsGroup1                    map[string]string
		nsLabelsGroup2                    map[string]string
		namespaceMapping                  map[string]string
		multipleRestoreMapping            map[string]string
		scheduleRestoreMapping            map[string]string
		scheduleMultipleRestoreMapping    map[string]string
		scheduledAppContexts              []*scheduler.Context
	)
	backupLocationMap := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("ManualAndScheduleBackupUsingNamespaceLabel", "Namespace labeled manual and schedule backup of single and multiple namespaces along with default and custom restore", nil, 84842, Apimpalgaonkar, Q2FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < 3; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Namespace labeled manual and schedule backup of single and multiple namespaces along with default and custom restore", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})
		Step("Adding labels to namespaces", func() {
			log.InfoD("Adding labels to namespaces")
			singleNamespace = []string{bkpNamespaces[0]}
			multipleNamespace = bkpNamespaces[1:]
			nsLabelsGroup1 = GenerateRandomLabels(10)
			err = AddLabelsToMultipleNamespaces(nsLabelsGroup1, multipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to multiple namespaces [%v]", nsLabelsGroup1, multipleNamespace))
			nsLabelsGroup2 = GenerateRandomLabels(10)
			err = AddLabelsToMultipleNamespaces(nsLabelsGroup2, singleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to single namespaces [%v]", nsLabelsGroup2, singleNamespace))
		})
		Step("Generating namespace label string from label map for single and multiple namespace", func() {
			log.InfoD("Generating namespace label string from label map for single and multiple namespace")
			labelForSingleNamespace = MapToKeyValueString(nsLabelsGroup2)
			log.Infof("labels for single namespace [%s]", labelForSingleNamespace)
			labelForMultipleNamespace = MapToKeyValueString(nsLabelsGroup1)
			log.Infof("labels for multiple namespace [%s]", labelForMultipleNamespace)
		})
		Step("Creating cloud credentials and registering backup location", func() {
			log.InfoD("Creating cloud credentials and registering backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credential named %s", credName))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationMap[backupLocationUID] = backupLocationName
				err := CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})
		Step("Configure source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Configuring source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of source [%s] and destination [%s] clusters with px-central-admin ctx", SourceClusterName, destinationClusterName))
			appClusterName := SourceClusterName
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, appClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", appClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", appClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, appClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", appClusterName))
			log.InfoD("Uid of [%s] cluster is %s", appClusterName, clusterUid)
		})
		Step("Taking a manual backup of single application with namespace label filter", func() {
			log.InfoD("Taking a manual backup of single application with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")

			manualBkpSingleNS = fmt.Sprintf("%s-%v", "backup", time.Now().Unix())
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, singleNamespace)
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, manualBkpSingleNS, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, clusterUid, "", "", "", "", labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled backup [%s] with label [%s]", manualBkpSingleNS, labelForSingleNamespace))

			err = NamespaceLabelBackupSuccessCheck(manualBkpSingleNS, ctx, singleNamespace, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", singleNamespace, labelForSingleNamespace, manualBkpSingleNS))
		})
		Step("Taking a manual backup of multiple applications with namespace label filter", func() {
			log.InfoD("Taking a manual backup of multiple applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")

			manualBkpMultipleNS = fmt.Sprintf("%s-%v", "multiple-namespace-backup", time.Now().Unix())
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, multipleNamespace)
			err = CreateBackupWithNamespaceLabelWithValidation(ctx, manualBkpMultipleNS, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, clusterUid, "", "", "", "", labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled backup [%s] with label [%s]", manualBkpMultipleNS, labelForMultipleNamespace))

			err = NamespaceLabelBackupSuccessCheck(manualBkpMultipleNS, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", multipleNamespace, labelForMultipleNamespace, manualBkpMultipleNS))
		})
		Step("Create schedule policy", func() {
			log.InfoD("Creating a schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, 15, 5)
			err = Inst().Backup.BackupSchedulePolicy(periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, periodicSchedulePolicyInfo)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval 15 minutes named [%s]", periodicSchedulePolicyName))
			periodicSchedulePolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchedulePolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchedulePolicyName))
		})
		Step("Creating a schedule backup for single namespace with namespace label filter", func() {
			log.InfoD("Creating a schedule backup for single namespace with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")

			scheduleBkpSingleNs = fmt.Sprintf("%s-schedule-%v", BackupNamePrefix, time.Now().Unix())
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, singleNamespace)
			firstScheduleBackupName, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, scheduleBkpSingleNs, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, "", "", "", "", labelForSingleNamespace, periodicSchedulePolicyName, periodicSchedulePolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled schedule backup [%s] with label [%s]", scheduleBkpSingleNs, labelForSingleNamespace))
			scheduleNames = append(scheduleNames, scheduleBkpSingleNs)

			err = NamespaceLabelBackupSuccessCheck(firstScheduleBackupName, ctx, singleNamespace, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", singleNamespace, labelForSingleNamespace, firstScheduleBackupName))
		})
		Step("Creating a schedule backup for multiple applications with namespace label filter", func() {
			log.InfoD("Creating a schedule backup for multiple applications with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")

			scheduleBkpMultipleNs = fmt.Sprintf("%s-%v", BackupNamePrefix, time.Now().Unix())
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, multipleNamespace)
			firstScheduleBackupForMultipleNs, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, scheduleBkpMultipleNs, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, "", "", "", "", labelForMultipleNamespace, periodicSchedulePolicyName, periodicSchedulePolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of namespace labelled schedule backup [%s] with label [%s]", scheduleBkpMultipleNs, labelForMultipleNamespace))
			scheduleNames = append(scheduleNames, scheduleBkpMultipleNs)

			err = NamespaceLabelBackupSuccessCheck(firstScheduleBackupForMultipleNs, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespaces [%v] are backed up and check for labels [%s] applied to backups [%s]", multipleNamespace, labelForMultipleNamespace, firstScheduleBackupForMultipleNs))
		})
		Step("Restoring manual backup of single application", func() {
			log.InfoD("Restoring backup of single application")
			namespaceMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			// Restore backup to default namespace
			restoreName = fmt.Sprintf("%s-%v", manualBkpSingleNS, time.Now().Unix())
			err = CreateRestore(restoreName, manualBkpSingleNS, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore with name [%s] in default namespace", restoreName))
			// Restore backup to custom namespace
			backupNamespace, err := FetchNamespacesFromBackup(ctx, manualBkpSingleNS, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %v from backup %s", backupNamespace, manualBkpSingleNS))
			customNamespace := fmt.Sprintf("%s-%v", manualBkpSingleNS, time.Now().Unix())
			customRestoreName := fmt.Sprintf("%s-%v", backupNamespace[0], time.Now().Unix())
			namespaceMapping[backupNamespace[0]] = customNamespace
			err = CreateRestore(customRestoreName, manualBkpSingleNS, namespaceMapping, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying backup restore [%s] in custom namespace [%s]", customRestoreName, customNamespace))
			restoreNames = append(restoreNames, restoreName, customRestoreName)
		})
		Step("Restoring manual backup of multiple applications backup", func() {
			log.InfoD("Restoring manual backup of multiple applications backup")
			multipleRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			// Restore to default namespace
			restoreName = fmt.Sprintf("%s-%v", manualBkpMultipleNS, time.Now().Unix())
			err = CreateRestore(restoreName, manualBkpMultipleNS, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying multiple backups [%s] restore in default namespace", restoreName))
			multipleBackupNamespace, err := FetchNamespacesFromBackup(ctx, manualBkpMultipleNS, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %v from backup %v", multipleBackupNamespace, manualBkpMultipleNS))
			// Restore to custom namespace
			for _, namespace := range multipleBackupNamespace {
				restoredNameSpace := fmt.Sprintf("%s-%v", manualBkpMultipleNS, time.Now().Unix())
				multipleRestoreMapping[namespace] = restoredNameSpace
			}
			customRestoreName := fmt.Sprintf("%s-%v", "multiple-application", time.Now().Unix())
			err = CreateRestore(customRestoreName, manualBkpMultipleNS, multipleRestoreMapping, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying multiple backup restore [%s] in custom namespace [%v]", customRestoreName, multipleRestoreMapping))
			restoreNames = append(restoreNames, restoreName, customRestoreName)
		})
		Step("Restoring the incremental scheduled backup of single namespace", func() {
			log.InfoD("Restoring the incremental scheduled backup of single namespace")
			scheduleRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			log.InfoD("Waiting for the incremental scheduled backup for single namespace to be triggered")
			secondScheduleBackupName, err = GetNextScheduleBackupName(scheduleBkpSingleNs, time.Duration(15), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", secondScheduleBackupName))
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, singleNamespace)
			err = backupSuccessCheckWithValidation(ctx, secondScheduleBackupName, scheduledAppContextsExpectedToBeInBackup, orgID, maxWaitPeriodForBackupCompletionInMinutes*time.Minute, 30*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of success and Validation of second schedule backup named [%s] of schedule named [%s]", secondScheduleBackupName, scheduleBkpSingleNs))
			err = NamespaceLabelBackupSuccessCheck(secondScheduleBackupName, ctx, singleNamespace, labelForSingleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", bkpNamespaces, labelForSingleNamespace, secondScheduleBackupName))
			// Restore to default namespace
			restoreName = fmt.Sprintf("%s-%v", restoreNamePrefix, time.Now().Unix())
			err = CreateRestore(restoreName, secondScheduleBackupName, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups - %s", restoreName))
			// Restore to custom namespace
			backupScheduleNamespace, err := FetchNamespacesFromBackup(ctx, secondScheduleBackupName, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %s from schedule backup %s", backupScheduleNamespace, secondScheduleBackupName))
			restoredNameSpace := fmt.Sprintf("%s-%v", backupScheduleNamespace[0], time.Now().Unix())
			scheduleRestoreMapping[backupScheduleNamespace[0]] = restoredNameSpace
			customRestoreName := fmt.Sprintf("%s-%v", scheduleBkpSingleNs, time.Now().Unix())
			err = CreateRestore(customRestoreName, secondScheduleBackupName, scheduleRestoreMapping, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups %s in custom namespace %v", customRestoreName, scheduleRestoreMapping))
			restoreNames = append(restoreNames, restoreName, customRestoreName)
		})
		Step("Restoring the incremental backups for multiple applications", func() {
			log.InfoD("Restoring he incremental backups for multiple applications")
			scheduleMultipleRestoreMapping = make(map[string]string)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			secondScheduleBackupForMultipleNs, err = GetNextScheduleBackupName(scheduleBkpMultipleNs, time.Duration(15), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching the name of the second schedule backup [%s]", secondScheduleBackupForMultipleNs))
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, multipleNamespace)
			err = backupSuccessCheckWithValidation(ctx, secondScheduleBackupForMultipleNs, scheduledAppContextsExpectedToBeInBackup, orgID, maxWaitPeriodForBackupCompletionInMinutes*time.Minute, 30*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of success and Validation of second schedule backup named [%s] of schedule named [%s]", secondScheduleBackupForMultipleNs, scheduleBkpMultipleNs))
			err = NamespaceLabelBackupSuccessCheck(secondScheduleBackupForMultipleNs, ctx, multipleNamespace, labelForMultipleNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if the labeled namespace [%v] is backed up and checks for labels [%s] applied to backup [%s]", bkpNamespaces, labelForMultipleNamespace, secondScheduleBackupForMultipleNs))
			// Restore to default namespace
			restoreName = fmt.Sprintf("%s-%v", RestoreNamePrefix, time.Now().Unix())
			err = CreateRestore(restoreName, secondScheduleBackupForMultipleNs, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups for multiple application %s in default namespace", restoreName))
			// Restore to custom namespace
			multipleBackupScheduleNamespace, err := FetchNamespacesFromBackup(ctx, secondScheduleBackupForMultipleNs, orgID)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching namespaces %v from schedule backup %v", multipleBackupScheduleNamespace, secondScheduleBackupForMultipleNs))
			for _, namespace := range multipleBackupScheduleNamespace {
				restoredNameSpace := fmt.Sprintf("%s-%v", RestoreNamePrefix, time.Now().Unix())
				scheduleMultipleRestoreMapping[namespace] = restoredNameSpace
			}
			customRestoreName := fmt.Sprintf("%s-%v", scheduleBkpMultipleNs, time.Now().Unix())
			err = CreateRestore(customRestoreName, secondScheduleBackupForMultipleNs, scheduleMultipleRestoreMapping, SourceClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of restoring scheduled backups for multiple application [%s] in custom namespace [%v]", customRestoreName, scheduleMultipleRestoreMapping))
			restoreNames = append(restoreNames, customRestoreName, restoreName)
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for _, scheduleName := range scheduleNames {
			err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		}
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		for _, restoreName := range restoreNames {
			err := DeleteRestore(restoreName, orgID, ctx)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verifying the deletion of the restore named [%s]", restoreName))
		}
		log.InfoD("Deleting labels from namespaces- %v", multipleNamespace)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsGroup1, multipleNamespace)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsGroup1, multipleNamespace))
		log.InfoD("Deleting labels from namespaces- %v", singleNamespace)
		err = DeleteLabelsFromMultipleNamespaces(nsLabelsGroup2, singleNamespace)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting labels [%v] from namespaces [%v]", nsLabelsGroup2, singleNamespace))

		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		log.InfoD("Deleting deployed namespaces - %v", bkpNamespaces)
		DestroyApps(scheduledAppContexts, opts)
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// NamespaceLabelledBackupOfEmptyNamespace takes namespace labelled backup of empty namespace and restores it
var _ = Describe("{NamespaceLabelledBackupOfEmptyNamespace}", func() {
	var (
		backupLocationUID           string
		cloudCredUID                string
		clusterUid                  string
		credName                    string
		backupLocationName          string
		labelForNamespace           string
		periodicSchedulePolicyName  string
		periodicSchedulePolicyUid   string
		scheduleName                string
		firstScheduleBackupName     string
		emptyNamespaceRestore       string
		nextScheduleBackupName      string
		scheduleBackupWithNamespace string
		restoreWithNamespaces       string
		schPolicyInterval           int64
		cloudCredUidList            []string
		bkpNamespaces               []string
		scheduleBackupList          []string
		nsLabels                    map[string]string
		scheduledAppContexts        []*scheduler.Context
	)
	backupLocationMap := make(map[string]string)
	bkpNamespaces = make([]string, 0)
	schPolicyInterval = 15
	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("NamespaceLabelledBackupOfEmptyNamespace", "NamespaceLabelledBackupOfEmptyNamespace takes namespace labelled backup of empty namespace and restores it", nil, 86693, Sagrawal, Q3FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < 3; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Namespace labelled backup of empty namespace and restore it", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step("Generating namespace label string from label map ", func() {
			log.InfoD("Generating namespace label string from label map")
			nsLabels = GenerateRandomLabels(2)
			labelForNamespace = MapToKeyValueString(nsLabels)
			log.Infof("labels for namespace are [%s]", labelForNamespace)
		})

		Step("Creating cloud credentials and registering backup location", func() {
			log.InfoD("Creating cloud credentials and registering backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			for _, provider := range providers {
				cloudCredUID = uuid.New()
				cloudCredUidList = append(cloudCredUidList, cloudCredUID)
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating cloud credential named %s", credName))
				log.InfoD("Created Cloud Credentials with name - %s", credName)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
				backupLocationMap[backupLocationUID] = backupLocationName
				err := CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "")
				dash.VerifyFatal(err, nil, fmt.Sprintf("Creating backup location %s", backupLocationName))
			}
		})

		Step("Configure source and destination clusters with px-central-admin ctx", func() {
			log.InfoD("Configuring source and destination clusters with px-central-admin ctx")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of source [%s] and destination [%s] clusters with px-central-admin ctx", SourceClusterName, destinationClusterName))
			appClusterName := SourceClusterName
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, appClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", appClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", appClusterName))
			clusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, appClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", appClusterName))
			log.InfoD("Uid of [%s] cluster is %s", appClusterName, clusterUid)
		})

		Step("Create schedule policy", func() {
			log.InfoD("Creating schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%v", "periodic", RandomString(5))
			periodicSchedulePolicyUid = uuid.New()
			err = CreateBackupScheduleIntervalPolicy(5, 15, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, ctx)
		})

		Step("Creating a schedule backup of empty namespace with namespace label filter", func() {
			log.InfoD("Creating a schedule backup of empty namespace with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			scheduleName = fmt.Sprintf("%s-schedule-%v", BackupNamePrefix, RandomString(5))
			scheduledAppContextsExpectedToBeInBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{})
			firstScheduleBackupName, err = CreateScheduleBackupWithNamespaceLabelWithValidation(ctx, scheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContextsExpectedToBeInBackup, nil, orgID, "", "", "", "", labelForNamespace, periodicSchedulePolicyName, periodicSchedulePolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Creation and Validation of empty namespace labelled schedule backup [%s] with label [%s]", scheduleName, labelForNamespace))
			err = NamespaceLabelBackupSuccessCheck(firstScheduleBackupName, ctx, []string{}, labelForNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying that no namespace are included in this schedule backup %s as no namespaces are labelled with %s label", firstScheduleBackupName, labelForNamespace))
			scheduleBackupList = append(scheduleBackupList, firstScheduleBackupName)
			nextScheduleBackupName, err = GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of second namespace labelled schedule backup %s of emtpy namespace", nextScheduleBackupName))
			scheduleBackupList = append(scheduleBackupList, nextScheduleBackupName)
		})

		Step("Restoring first schedule backup of empty namespace with namespace label filter", func() {
			log.InfoD("Restoring first schedule backup of empty namespace with namespace label filter")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			emptyNamespaceRestore = fmt.Sprintf("empty-namespace-restore-%s-%v", firstScheduleBackupName, RandomString(5))
			err = CreateRestore(emptyNamespaceRestore, firstScheduleBackupName, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(strings.Contains(err.Error(), "an empty namespace may not be set during creation"), true, "Verifying restore failure of empty namespace backup")
		})

		Step("Deleting few schedule backup with empty namespaces", func() {
			log.InfoD("Deleting few schedule backup with empty namespaces")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			nextScheduleBackupName, err = GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of third schedule namespace labelled backup %s of emtpy namespace", nextScheduleBackupName))
			scheduleBackupList = append(scheduleBackupList, nextScheduleBackupName)
			for _, backupName := range scheduleBackupList[1:] {
				backupUID, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "Failed while trying to get backup UID for - %s", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting schedule backup:%s with empty namespace", backupName))
			}
		})

		Step("Adding labels created above to the existing namespace and verify these namespace are included as part of next scheduled backup", func() {
			log.InfoD("Adding labels created above to the existing namespace and verify these namespace are included as part of next scheduled backup")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			err = AddLabelsToMultipleNamespaces(nsLabels, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to multiple namespaces [%v]", nsLabels, bkpNamespaces))
			scheduleBackupWithNamespace, err = GetNextScheduleBackupName(scheduleName, time.Duration(schPolicyInterval), ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of next namespace labelled schedule backup %s with namespace included", scheduleBackupWithNamespace))
			err = NamespaceLabelBackupSuccessCheck(scheduleBackupWithNamespace, ctx, bkpNamespaces, labelForNamespace)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying if labelled namespace %s are included in this schedule backup %s ", bkpNamespaces, nextScheduleBackupName))
			err = backupSuccessCheckWithValidation(ctx, scheduleBackupWithNamespace, scheduledAppContexts, orgID, maxWaitPeriodForBackupCompletionInMinutes*time.Minute, 30*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the success of schedule backup named [%s]", scheduleBackupWithNamespace))
		})

		Step("Restoring schedule backup with namespace included", func() {
			log.InfoD("Restoring schedule backup with namespace included")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Unable to fetch px-central-admin ctx")
			restoreWithNamespaces = fmt.Sprintf("restore-%s-%v-with-namespaces", firstScheduleBackupName, RandomString(5))
			err = CreateRestore(restoreWithNamespaces, scheduleBackupWithNamespace, nil, destinationClusterName, orgID, ctx, nil)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restore %s with namespaces included", restoreWithNamespaces))
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.Infof("Deleting the deployed applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Deleting the restores taken")
		err = DeleteRestore(restoreWithNamespaces, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting restore %s", restoreWithNamespaces))
		err = DeleteSchedule(scheduleName, SourceClusterName, orgID, ctx)
		dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup schedule - %s", scheduleName))
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		CleanupCloudSettingsAndClusters(backupLocationMap, "", "", ctx)
	})
})

package tests

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/backup/portworx"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
	"golang.org/x/sync/errgroup"
)

// DeleteSameNameObjectsByMultipleUsersFromAdmin delete backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin
var _ = Describe("{DeleteSameNameObjectsByMultipleUsersFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87563

	var (
		scheduledAppContexts                           = make([]*scheduler.Context, 0)
		appNamespaces                                  = make([]string, 0)
		infraAdminUsers                                = make([]string, 0)
		providers                                      = getProviders()
		userCloudCredentialMap                         = make(map[string]map[string]string)
		userBackupLocationMap                          = make(map[string]map[string]string)
		userClusterMap                                 = make(map[string]map[string]string)
		userSchedulePolicyInterval                     = int64(15)
		userSchedulePolicyMap                          = make(map[string]map[string]string)
		userBackupMap                                  = make(map[string]map[string]string)
		userScheduleNameMap                            = make(map[string]string)
		userRestoreMap                                 = make(map[string]map[string]string)
		numberOfUsers                                  = 3
		numberOfBackups                                = 1
		randomSuffix                                   = RandomString(4)
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
		controlChannel             chan string
		errorGroup                 *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteSameNameObjectsByMultipleUsersFromAdmin", "Delete backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin", nil, 87563, KPhalgun, Q3FY24)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups, backup schedules, restore and cluster objects created by multiple user with same name from the admin", func() {
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})
		Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
			for _, user := range createUsers(numberOfUsers) {
				err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
				log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
				infraAdminUsers = append(infraAdminUsers, user)
			}
		})
		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, provider := range providers {
					userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", randomSuffix)
					userCloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
					userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
					userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%v", randomSuffix)
					userBackupLocationUID := uuid.New()
					err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
					log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
					userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
				}
			})
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userBackupMap[user] = make(map[string]string)
				createBackup := func(backupName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
					for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
						err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
						break
					}
					mu.Lock()
					defer mu.Unlock()
					userBackupMap[user][backupName] = namespace
				}
				for _, namespace := range appNamespaces {
					for i := 0; i < numberOfBackups; i++ {
						backupName := fmt.Sprintf("%s-%s-%d-%v", BackupNamePrefix, namespace, i, randomSuffix)
						wg.Add(1)
						go createBackup(backupName, namespace)
					}
				}
				wg.Wait()
				log.Infof("The list of user backups taken are: %v", userBackupMap)
			})
			Step(fmt.Sprintf("Create schedule policy from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating schedule policy from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userSchedulePolicyName := fmt.Sprintf("%s-%v", "periodic", randomSuffix)
				userSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, userSchedulePolicyInterval, 5)
				userSchedulePolicyCreateRequest := &api.SchedulePolicyCreateRequest{
					CreateMetadata: &api.CreateMetadata{
						Name:  userSchedulePolicyName,
						OrgId: orgID,
					},
					SchedulePolicy: userSchedulePolicyInfo,
				}
				_, err = Inst().Backup.CreateSchedulePolicy(nonAdminCtx, userSchedulePolicyCreateRequest)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation schedule policy %s", userSchedulePolicyName))
				userSchedulePolicyUID, err := Inst().Backup.GetSchedulePolicyUid(orgID, nonAdminCtx, userSchedulePolicyName)
				log.FailOnError(err, "failed to fetch schedule policy uid %s of user %s", userSchedulePolicyName, user)
				userSchedulePolicyMap[user] = map[string]string{userSchedulePolicyUID: userSchedulePolicyName}
			})
			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", randomSuffix)
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						_, err = CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContexts, make(map[string]string), orgID, "", "", "", "", schedulePolicyName, schedulePolicyUID)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", schedulePolicyName))
						break
					}
					break
				}
				userScheduleNameMap[user] = userScheduleName
			})
		}
		err = TaskHandler(infraAdminUsers, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")
		for _, user := range infraAdminUsers {
			Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userRestoreMap[user] = make(map[string]string, 0)
				createRestore := func(backupName string, restoreName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					customNamespace := "custom-" + namespace + randomSuffix
					namespaceMapping := map[string]string{namespace: customNamespace}
					err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
					mu.Lock()
					defer mu.Unlock()
					userRestoreMap[user][restoreUid] = restoreName
				}
				for backupName, namespace := range userBackupMap[user] {
					wg.Add(1)
					restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
					go createRestore(backupName, restoreName, namespace)
				}
				wg.Wait()
				log.Infof("The list of user restores taken are: %v", userRestoreMap)
			})
			Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the admin", userOwnerID)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
		}
		cleanupUserObjectsFromAdmin := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Delete user %s schedule backups, backup schedule and schedule policy from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s schedule backups, backup schedule and schedule policy from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				allScheduleBackupNames, err := Inst().Backup.GetAllScheduleBackupNames(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to get all schedule backup names with schedule name %s of the user %s", userScheduleNameMap[user], user)
				for i := len(allScheduleBackupNames) - 1; i >= 0; i-- {
					backupName := allScheduleBackupNames[i]
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, ctx)
					log.FailOnError(err, "failed to delete schedule backup %s of the user %s", backupName, user)
				}
				scheduleUid, err := Inst().Backup.GetBackupScheduleUID(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to fetch backup schedule %s uid of the user %s", userScheduleNameMap[user], user)
				err = DeleteScheduleWithUID(userScheduleNameMap[user], scheduleUid, orgID, ctx)
				log.FailOnError(err, "failed to delete schedule %s of the user %s", userScheduleNameMap[user], user)
			})
			Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for backupName := range userBackupMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, ctx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
				}
			})
			Step(fmt.Sprintf("Wait for the backups and backup schedule to be deleted"), func() {
				log.InfoD("Waiting for the backups and backup schedule to be deleted")
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				clusterInspectReq := &api.ClusterInspectRequest{
					OrgId:          orgID,
					Name:           SourceClusterName,
					Uid:            userClusterMap[user][SourceClusterName],
					IncludeSecrets: true,
				}
				clusterResp, err := Inst().Backup.InspectCluster(nonAdminCtx, clusterInspectReq)
				log.FailOnError(err, "failed to inspect cluster %s", SourceClusterName)
				var wg sync.WaitGroup
				namespace := "*"
				wg.Add(1)
				go func() {
					defer GinkgoRecover()
					defer wg.Done()
					err = Inst().Backup.WaitForBackupScheduleDeletion(
						nonAdminCtx,
						userScheduleNameMap[user],
						namespace,
						orgID,
						clusterResp.GetCluster(),
						backupLocationDeleteTimeout,
						backupLocationDeleteRetryTime,
					)
					log.FailOnError(err, "failed while waiting for backup schedule %s to be deleted for the user %s", userScheduleNameMap[user], user)
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						schedulePolicyDeleteRequest := &api.SchedulePolicyDeleteRequest{
							Name:  schedulePolicyName,
							Uid:   schedulePolicyUID,
							OrgId: orgID,
						}
						_, err = Inst().Backup.DeleteSchedulePolicy(ctx, schedulePolicyDeleteRequest)
						log.FailOnError(err, "failed to delete schedule policy %s of the user %s", schedulePolicyName, user)
						break
					}
				}()
				for backupName := range userBackupMap[user] {
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						err = Inst().Backup.WaitForBackupDeletion(nonAdminCtx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
						log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
					}(backupName)
				}
				wg.Wait()
			})
			Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
				for restoreUid, restoreName := range userRestoreMap[user] {
					err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, ctx)
					log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
				}
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the admin", user))
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, ctx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
				}
			})
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjectsFromAdmin, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjects, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin deletes user backups and restores of the deleted and inactive cluster from the admin
var _ = Describe("{DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87569

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		infraAdminUsers                            = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		userRestoreMap                             = make(map[string]map[string]string)
		numberOfUsers                              = 1
		numberOfBackups                            = 1
		invalidKubeconfig                          = "\"\""
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		controlChannel         chan string
		errorGroup             *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteUserBackupsAndRestoresOfDeletedAndInActiveClusterFromAdmin", "Delete user backups and restores of the deleted and inactive cluster from the admin", nil, 87569, KPhalgun, Q3FY24)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes user backups and restores of the deleted and inactive cluster from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})
		for i := 0; i < 2; i++ {
			Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
				log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
				for _, user := range createUsers(numberOfUsers) {
					err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
					log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
					infraAdminUsers = append(infraAdminUsers, user)
				}
			})
			createObjectsFromUser := func(user string) {
				Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					for _, provider := range providers {
						userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%s-%s", user, RandomString(5))
						userCloudCredentialUID := uuid.New()
						err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
						log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
						userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
						userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%s-%s", user, RandomString(5))
						userBackupLocationUID := uuid.New()
						err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
						log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
						userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
					}
				})
				Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
					log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
					clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
					dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
					userClusterMap[user] = make(map[string]string)
					for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
						userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
						userClusterMap[user][clusterName] = userClusterUID
					}
				})
				Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userBackupMap[user] = make(map[string]string)
					createBackup := func(backupName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
						for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
							err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
							break
						}
						mu.Lock()
						defer mu.Unlock()
						userBackupMap[user][backupName] = namespace
					}
					for _, namespace := range appNamespaces {
						for i := 0; i < numberOfBackups; i++ {
							backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, user, RandomString(5))
							wg.Add(1)
							go createBackup(backupName, namespace)
						}
					}
					wg.Wait()
					log.Infof("The list of user backups taken are: %v", userBackupMap)
				})
				Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
					for backupName := range userBackupMap[user] {
						if !IsPresent(backupNamesByOwnerID, backupName) {
							err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
			}
			err := TaskHandler([]string{infraAdminUsers[i]}, createObjectsFromUser, Parallel)
			log.FailOnError(err, "failed to create objects from user")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, user := range []string{infraAdminUsers[i]} {
				Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
					log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					var wg sync.WaitGroup
					var mu sync.RWMutex
					userRestoreMap[user] = make(map[string]string, 0)
					createRestore := func(backupName string, restoreName string, namespace string) {
						defer GinkgoRecover()
						defer wg.Done()
						customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
						namespaceMapping := map[string]string{namespace: customNamespace}
						err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
						restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
						log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
						mu.Lock()
						defer mu.Unlock()
						userRestoreMap[user][restoreUid] = restoreName
					}
					for backupName, namespace := range userBackupMap[user] {
						wg.Add(1)
						restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
						go createRestore(backupName, restoreName, namespace)
					}
					wg.Wait()
					log.Infof("The list of user restores taken are: %v", userRestoreMap)
				})
				Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
					nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
					log.FailOnError(err, "failed to fetch user %s ctx", user)
					userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
					log.FailOnError(err, "failed to fetch user owner id %s", user)
					ctx, err := backup.GetAdminCtxFromSecret()
					log.FailOnError(err, "Fetching px-central-admin ctx")
					restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
					log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
					for _, restoreName := range userRestoreMap[user] {
						if !IsPresent(restoreNamesByOwnerID, restoreName) {
							err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
							log.FailOnError(fmt.Errorf(""), err.Error())
						}
					}
				})
				if i == 0 {
					Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
						log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, nonAdminCtx, false)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
						}
					})
					// In case of CSI, a cluster reference is mandatory to delete a backup. We are creating new clusters
					// to refer them in the delete-backup request, as the associated clusters have been deleted.
					Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
						log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
						log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
						clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
						log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
						dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
						userClusterMap[user] = make(map[string]string)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
							userClusterMap[user][clusterName] = userClusterUID
						}
					})
				} else {
					Step(fmt.Sprintf("Make source and destination cluster inactive from the user %s", user), func() {
						log.InfoD(fmt.Sprintf("Making source and destination cluster inactive from the user %s", user))
						nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
						log.FailOnError(err, "failed to fetch user %s ctx", user)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							clusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
							log.FailOnError(err, "failed to fetch cluster %s uid", clusterName)
							clusterInspectRequest := &api.ClusterInspectRequest{
								Name:           clusterName,
								Uid:            clusterUID,
								OrgId:          orgID,
								IncludeSecrets: true,
							}
							clusterInspectResp, err := Inst().Backup.InspectCluster(nonAdminCtx, clusterInspectRequest)
							log.FailOnError(err, "failed to inspect cluster %s with uid %s", clusterName, clusterUID)
							clusterUpdateRequest := &api.ClusterUpdateRequest{
								CreateMetadata: &api.CreateMetadata{
									Name:  clusterName,
									Uid:   clusterUID,
									OrgId: orgID,
								},
								Kubeconfig:            invalidKubeconfig,
								CloudCredential:       clusterInspectResp.GetCluster().GetCloudCredential(),
								CloudCredentialRef:    clusterInspectResp.GetCluster().GetCloudCredentialRef(),
								PlatformCredentialRef: clusterInspectResp.GetCluster().GetPlatformCredentialRef(),
							}
							_, err = Inst().Backup.UpdateCluster(nonAdminCtx, clusterUpdateRequest)
							if err != nil {
								clusterStatus, statusError := Inst().Backup.GetClusterStatus(orgID, clusterName, nonAdminCtx)
								log.FailOnError(statusError, "failed to get cluster status %s", clusterName)
								if clusterStatus != api.ClusterInfo_StatusInfo_Failed {
									log.FailOnError(err, "failed to make cluster %s inactive. Expected status %v but got %v", clusterName, api.ClusterInfo_StatusInfo_Failed, clusterStatus)
								}
							} else {
								err = fmt.Errorf("failed to make cluster %s inactive. Expected error not be nil", clusterName)
								log.FailOnError(fmt.Errorf(""), err.Error())
							}
						}
					})
					// In case of CSI, a cluster reference is mandatory to delete a backup. We are creating new clusters
					// to refer them in the delete-backup request, as the associated clusters have been inactive.
					Step("Create source and destination cluster from the admin", func() {
						log.InfoD("Creating source and destination cluster from the admin")
						err = CreateApplicationClusters(orgID, "", "", ctx)
						log.FailOnError(err, "failed create source and destination cluster from the admin")
						clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
						log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
						dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
						userClusterMap[user] = make(map[string]string)
						for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
							userClusterUID, err := Inst().Backup.GetClusterUID(ctx, orgID, clusterName)
							dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
							userClusterMap[user][clusterName] = userClusterUID
						}
					})
				}
			}
			cleanupUserObjectsFromAdmin := func(user string) {
				defer GinkgoRecover()
				Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
					for backupName := range userBackupMap[user] {
						backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
						log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
						_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, ctx)
						log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
						err = Inst().Backup.WaitForBackupDeletion(ctx, backupName, orgID, backupDeleteTimeout, backupDeleteRetryTime)
						log.FailOnError(err, fmt.Sprintf("failed waiting for user %s backup %s deletion", user, backupName))
					}
				})
				Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
					for restoreUid, restoreName := range userRestoreMap[user] {
						err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, ctx)
						log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
					}
				})
			}
			err = TaskHandler([]string{infraAdminUsers[i]}, cleanupUserObjectsFromAdmin, Parallel)
			log.FailOnError(err, "failed to cleanup user objects from admin")
			for _, user := range []string{infraAdminUsers[i]} {
				Step(fmt.Sprintf("Delete user %s source and destination cluster", user), func() {
					log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster", user))
					for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
						err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, ctx, false)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
					}
				})
			}
		}
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjects, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteObjectsByMultipleUsersFromNewAdmin delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin
var _ = Describe("{DeleteObjectsByMultipleUsersFromNewAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87567

	var (
		scheduledAppContexts       = make([]*scheduler.Context, 0)
		appNamespaces              = make([]string, 0)
		infraAdminUsers            = make([]string, 0)
		providers                  = getProviders()
		userCloudCredentialMap     = make(map[string]map[string]string)
		userBackupLocationMap      = make(map[string]map[string]string)
		userClusterMap             = make(map[string]map[string]string)
		userSchedulePolicyInterval = int64(15)
		userSchedulePolicyMap      = make(map[string]map[string]string)
		userBackupMap              = make(map[string]map[string]string)
		userScheduleNameMap        = make(map[string]string)
		userRestoreMap             = make(map[string]map[string]string)
		numberOfUsers              = 2
		numberOfBackups            = 1
		newAdmin                   string
		adminGroup                                     = "px-admin-group"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
		controlChannel             chan string
		errorGroup                 *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteObjectsByMultipleUsersFromNewAdmin", "Delete backups, backup schedules, restore and cluster objects created by multiple user from the new admin", nil, 87567, KPhalgun, Q3FY24)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups, backup schedules, restore and cluster objects created by multiple user from the new admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})
		Step(fmt.Sprintf("Create %d users with %s role", numberOfUsers, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", numberOfUsers, infraAdminRole))
			for _, user := range createUsers(numberOfUsers) {
				err := backup.AddRoleToUser(user, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user))
				log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user)
				infraAdminUsers = append(infraAdminUsers, user)
			}
		})
		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, provider := range providers {
					userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%s-%s", user, RandomString(5))
					userCloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
					userCloudCredentialMap[user] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
					userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%s-%s", user, RandomString(5))
					userBackupLocationUID := uuid.New()
					err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
					log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
					userBackupLocationMap[user] = map[string]string{userBackupLocationUID: userBackupLocationName}
				}
			})
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userBackupMap[user] = make(map[string]string)
				createBackup := func(backupName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
					for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
						err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user][SourceClusterName], "", "", "", "")
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
						break
					}
					mu.Lock()
					defer mu.Unlock()
					userBackupMap[user][backupName] = namespace
				}
				for _, namespace := range appNamespaces {
					for i := 0; i < numberOfBackups; i++ {
						backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, user, RandomString(5))
						wg.Add(1)
						go createBackup(backupName, namespace)
					}
				}
				wg.Wait()
				log.Infof("The list of user backups taken are: %v", userBackupMap)
			})
			Step(fmt.Sprintf("Create schedule policy from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating schedule policy from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userSchedulePolicyName := fmt.Sprintf("%s-%s-%s", "periodic", user, RandomString(5))
				userSchedulePolicyInfo := Inst().Backup.CreateIntervalSchedulePolicy(5, userSchedulePolicyInterval, 5)
				userSchedulePolicyCreateRequest := &api.SchedulePolicyCreateRequest{
					CreateMetadata: &api.CreateMetadata{
						Name:  userSchedulePolicyName,
						OrgId: orgID,
					},
					SchedulePolicy: userSchedulePolicyInfo,
				}
				_, err = Inst().Backup.CreateSchedulePolicy(nonAdminCtx, userSchedulePolicyCreateRequest)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation schedule policy %s", userSchedulePolicyName))
				userSchedulePolicyUID, err := Inst().Backup.GetSchedulePolicyUid(orgID, nonAdminCtx, userSchedulePolicyName)
				log.FailOnError(err, "failed to fetch schedule policy uid %s of user %s", userSchedulePolicyName, user)
				userSchedulePolicyMap[user] = map[string]string{userSchedulePolicyUID: userSchedulePolicyName}
			})
			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%s-%s", user, RandomString(5))
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user] {
					for schedulePolicyUID, schedulePolicyName := range userSchedulePolicyMap[user] {
						_, err = CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationName, backupLocationUID, scheduledAppContexts, make(map[string]string), orgID, "", "", "", "", schedulePolicyName, schedulePolicyUID)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", schedulePolicyName))
						err = suspendBackupSchedule(userScheduleName, schedulePolicyName, orgID, nonAdminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", schedulePolicyName, user))
						break
					}
					break
				}
				userScheduleNameMap[user] = userScheduleName
			})
		}
		err := TaskHandler(infraAdminUsers, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")
		for _, user := range infraAdminUsers {
			Step(fmt.Sprintf("Take restore of backups from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking restore of backups from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				var wg sync.WaitGroup
				var mu sync.RWMutex
				userRestoreMap[user] = make(map[string]string, 0)
				createRestore := func(backupName string, restoreName string, namespace string) {
					defer GinkgoRecover()
					defer wg.Done()
					customNamespace := fmt.Sprintf("custom-%s-%v", namespace, RandomString(4))
					namespaceMapping := map[string]string{namespace: customNamespace}
					err = CreateRestoreWithValidation(nonAdminCtx, restoreName, backupName, namespaceMapping, make(map[string]string), destinationClusterName, orgID, scheduledAppContexts)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					restoreUid, err := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(err, "failed to fetch restore %s uid of the user %s", restoreName, user)
					mu.Lock()
					defer mu.Unlock()
					userRestoreMap[user][restoreUid] = restoreName
				}
				for backupName, namespace := range userBackupMap[user] {
					wg.Add(1)
					restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
					go createRestore(backupName, restoreName, namespace)
				}
				wg.Wait()
				log.Infof("The list of user restores taken are: %v", userRestoreMap)
			})
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			Step(fmt.Sprintf("Verify backups of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the admin", userOwnerID)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the admin", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
		}
		Step(fmt.Sprintf("Add new user to %s group", adminGroup), func() {
			log.InfoD(fmt.Sprintf("Adding new user to %s group", adminGroup))
			for _, user := range createUsers(1) {
				err := backup.AddGroupToUser(user, adminGroup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying addition of user %s to the group %s", user, adminGroup))
				newAdmin = user
			}
		})
		newAdminCtx, err := backup.GetNonAdminCtx(newAdmin, commonPassword)
		log.FailOnError(err, "Fetching new admin %s ctx", newAdmin)
		cleanupUserObjectsFromAdmin := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Verify backups of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backups of the user %s from new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for backupName := range userBackupMap[user] {
					if !IsPresent(backupNamesByOwnerID, backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify backup schedules of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying backup schedules of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				backupScheduleNamesByOwnerID, err := GetAllBackupScheduleNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch backup schedule names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, backupScheduleName := range userScheduleNameMap {
					if !IsPresent(backupScheduleNamesByOwnerID, backupScheduleName) {
						err := fmt.Errorf("backup schedule %s is not listed in backup schedule names %s", backupScheduleName, backupScheduleNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Verify restores of the user %s from the new admin %s", user, newAdmin), func() {
				log.InfoD(fmt.Sprintf("Verifying restores of the user %s from the new admin %s", user, newAdmin))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
				log.FailOnError(err, "failed to fetch user owner id %s", user)
				restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, newAdminCtx)
				log.FailOnError(err, "failed to fetch restore names with owner id %s from the new admin %s", userOwnerID, newAdmin)
				for _, restoreName := range userRestoreMap[user] {
					if !IsPresent(restoreNamesByOwnerID, restoreName) {
						err := fmt.Errorf("restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			})
			Step(fmt.Sprintf("Delete user %s schedule backups, backup schedule and schedule policy from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s schedule backups, backup schedule and schedule policy from the admin", user))
				var wg sync.WaitGroup
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				allScheduleBackupNames, err := Inst().Backup.GetAllScheduleBackupNames(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to get all schedule backup names with schedule name %s of the user %s", userScheduleNameMap[user], user)
				for i := len(allScheduleBackupNames) - 1; i >= 0; i-- {
					backupName := allScheduleBackupNames[i]
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
						log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
						_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, newAdminCtx)
						log.FailOnError(err, "failed to delete schedule backup %s of the user %s", backupName, user)
					}(backupName)

				}
				wg.Wait()
				scheduleUid, err := Inst().Backup.GetBackupScheduleUID(nonAdminCtx, userScheduleNameMap[user], orgID)
				log.FailOnError(err, "failed to fetch backup schedule %s uid of the user %s", userScheduleNameMap[user], user)
				err = DeleteScheduleWithUIDAndWait(userScheduleNameMap[user], scheduleUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, newAdminCtx)
				log.FailOnError(err, "failed to delete schedule %s of the user %s", userScheduleNameMap[user], user)
			})
			Step(fmt.Sprintf("Delete user %s backups from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user))
				var wg sync.WaitGroup
				for backupName := range userBackupMap[user] {
					wg.Add(1)
					go func(backupName string) {
						defer GinkgoRecover()
						defer wg.Done()
						backupUid, err := Inst().Backup.GetBackupUID(newAdminCtx, backupName, orgID)
						log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
						_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user][SourceClusterName], orgID, newAdminCtx)
						log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
						err = DeleteBackupAndWait(backupName, newAdminCtx)
						log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
					}(backupName)
				}
				wg.Wait()
			})
			Step(fmt.Sprintf("Delete user %s restores from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s restores from the admin", user))
				for restoreUid, restoreName := range userRestoreMap[user] {
					err = DeleteRestoreWithUID(restoreName, restoreUid, orgID, newAdminCtx)
					log.FailOnError(err, "failed to delete restore %s of the user %s", restoreName, user)
				}
			})

			Step(fmt.Sprintf("Delete user %s source and destination cluster from the admin", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the admin", user))
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteClusterWithUID(clusterName, userClusterMap[user][clusterName], orgID, newAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
				}
			})
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjectsFromAdmin, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		cleanupUserObjects := func(user string) {
			nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user)
			for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user] {
				CleanupCloudSettingsAndClusters(userBackupLocationMap[user], cloudCredentialName, cloudCredentialUID, nonAdminCtx)
				break
			}
			err = backup.DeleteUser(user)
			log.FailOnError(err, "failed to delete user %s", user)
		}
		err = TaskHandler(infraAdminUsers, cleanupUserObjects, Sequential)
		log.FailOnError(err, "failed to cleanup user objects from user")
	})
})

// DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin deletes failed and in-progress backups and restores of user from the admin
var _ = Describe("{DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87564

	var (
		scheduledAppContexts                           = make([]*scheduler.Context, 0)
		appNamespaces                                  = make([]string, 0)
		userCloudCredentialMap                         = make(map[string]string)
		userBackupLocationMap                          = make(map[string]string)
		providers                                      = getProviders()
		userInProgressBackupNames                      = make([]string, 0)
		userFailedBackupNames                          = make([]string, 0)
		userSuccessfulBackupMap                        = make(map[string]string)
		userInProgressRestoreNames                     = make([]string, 0)
		userFailedRestoreNames                         = make([]string, 0)
		deletedUserRestoreMap                          = make(map[string]bool)
		numberOfBackups                                = 1
		invalidNamespace                               = "-"
		infraAdminRole             backup.PxBackupRole = backup.InfrastructureOwner
		userSourceClusterUID       string
		infraAdminUser             string
		controlChannel             chan string
		errorGroup                 *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteFailedInProgressBackupAndRestoreOfUserFromAdmin", "Delete failed and in-progress backups and restores of user from the admin side", nil, 87564, KPhalgun, Q3FY24)
		log.InfoD("Scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Delete failed and in-progress backups and restores of user from the admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})
		Step(fmt.Sprintf("Create user with %s role", infraAdminRole), func() {
			infraAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(infraAdminUser, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, infraAdminUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
			log.Infof("username %s common password %s", infraAdminUser, commonPassword)

		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%s-%s", infraAdminUser, RandomString(5))
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[userCloudCredentialUID] = userCloudCredentialName
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%s-%s", infraAdminUser, RandomString(5))
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[userBackupLocationUID] = userBackupLocationName
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", infraAdminUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userSourceClusterUID, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})
		Step(fmt.Sprintf("Take in progress backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{namespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, infraAdminUser, RandomString(5))
					wg.Add(1)
					go createBackup(backupName, namespace)
					userInProgressBackupNames = append(userInProgressBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of in progress user backups taken are: %v", userInProgressBackupNames)
		})
		Step(fmt.Sprintf("Verify in progress backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userInProgressBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("in progress backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress backups taken by user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			backupEnumerateRequest := &api.BackupEnumerateRequest{
				OrgId: orgID,
				EnumerateOptions: &api.EnumerateOptions{
					Owners: []string{userOwnerID},
				},
			}
			deletedUserBackupMap := make(map[string]bool)
			deleteInProgressBackup := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateBackup(ctx, backupEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingBackups := false
				for _, backup := range resp.GetBackups() {
					if IsPresent(userInProgressBackupNames, backup.GetName()) {
						actual := backup.GetStatus().GetStatus()
						switch actual {
						case api.BackupInfo_StatusInfo_InProgress:
							backupName := backup.GetName()
							if _, exists := deletedUserBackupMap[backupName]; exists {
								continue
							}
							wg.Add(1)
							go func(backup *api.BackupObject, ctx context.Context) {
								defer GinkgoRecover()
								defer wg.Done()
								_, err := DeleteBackup(backup.GetName(), backup.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(backup, ctx)
							deletedUserBackupMap[backupName] = true
						case api.BackupInfo_StatusInfo_Pending:
							pendingBackups = true
						}
					} else {
						log.Warnf("backup %s with uid %s may not have been created by this testcase", backup.GetName(), backup.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingBackups {
						return "", true, fmt.Errorf("there are pending backups")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressBackup, maxWaitPeriodForBackupJobCancellation*time.Minute, backupJobCancellationRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress backups"))
			dash.VerifyFatal(len(deletedUserBackupMap) > 0, true, "Verifying if there is at least one in progress backup")
		})
		Step(fmt.Sprintf("Take failed backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					_, err = CreateBackupByNamespacesWithoutCheck(backupName, SourceClusterName, backupLocationName, backupLocationUID,
						[]string{invalidNamespace}, map[string]string{}, orgID, userSourceClusterUID, "", "", "", "", nonAdminCtx)
					if err != nil {
						backupUID, UIDError := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
						log.FailOnError(UIDError, "failed to get backup %s uid", backupName)
						backupInspectRequest := &api.BackupInspectRequest{
							Name:  backupName,
							OrgId: orgID,
							Uid:   backupUID,
						}
						resp, inspectError := Inst().Backup.InspectBackup(nonAdminCtx, backupInspectRequest)
						log.FailOnError(inspectError, "failed to inspect backup %s", backupName)
						if resp.GetBackup().GetStatus().GetStatus() != api.BackupInfo_StatusInfo_Failed {
							dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup %s of namespace %s", backupName, namespace))
						}
					}
					break
				}
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, infraAdminUser, RandomString(5))
					wg.Add(1)
					go createBackup(backupName, namespace)
					userFailedBackupNames = append(userFailedBackupNames, backupName)
				}
			}
			wg.Wait()
			log.Infof("The list of failed user backups taken are: %v", userFailedBackupNames)
		})
		Step(fmt.Sprintf("Verify failed backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for _, backupName := range userFailedBackupNames {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("failed backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed backups taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed backups taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, backupName := range userFailedBackupNames {
				backupUID, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
				log.FailOnError(err, "failed to fetch backup %s uid", backupName)
				_, err = DeleteBackup(backupName, backupUID, orgID, ctx)
				log.FailOnError(err, "failed to delete backup %s uid", backupName)
			}
		})
		Step(fmt.Sprintf("Take successful backup of applications from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking successful backup of applications from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userSourceClusterUID, "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userSuccessfulBackupMap[backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, infraAdminUser, RandomString(5))
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of successful user backups taken are: %v", userSuccessfulBackupMap)
		})
		Step(fmt.Sprintf("Verify successful backups of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying successful backups of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userSuccessfulBackupMap {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("successful backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Take in progress restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking in progress restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: fmt.Sprintf("r-%s-%s", namespace, RandomString(5))}
				_, err = CreateRestoreWithoutCheck(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
				mu.Lock()
				defer mu.Unlock()
				userInProgressRestoreNames = append(userInProgressRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of in progress user restores taken are: %v", userInProgressRestoreNames)
		})
		Step(fmt.Sprintf("Verify in progress restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying in progress restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userInProgressRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("in progress restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete in progress restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting in progress restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreEnumerateRequest := &api.RestoreEnumerateRequest{
				OrgId: orgID,
			}
			deleteInProgressRestore := func() (interface{}, bool, error) {
				var wg sync.WaitGroup
				errCh := make(chan error, 1)
				resp, err := Inst().Backup.EnumerateRestore(ctx, restoreEnumerateRequest)
				if err != nil {
					return "", false, err
				}
				pendingRestores := false
				for _, restore := range resp.GetRestores() {
					if IsPresent(userInProgressRestoreNames, restore.GetName()) {
						actual := restore.GetStatus().GetStatus()
						switch actual {
						case api.RestoreInfo_StatusInfo_InProgress:
							restoreName := restore.GetName()
							if _, exists := deletedUserRestoreMap[restoreName]; exists {
								continue
							}
							wg.Add(1)
							go func(restore *api.RestoreObject, ctx context.Context) {
								defer GinkgoRecover()
								defer wg.Done()
								err := DeleteRestoreWithUID(restore.GetName(), restore.GetUid(), orgID, ctx)
								if err != nil {
									select {
									case errCh <- err:
									default:
									}
								}
							}(restore, ctx)
							deletedUserRestoreMap[restoreName] = true
						case api.RestoreInfo_StatusInfo_Pending:
							pendingRestores = true
						}
					} else {
						log.Warnf("restore %s with uid %s may not have been created by this testcase", restore.GetName(), restore.GetOrgId())
					}
				}
				wg.Wait()
				select {
				case err := <-errCh:
					return "", false, err
				default:
					if pendingRestores {
						return "", true, fmt.Errorf("there are pending restores")
					}
					return "", false, nil
				}
			}
			_, err = DoRetryWithTimeoutWithGinkgoRecover(deleteInProgressRestore, maxWaitPeriodForRestoreJobCancellation*time.Minute, restoreJobProgressRetryTime*time.Second)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Attempting to delete in progress restores"))
			dash.VerifyFatal(len(deletedUserRestoreMap) > 0, true, "Verifying if there is at least one in progress restores")
		})
		Step(fmt.Sprintf("Take failed restore of backups from the user %s", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking failed restore of backups from the user %s", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			createRestore := func(backupName string, restoreName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				namespaceMapping := map[string]string{namespace: invalidNamespace}
				backupUID, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
				log.FailOnError(err, "failed to get backup %s uid", backupName)
				err = CreateRestoreWithUID(restoreName, backupName, namespaceMapping, destinationClusterName, orgID, nonAdminCtx, make(map[string]string), backupUID)
				if err != nil {
					restoreUID, UIDError := Inst().Backup.GetRestoreUID(nonAdminCtx, restoreName, orgID)
					log.FailOnError(UIDError, "failed to get restore %s uid", restoreName)
					restoreInspectRequest := &api.RestoreInspectRequest{
						Name:  restoreName,
						OrgId: orgID,
						Uid:   restoreUID,
					}
					resp, inspectError := Inst().Backup.InspectRestore(nonAdminCtx, restoreInspectRequest)
					log.FailOnError(inspectError, "failed to inspect restore %s", backupName)
					if resp.GetRestore().GetStatus().GetStatus() != api.RestoreInfo_StatusInfo_Failed {
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreName, backupName))
					}
				}
				mu.Lock()
				defer mu.Unlock()
				userFailedRestoreNames = append(userFailedRestoreNames, restoreName)
			}
			for backupName, namespace := range userSuccessfulBackupMap {
				wg.Add(1)
				restoreName := fmt.Sprintf("%s-%s", restoreNamePrefix, backupName)
				go createRestore(backupName, restoreName, namespace)
			}
			wg.Wait()
			log.Infof("The list of failed user restores taken are: %v", userFailedRestoreNames)
		})
		Step(fmt.Sprintf("Verify failed restores of the user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verifying failed restores of the user %s from the admin", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", infraAdminUser)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			restoreNamesByOwnerID, err := GetAllRestoreNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch restore names with owner id %s from the admin", userOwnerID)
			for _, restoreName := range userFailedRestoreNames {
				if !IsPresent(restoreNamesByOwnerID, restoreName) {
					err := fmt.Errorf("failed restore %s is not listed in restore names %s", restoreName, restoreNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete failed restores taken by user %s from the admin", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting failed restores taken by user %s from the admin", infraAdminUser))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			for _, restoreName := range userFailedRestoreNames {
				restoreUID, err := Inst().Backup.GetRestoreUID(ctx, restoreName, orgID)
				log.FailOnError(err, "failed to fetch restore %s uid", restoreName)
				err = DeleteRestoreWithUID(restoreName, restoreUID, orgID, ctx)
				log.FailOnError(err, "failed to delete restore %s uid", restoreName)
			}
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
		log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap {
			CleanupCloudSettingsAndClusters(userBackupLocationMap, cloudCredentialName, cloudCredentialUID, nonAdminCtx)
			break
		}
		err = backup.DeleteUser(infraAdminUser)
		log.FailOnError(err, "failed to delete user %s", infraAdminUser)
	})
})

// DeleteSharedBackupOfUserFromAdmin deletes backups shared by the user from the admin
var _ = Describe("{DeleteSharedBackupOfUserFromAdmin}", func() {

	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87562

	var (
		scheduledAppContexts                       = make([]*scheduler.Context, 0)
		appNamespaces                              = make([]string, 0)
		providers                                  = getProviders()
		userCloudCredentialMap                     = make(map[string]map[string]string)
		userBackupLocationMap                      = make(map[string]map[string]string)
		userClusterMap                             = make(map[string]map[string]string)
		userBackupMap                              = make(map[string]map[string]string)
		numberOfBackups                            = 1
		infraAdminRole         backup.PxBackupRole = backup.InfrastructureOwner
		user1                  string
		user2                  string
		user3                  string
		controlChannel         chan string
		errorGroup             *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteSharedBackupOfUserFromAdmin", "Delete backups shared by the user from the admin", nil, 87562, KPhalgun, Q3FY24)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				appNamespaces = append(appNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Scheduled application namespaces: %v", appNamespaces)
	})

	It("Deletes backups shared by the user from the admin", func() {
		Step("Validate applications", func() {
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
			ValidateApplications(scheduledAppContexts)
		})
		Step(fmt.Sprintf("Create %d users with %s role", 3, infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating %d users with %s role", 3, infraAdminRole))
			user1 = createUsers(1)[0]
			err := backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user1))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user1)
			user2 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user2))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user2)
			user3 = createUsers(1)[0]
			err = backup.AddRoleToUser(user1, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, user3))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, user3)
		})
		Step(fmt.Sprintf("Create cloud credential and backup location from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credential and backup location from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for _, provider := range providers {
				userCloudCredentialName := fmt.Sprintf("autogenerated-cred-%s-%s", user1, RandomString(5))
				userCloudCredentialUID := uuid.New()
				err = CreateCloudCredential(provider, userCloudCredentialName, userCloudCredentialUID, orgID, nonAdminCtx)
				log.FailOnError(err, "failed to create cloud credential %s using provider %s for the user", userCloudCredentialName, provider)
				userCloudCredentialMap[user1] = map[string]string{userCloudCredentialUID: userCloudCredentialName}
				userBackupLocationName := fmt.Sprintf("autogenerated-backup-location-%s-%s", user1, RandomString(5))
				userBackupLocationUID := uuid.New()
				err = CreateBackupLocationWithContext(provider, userBackupLocationName, userBackupLocationUID, userCloudCredentialName, userCloudCredentialUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", userBackupLocationName, provider)
				userBackupLocationMap[user1] = map[string]string{userBackupLocationUID: userBackupLocationName}
			}
		})
		Step(fmt.Sprintf("Create source and destination cluster from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", user1)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[user1] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[user1][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the user %s", user1), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			var wg sync.WaitGroup
			var mu sync.RWMutex
			userBackupMap[user1] = make(map[string]string)
			createBackup := func(backupName string, namespace string) {
				defer GinkgoRecover()
				defer wg.Done()
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{namespace})
				for backupLocationUID, backupLocationName := range userBackupLocationMap[user1] {
					err := CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup, make(map[string]string), orgID, userClusterMap[user1][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, namespace))
					break
				}
				mu.Lock()
				defer mu.Unlock()
				userBackupMap[user1][backupName] = namespace
			}
			for _, namespace := range appNamespaces {
				for i := 0; i < numberOfBackups; i++ {
					backupName := fmt.Sprintf("%s-%s-%d-%s-%s", BackupNamePrefix, namespace, i, user1, RandomString(5))
					wg.Add(1)
					go createBackup(backupName, namespace)
				}
			}
			wg.Wait()
			log.Infof("The list of user backups taken are: %v", userBackupMap)
		})
		Step(fmt.Sprintf("Share user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [backup-share] with user %s with ViewOnlyAccess", user1, user2))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			for backupName := range userBackupMap[user1] {
				err := ShareBackup(backupName, nil, []string{user2}, ViewOnlyAccess, nonAdminCtx)
				log.FailOnError(err, "failed to share user %s backup %s [backup-share] with user %s with ViewOnlyAccess", user1, backupName, user2)
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user2), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin2Ctx, err := backup.GetNonAdminCtx(user2, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin2Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user2)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Share user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Sharing user %s backups [cluster-share] with user %s with ViewOnlyAccess", user1, user3))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			err = ClusterUpdateBackupShare(SourceClusterName, nil, []string{user3}, ViewOnlyAccess, true, nonAdminCtx)
			log.FailOnError(err, "failed to share user %s backups %s [cluster-share] with user %s with ViewOnlyAccess", user1, userBackupMap[user1], user3)
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the user %s", user1, user3), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			nonAdmin3Ctx, err := backup.GetNonAdminCtx(user3, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, nonAdmin3Ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the user %s", userOwnerID, user3)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Verify shared backups of the user %s from the admin", user1), func() {
			log.InfoD(fmt.Sprintf("Verifying shared backups of the user %s from the admin", user1))
			nonAdminCtx, err := backup.GetNonAdminCtx(user1, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", user1)
			userOwnerID, err := portworx.GetSubFromCtx(nonAdminCtx)
			log.FailOnError(err, "failed to fetch user owner id %s", user1)
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			backupNamesByOwnerID, err := GetAllBackupNamesByOwnerID(userOwnerID, orgID, ctx)
			log.FailOnError(err, "failed to fetch backup names with owner id %s from the admin", userOwnerID)
			for backupName := range userBackupMap[user1] {
				if !IsPresent(backupNamesByOwnerID, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, backupNamesByOwnerID)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})
		Step(fmt.Sprintf("Delete the owner [%s] of the backups", user1), func() {
			log.InfoD(fmt.Sprintf("Deleting the owner [%s] of the backups", user1))
			err := backup.DeleteUser(user1)
			log.FailOnError(err, "failed to delete user %s", user1)
		})
		Step(fmt.Sprintf("Delete user %s backups from the admin", user1), func() {
			var wg sync.WaitGroup
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-central-admin ctx")
			log.InfoD(fmt.Sprintf("Deleting user %s backups from the admin", user1))
			for backupName := range userBackupMap[user1] {
				wg.Add(1)
				go func(backupName string) {
					defer GinkgoRecover()
					defer wg.Done()
					backupUid, err := Inst().Backup.GetBackupUID(ctx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user1)
					_, err = DeleteBackupWithClusterUID(backupName, backupUid, SourceClusterName, userClusterMap[user1][SourceClusterName], orgID, ctx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user1)
					err = DeleteBackupAndWait(backupName, ctx)
					log.FailOnError(err, "failed while waiting for backup %s to be deleted", backupName)
				}(backupName)
			}
			wg.Wait()
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Destroying the scheduled applications")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		for cloudCredentialUID, cloudCredentialName := range userCloudCredentialMap[user1] {
			CleanupCloudSettingsAndClusters(userBackupLocationMap[user1], cloudCredentialName, cloudCredentialUID, ctx)
			break
		}
		err = backup.DeleteUser(user2)
		log.FailOnError(err, "failed to delete user %s", user2)
		err = backup.DeleteUser(user3)
		log.FailOnError(err, "failed to delete user %s", user3)
	})
})

// DeleteBackupOfUserNonSharedRBAC delete backups created by user from admin with non-shared RBAC resources from  px-admin.
var _ = Describe("{DeleteBackupOfUserNonSharedRBAC}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87561
	var (
		userNames                      []string
		periodicSchedulePolicyName     string
		periodicSchedulePolicyUid      string
		periodicSchedulePolicyInterval int64
		scheduledAppContexts           []*scheduler.Context
		backupLocationUID              string
		bkpNamespaces                  []string
		adminCredName                  string
		adminCloudCredUID              string
		infraUserCredName              string
		infraUserCloudCredUID          string
		srcClusterUid                  string
		backupLocationName             string
		preRuleName                    string
		postRuleName                   string
		preRuleUid                     string
		postRuleUid                    string
		backupName                     string
		backupLocationMap              map[string]string
		nsLabels                       map[string]string
		namespaceLabel                 string
		appAdminUserNames              []string
		infraAdminUserNames            []string
		mutex                          sync.Mutex
		wg                             sync.WaitGroup
		controlChannel                 chan string
		errorGroup                     *errgroup.Group
	)
	bkpNamespaces = make([]string, 0)
	userNames = make([]string, 0)
	numOfNS := 2
	numOfUsers := 4
	timeBetweenConsecutiveBackups := 10 * time.Second
	backupLocationMap = make(map[string]string)
	userIdMap := make(map[string]string)
	userCredNameMap := make(map[string]string)
	userCloudCredUIDMap := make(map[string]string)
	namespaceMapping := make(map[string]string)
	storageClassMapping := make(map[string]string)
	clusterUidMap := make(map[string]map[string]string)
	backupLocationNameMap := make(map[string]string)
	backupLocationUidMap := make(map[string]string)
	periodicSchedulePolicyNameMap := make(map[string]string)
	periodicSchedulePolicyUidMap := make(map[string]string)
	preRuleNameMap := make(map[string]string)
	preRuleUidMap := make(map[string]string)
	postRuleNameMap := make(map[string]string)
	postRuleUidMap := make(map[string]string)
	singleNamespaceBackupsMap := make(map[string][]string)
	multipleNamespaceBackupsMap := make(map[string][]string)
	multipleNamespaceLabelBackupsMap := make(map[string][]string)
	backupNameMap := make(map[string]string)
	scheduleNameMap := make(map[string]string)
	restoreNameMap := make(map[string]string)
	userBackupNamesMap := make(map[string][]string)
	userBackupNamesMapFromAdmin := make(map[string][]string)
	userBackupSchedulesMap := make(map[string][]string)
	userRestoresMap := make(map[string][]string)
	backupDriver := Inst().Backup

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteBackupOfUserNonSharedRBAC",
			"Delete backups,restores,schedules,clusters created by non-admin user with non-shared RBAC resources from px-admin ", nil, 87561, Ak, Q3FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < numOfNS; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Delete backups by user from admin with non-shared RBAC objects", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})

		Step("Generate and add labels to namespaces", func() {
			log.InfoD("Generate and add labels to namespaces")
			nsLabels = GenerateRandomLabels(1)
			err := AddLabelsToMultipleNamespaces(nsLabels, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%s]", nsLabels, bkpNamespaces))
		})

		Step("Generating namespace label string from label map", func() {
			log.InfoD("Generating namespace label string from label map")
			namespaceLabel = MapToKeyValueString(nsLabels)
			log.Infof("Generated labels [%s]", namespaceLabel)
		})

		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [2]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner}
			for i := 1; i <= numOfUsers/2; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					if role == backup.ApplicationOwner {
						appAdminUserNames = append(appAdminUserNames, userName)
					} else {
						infraAdminUserNames = append(infraAdminUserNames, userName)
					}
					userNames = append(userNames, userName)
					userUID, err := backup.FetchIDOfUser(userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
					userIdMap[userName] = userUID
				}
			}
		})

		Step(fmt.Sprintf("Adding cloud account and backup location from px-admin "), func() {
			log.InfoD(fmt.Sprintf("Adding cloud account and backup location from px-admin"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, provider := range providers {
				adminCloudCredUID = uuid.New()
				adminCredName = fmt.Sprintf("%s-cred-%s", provider, RandomString(5))
				err := CreateCloudCredential(provider, adminCredName, adminCloudCredUID, orgID, adminCtx)
				log.FailOnError(err, "Failed to create cloud account for backup location from px-admin user  - %s", err)
				if provider != drivers.ProviderNfs {
					log.InfoD(fmt.Sprintf("Update ownership for cloud account from px-admin to users with role app.admin"))
					log.Infof("Update CloudAccount - %s ownership for users - [%v]", adminCredName, appAdminUserNames)
					err = AddCloudCredentialOwnership(adminCredName, adminCloudCredUID, appAdminUserNames, nil, Read, Invalid, adminCtx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of owbership for CloudCredential- %s", adminCredName))
					for _, appAdminUserName := range appAdminUserNames {
						userCredNameMap[appAdminUserName] = adminCredName
						userCloudCredUIDMap[appAdminUserName] = adminCloudCredUID
					}
				}
			}
		})

		for _, infraAdminUserName := range infraAdminUserNames {
			Step(fmt.Sprintf("Adding cloud account for backup location for infra-admin user [%s] from px-admin ", infraAdminUserName), func() {
				log.InfoD(fmt.Sprintf("Adding cloud account for backup location for infra-admin user"))
				nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
				for _, provider := range providers {
					infraUserCloudCredUID = uuid.New()
					infraUserCredName = fmt.Sprintf("%s-cred-%s", provider, RandomString(5))
					err = CreateCloudCredential(provider, infraUserCredName, infraUserCloudCredUID, orgID, nonAdminCtx)
					log.FailOnError(err, "Failed to create cloud account for backup location from px-admin user  - %s", err)
					userCredNameMap[infraAdminUserName] = infraUserCredName
					userCloudCredUIDMap[infraAdminUserName] = infraUserCloudCredUID
				}
			})
		}

		Step(fmt.Sprintf("Create backup location for non-admin user using the cloud cred "), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Create backup location for non-admin user [%s] using the cloud cred created ", nonAdminUserName))
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin user ctx")
				for _, provider := range providers {
					backupLocationUID = uuid.New()
					backupLocationName = fmt.Sprintf("%s-location-%s", provider, RandomString(5))
					backupLocationNameMap[nonAdminUserName] = backupLocationName
					backupLocationUidMap[nonAdminUserName] = backupLocationUID
					userBucketName := fmt.Sprintf("%s-%s", getGlobalBucketName(provider), RandomString(5))
					err = CreateBackupLocationWithContext(provider, backupLocationNameMap[nonAdminUserName], backupLocationUidMap[nonAdminUserName], userCredNameMap[nonAdminUserName], userCloudCredUIDMap[nonAdminUserName], userBucketName, orgID, "", nonAdminCtx, true)
					log.FailOnError(err, "Failed to add backup location %s using provider %s for non-admin user %s", backupLocationNameMap[nonAdminUserName], provider, nonAdminUserName)
					backupLocationMap[backupLocationUID] = backupLocationName
				}
			}
		})

		Step(fmt.Sprintf("Create schedule policy from non-admin user"), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Creating a schedule policy from non-admin [%s] user", nonAdminUserName))
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin user ctx")
				periodicSchedulePolicyName = fmt.Sprintf("%s-%s-%s", "periodic", RandomString(5), nonAdminUserName)
				periodicSchedulePolicyUid = uuid.New()
				periodicSchedulePolicyInterval = 15
				periodicSchedulePolicyNameMap[nonAdminUserName] = periodicSchedulePolicyName
				periodicSchedulePolicyUidMap[nonAdminUserName] = periodicSchedulePolicyUid
				err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[nonAdminUserName], periodicSchedulePolicyUidMap[nonAdminUserName], orgID, nonAdminCtx, false, false)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s] for user [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[nonAdminUserName], nonAdminUserName))
			}
		})

		Step(fmt.Sprintf("Create pre and post exec rules for applications from non-admin user "), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Create pre and post exec rules for applications from non-admin user [%s]", nonAdminUserName))
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin user ctx")
				preRuleName, postRuleName, err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from non-admin user [%s]", nonAdminUserName))
				if preRuleName != "" {
					preRuleNameMap[nonAdminUserName] = preRuleName
					preRuleUid, err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, preRuleNameMap[nonAdminUserName])
					log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleNameMap[nonAdminUserName])
					preRuleUidMap[nonAdminUserName] = preRuleUid
					log.Infof("Pre backup rule [%s] uid: [%s]", preRuleNameMap[nonAdminUserName], preRuleUidMap[nonAdminUserName])
				}
				if postRuleName != "" {
					postRuleNameMap[nonAdminUserName] = postRuleName
					postRuleUid, err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, postRuleNameMap[nonAdminUserName])
					log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleNameMap[nonAdminUserName])
					postRuleUidMap[nonAdminUserName] = postRuleUid
					log.Infof("Post backup rule [%s] uid: [%s]", postRuleNameMap[nonAdminUserName], postRuleUidMap[nonAdminUserName])
				}
			}
		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
				destClusterUid, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
				clusterInfo := make(map[string]string)
				clusterInfo[SourceClusterName] = srcClusterUid
				clusterInfo[destinationClusterName] = destClusterUid
				clusterUidMap[nonAdminUserName] = clusterInfo
			}
		})

		Step(fmt.Sprintf("Taking manual backup of applications with and without rules from non-admin user"), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Taking manual backup of applications with and without rules from non-admin user [%s]", nonAdminUserName))
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking manual backup of single namespace as user : %s with-rules", nonAdminUserName)
					backupName = fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					backupNameMap[nonAdminUserName] = backupName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a backup of namespace [%s] with pre and post exec rules", bkpNamespaces[0])
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[nonAdminUserName], SourceClusterName, backupLocationNameMap[nonAdminUserName], backupLocationUidMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, clusterUidMap[nonAdminUserName][SourceClusterName], preRuleNameMap[nonAdminUserName], preRuleUidMap[nonAdminUserName], postRuleNameMap[nonAdminUserName], postRuleUidMap[nonAdminUserName])
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupNameMap[nonAdminUserName]))
					singleNamespaceBackupsMap[nonAdminUserName] = SafeAppend(&mutex, singleNamespaceBackupsMap[nonAdminUserName], backupNameMap[nonAdminUserName]).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], backupNameMap[nonAdminUserName]).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking manual backup of multiple namespace as user : %s without-rules", nonAdminUserName)
					backupName = fmt.Sprintf("%s-manual-multiple-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					backupNameMap[nonAdminUserName] = backupName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a backup of namespaces [%v] without pre and post exec rules", bkpNamespaces)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[nonAdminUserName], SourceClusterName, backupLocationNameMap[nonAdminUserName], backupLocationUidMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, clusterUidMap[nonAdminUserName][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupNameMap[nonAdminUserName]))
					multipleNamespaceBackupsMap[nonAdminUserName] = SafeAppend(&mutex, multipleNamespaceBackupsMap[nonAdminUserName], backupNameMap[nonAdminUserName]).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], backupNameMap[nonAdminUserName]).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()

		})

		Step(fmt.Sprintf("Taking schedule backup of applications as non-admin user with and without rules"), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications with and without rules from non-admin user [%s]", nonAdminUserName))
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking schedule backup of single namespace as user : %s without-rules", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-single-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationNameMap[nonAdminUserName], backupLocationUidMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyNameMap[nonAdminUserName], periodicSchedulePolicyUidMap[nonAdminUserName])
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					singleNamespaceBackupsMap[nonAdminUserName] = SafeAppend(&mutex, singleNamespaceBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], scheduleBackupName).([]string)
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyNameMap[nonAdminUserName], orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Taking namespace label schedule backup of applications with and without rules from non-admin user"), func() {
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Taking namespace label schedule backup of applications with and without rules from non-admin user [%s]", nonAdminUserName))
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking namespace label schedule backup of applications of user : %s ", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-nslabel-%s-with-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a backup of namespaces [%v] with pre and post exec rules", bkpNamespaces)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					scheduleBackupName, err := CreateScheduleBackupWithNamespaceLabelWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationNameMap[nonAdminUserName], backupLocationUidMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, preRuleNameMap[nonAdminUserName], preRuleUidMap[nonAdminUserName], postRuleNameMap[nonAdminUserName], postRuleUidMap[nonAdminUserName], namespaceLabel, periodicSchedulePolicyNameMap[nonAdminUserName], periodicSchedulePolicyUidMap[nonAdminUserName])
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					multipleNamespaceLabelBackupsMap[nonAdminUserName] = SafeAppend(&mutex, multipleNamespaceLabelBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], scheduleBackupName).([]string)
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyNameMap[nonAdminUserName], orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		// single namespace backups restore
		Step("Restore single namespace backups with different configs", func() {
			log.InfoD("Restore single namespace backups with different configs")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				restoreConfigs := []struct {
					namePrefix          string
					namespaceMapping    map[string]string
					storageClassMapping map[string]string
					replacePolicy       ReplacePolicyType
				}{
					{
						"test-restore-single-ns",
						make(map[string]string, 0),
						make(map[string]string, 0),
						ReplacePolicyRetain,
					},
					{
						"test-custom-restore-single-ns",
						map[string]string{bkpNamespaces[0]: "custom-" + bkpNamespaces[0]},
						make(map[string]string, 0),
						ReplacePolicyRetain,
					},
				}
				for _, config := range restoreConfigs {
					restoreName := fmt.Sprintf("%s-%s-%s", nonAdminUserName, config.namePrefix, RandomString(4))
					restoreNameMap[nonAdminUserName] = restoreName
					log.InfoD("Restoring single namespace backup [%s] in cluster [%s] with restore [%s] and namespace mapping %v for user [%s]", singleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, restoreName, config.namespaceMapping, nonAdminUserName)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], singleNamespaceBackupsMap[nonAdminUserName][0], config.namespaceMapping, config.storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of single namespace backup [%s] in cluster [%s] by user [%s]", restoreNameMap[nonAdminUserName], singleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
				}
			}
			wg.Wait()
		})

		// Restore a multiple namespace backup
		Step("Restore a multiple namespace backups", func() {
			log.InfoD("Restore a multiple namespace backups")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				restoreName := fmt.Sprintf("%s-multiple-ns-restore-%s", nonAdminUserName, RandomString(4))
				restoreNameMap[nonAdminUserName] = restoreName
				log.InfoD("Restoring multiple namespace backup [%s] in cluster [%s] with restore name [%s] for user [%s] ", multipleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, restoreNameMap[nonAdminUserName], nonAdminUserName)
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], multipleNamespaceBackupsMap[nonAdminUserName][0], namespaceMapping, storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of multiple namespace schedule backup [%s] in cluster [%s] for user [%s]", restoreNameMap[nonAdminUserName], multipleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
			}
		})

		// Restore a multiple namespace backup
		Step("Restore a namespace label backups", func() {
			log.InfoD("Restore a namespace label backups")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				restoreName := fmt.Sprintf("%s-multiple-ns-label-restore-%s", nonAdminUserName, RandomString(4))
				restoreNameMap[nonAdminUserName] = restoreName
				log.InfoD("Restoring multiple namespace backup [%s] in cluster [%s] with restore name [%s] ", multipleNamespaceLabelBackupsMap[nonAdminUserName][0], destinationClusterName, restoreNameMap[nonAdminUserName])
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], multipleNamespaceLabelBackupsMap[nonAdminUserName][0], namespaceMapping, storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of multiple namespace schedule backup [%s] in cluster [%s] for user [%s]", restoreNameMap[nonAdminUserName], multipleNamespaceLabelBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
			}
		})

		log.InfoD("Deletion of all backup,restore,schedule,cluster of users when user is present in keycloak ")
		Step(fmt.Sprintf("Listing and Deletion of backup of non-admin user from px-admin user"), func() {
			log.InfoD("Listing and Deletion of backup of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:2] {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupNamesByOwnerID(userIdMap[nonAdminUserName], orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupNamesMapFromAdmin[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNamesMapFromAdmin[nonAdminUserName]))
				for _, backupName := range userBackupNamesMap[nonAdminUserName] {
					if !IsPresent(userBackupNamesMapFromAdmin[nonAdminUserName], backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesMapFromAdmin[nonAdminUserName])
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			for _, nonAdminUserName := range userNames[:2] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupNamesMapFromAdmin[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Deletion of backup schedules of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of backup schedules of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:2] {
				log.InfoD(fmt.Sprintf("Verifying listing of backup schedule of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user from px-admin user"))
				userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
				log.Infof(fmt.Sprintf("the list of user [%s ]backup schedules from px-admin user %v", nonAdminUserName, userBackupSchedulesMap[nonAdminUserName]))
			}
			for _, nonAdminUserName := range userNames[:2] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
						backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, adminCtx)
						log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
						err = DeleteScheduleWithUIDAndWait(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Deletion of restores of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of restores of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:2] {
				log.InfoD(fmt.Sprintf("Verifying  listing of restores of non-admin user [%s] from px-admin user", nonAdminUserName))
				userRestores, err := GetAllRestoresForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching restores of user ffrom px-admin user"))
				userRestoresMap[nonAdminUserName] = userRestores
				log.Infof(fmt.Sprintf("the list of user [%s] restores from px-admin user %v", nonAdminUserName, userRestoresMap[nonAdminUserName]))
			}
			for _, nonAdminUserName := range userNames[:2] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, restoreName := range userRestoresMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying  Deletion of restores [%s] of non-admin user [%s] from px-admin user", restoreName, nonAdminUserName))
						restoreUid, _ := Inst().Backup.GetRestoreUID(adminCtx, restoreName, orgID)
						err := DeleteRestoreWithUID(restoreName, restoreUid, orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting restore [%s] of user [%s] from px-admin user", restoreName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Deletion of clusters of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of clusters of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:2] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					err = DeleteClusterWithUID(SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
					err = DeleteClusterWithUID(destinationClusterName, clusterUidMap[nonAdminUserName][destinationClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		log.InfoD("Deletion of all backups,restores,schedules,clusters of users when user is deleted from keycloak ")
		Step(fmt.Sprintf("Verifying deletion of non-admin user from keycloak"), func() {
			for _, nonAdminUserName := range userNames[2:4] {
				log.InfoD(fmt.Sprintf("Verifying deletion of user  [%s] from keycloak", nonAdminUserName))
				log.Infof(fmt.Sprintf("Fetching user [%s] backup schedules and restore before user deletion ", nonAdminUserName))
				userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user from px-admin user"))
				userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
				log.Infof(fmt.Sprintf("the list of user [%s] backup schedules [%s] ", nonAdminUserName, userBackupSchedulesMap[nonAdminUserName]))
				userRestores, err := GetAllRestoresForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching restores of user ffrom px-admin user"))
				userRestoresMap[nonAdminUserName] = userRestores
				log.Infof(fmt.Sprintf("the list of user [%s] restores [%s] ", nonAdminUserName, userRestoresMap[nonAdminUserName]))
				err = backup.DeleteUser(nonAdminUserName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the deletion of the user [%s]", nonAdminUserName))
			}
		})
		Step(fmt.Sprintf("Listing and deletion of backup of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Listing and deletion of backup of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[2:4] {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupNamesByOwnerID(userIdMap[nonAdminUserName], orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupNamesMapFromAdmin[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin  %v", nonAdminUserName, userBackupNamesMapFromAdmin[nonAdminUserName]))
				for _, backupName := range userBackupNamesMap[nonAdminUserName] {
					if !IsPresent(userBackupNamesMapFromAdmin[nonAdminUserName], backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesMapFromAdmin[nonAdminUserName])
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			for _, nonAdminUserName := range userNames[2:4] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupNamesMapFromAdmin[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Verifying  deletion of backup schedule of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of backup schedule of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[2:4] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
						backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, adminCtx)
						log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
						err = DeleteScheduleWithUIDAndWait(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Verifying  deletion of restore of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of restore of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[2:4] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, restoreName := range userRestoresMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying  Deletion of restores [%s] of non-admin user [%s] from px-admin user", restoreName, nonAdminUserName))
						restoreUid, _ := Inst().Backup.GetRestoreUID(adminCtx, restoreName, orgID)
						err := DeleteRestoreWithUID(restoreName, restoreUid, orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting restore [%s] of user [%s] from px-admin user", restoreName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Verifying  deletion of clusters of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of clusters of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[2:4] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					log.InfoD(fmt.Sprintf("Verifying  deletion of clusters of deleted non-admin user [%s] from px-admin user", nonAdminUserName))
					err := DeleteClusterWithUID(SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
					err = DeleteClusterWithUID(destinationClusterName, clusterUidMap[nonAdminUserName][destinationClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err = DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		log.Infof("Deleting backup schedule policy")
		schedulePolicyNames, err := backupDriver.GetAllSchedulePolicies(ctx, orgID)
		for _, schedulePolicyName := range schedulePolicyNames {
			err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{schedulePolicyName})
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policy %s ", []string{schedulePolicyName}))
		}
		ruleNames, err := backupDriver.GetAllRules(ctx, orgID)
		for _, ruleName := range ruleNames {
			err = Inst().Backup.DeleteRuleForBackup(orgID, ruleName)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting  rule %s ", ruleName))
		}
		CleanupCloudSettingsAndClusters(backupLocationMap, adminCredName, adminCloudCredUID, ctx)
	})
})

// DeleteBackupOfUserSharedRBAC delete backups created by non-admin user from px-admin with shared RBAC resources from px-admin.
var _ = Describe("{DeleteBackupOfUserSharedRBAC}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87560
	var (
		periodicSchedulePolicyName       string
		periodicSchedulePolicyUid        string
		scheduledAppContexts             []*scheduler.Context
		backupLocationUID                string
		credName                         string
		cloudCredUID                     string
		srcClusterUid                    string
		backupLocationName               string
		preRuleName                      string
		postRuleName                     string
		preRuleUid                       string
		postRuleUid                      string
		nsLabels                         map[string]string
		periodicSchedulePolicyInterval   int64
		namespaceLabel                   string
		wg                               sync.WaitGroup
		mutex                            sync.Mutex
		bkpNamespaces                    = make([]string, 0)
		userNames                        = make([]string, 0)
		numOfNS                          = 2
		numOfUsers                       = 6
		timeBetweenConsecutiveBackups    = 10 * time.Second
		namespaceMapping                 = make(map[string]string)
		storageClassMapping              = make(map[string]string)
		userIdMap                        = make(map[string]string)
		clusterUidMap                    = make(map[string]map[string]string)
		backupLocationMap                = make(map[string]string)
		singleNamespaceBackupsMap        = make(map[string][]string)
		multipleNamespaceBackupsMap      = make(map[string][]string)
		multipleNamespaceLabelBackupsMap = make(map[string][]string)
		scheduleNameMap                  = make(map[string]string)
		restoreNameMap                   = make(map[string]string)
		userBackupNamesMap               = make(map[string][]string)
		userBackupNamesMapFromAdmin      = make(map[string][]string)
		userBackupSchedulesMap           = make(map[string][]string)
		userRestoresMap                  = make(map[string][]string)
		backupDriver                     = Inst().Backup
		controlChannel                   chan string
		errorGroup                       *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteBackupOfUserSharedRBAC",
			"Delete backups,restores,schedules,clusters created by non-admin user with shared RBAC resources from px-admin", nil, 87560, Ak, Q3FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < numOfNS; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})
	It("Delete backups by user from admin with shared RBAC objects", func() {
		providers := getProviders()
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})
		Step("Generate and add labels to namespaces", func() {
			log.InfoD("Generate and add labels to namespaces")
			nsLabels = GenerateRandomLabels(1)
			err := AddLabelsToMultipleNamespaces(nsLabels, bkpNamespaces)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Adding labels [%v] to namespaces [%s]", nsLabels, bkpNamespaces))
		})
		Step("Generating namespace label string from label map", func() {
			log.InfoD("Generating namespace label string from label map")
			namespaceLabel = MapToKeyValueString(nsLabels)
			log.Infof("Generated labels [%s]", namespaceLabel)
		})
		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for i := 1; i <= numOfUsers/3; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					userNames = append(userNames, userName)
					userUID, err := backup.FetchIDOfUser(userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
					userIdMap[userName] = userUID
				}
			}
		})
		Step(fmt.Sprintf("Adding Credentials and Backup Location from px-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credentials and backup location from px-admin user"))
			for _, provider := range providers {
				ctx, err := backup.GetAdminCtxFromSecret()
				log.FailOnError(err, "Fetching px-admin ctx")
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%s", RandomString(5))
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, ctx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%s", RandomString(5))
				err = CreateBackupLocation(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", true)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})
		Step(fmt.Sprintf("Create schedule policy from px-admin"), func() {
			log.InfoD("Creating a schedule policy from px-admin")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%s", "periodic", RandomString(5))
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval = 15
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, ctx, false, false)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyName))
			periodicSchedulePolicyUid, err = Inst().Backup.GetSchedulePolicyUid(orgID, ctx, periodicSchedulePolicyName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching uid of periodic schedule policy named [%s]", periodicSchedulePolicyName))
		})

		Step(fmt.Sprintf("Create pre and post exec rules for applications from px-admin"), func() {
			log.InfoD("Create pre and post exec rules for applications from px-admin")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			preRuleName, postRuleName, err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from px-admin"))
			if preRuleName != "" {
				preRuleUid, err = Inst().Backup.GetRuleUid(orgID, ctx, preRuleName)
				log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleName)
				log.Infof("Pre backup rule [%s] uid: [%s]", preRuleName, preRuleUid)
			}
			if postRuleName != "" {
				postRuleUid, err = Inst().Backup.GetRuleUid(orgID, ctx, postRuleName)
				log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleName)
				log.Infof("Post backup rule [%s] uid: [%s]", postRuleName, postRuleUid)
			}
		})

		Step("Update ownership for RBAC resource with non-admin users from px-admin", func() {
			log.InfoD("update ownership for RBAC resource with non-admin users from px-admin")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "fetching px-admin ctx")
			log.InfoD("Update BackupLocation - %s ownership for users - [%v]", backupLocationName, userNames)
			err = AddBackupLocationOwnership(backupLocationName, backupLocationUID, userNames, nil, Read, Invalid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of owbership for backuplocation - %s", backupLocationName))

			log.InfoD("Update SchedulePolicy - %s ownership for users - [%v]", periodicSchedulePolicyName, userNames)
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyName, periodicSchedulePolicyUid, userNames, nil, Read, Invalid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of ownership for schedulepolicy - %s", periodicSchedulePolicyName))

			log.InfoD("Update Application Rules ownership for users - [%v]", userNames)
			if preRuleName != "" {
				err = AddRuleOwnership(preRuleName, preRuleUid, userNames, nil, Read, Invalid, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of ownership for pre-rule of application"))
			}
			if postRuleName != "" {
				err = AddRuleOwnership(postRuleName, postRuleUid, userNames, nil, Read, Invalid, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of ownership for post-rule of application"))
			}
		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"), func() {
			log.InfoD("Register source and destination cluster for backup on non-admin user")
			for _, nonAdminUserName := range userNames {
				log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
				destClusterUid, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
				clusterInfo := make(map[string]string)
				clusterInfo[SourceClusterName] = srcClusterUid
				clusterInfo[destinationClusterName] = destClusterUid
				clusterUidMap[nonAdminUserName] = clusterInfo
			}
		})

		Step(fmt.Sprintf("Taking schedule backup of applications as non-admin user with and without rules"), func() {
			log.InfoD("Taking schedule backup of applications as non-admin user with and without rules")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking schedule backup of single namespace as user : %s without-rules", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-single-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
						labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyName, periodicSchedulePolicyUid)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					singleNamespaceBackupsMap[nonAdminUserName] = SafeAppend(&mutex, singleNamespaceBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], scheduleBackupName).([]string)
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyName, orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
				}(nonAdminUserName)
			}
			wg.Wait()

			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking schedule backup of multiple namespace as user : %s with-rules", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-multiple-ns-%s-with-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a schedule backup of namespace [%s] with pre and post exec rules", bkpNamespaces)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
						labelSelectors, orgID, preRuleName, preRuleUid, postRuleName, postRuleUid, periodicSchedulePolicyName, periodicSchedulePolicyUid)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					multipleNamespaceBackupsMap[nonAdminUserName] = SafeAppend(&mutex, multipleNamespaceBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], scheduleBackupName).([]string)
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyName, orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Taking namespace label schedule backup of applications with and without rules from non-admin user"), func() {
			log.InfoD("Taking namespace label schedule backup of applications with and without rules from non-admin user")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking namespace label schedule backup of applications of user : %s ", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-nslabel-%s-with-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a backup of namespaces [%v] with pre and post exec rules", bkpNamespaces)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					scheduleBackupName, err := CreateScheduleBackupWithNamespaceLabelWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
						labelSelectors, orgID, preRuleName, preRuleUid, postRuleName, postRuleUid, namespaceLabel, periodicSchedulePolicyName, periodicSchedulePolicyUid)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					multipleNamespaceLabelBackupsMap[nonAdminUserName] = SafeAppend(&mutex, multipleNamespaceLabelBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
					userBackupNamesMap[nonAdminUserName] = SafeAppend(&mutex, userBackupNamesMap[nonAdminUserName], scheduleBackupName).([]string)
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyName, orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step("Restore single namespace backups with different configs", func() {
			log.InfoD("Restore single namespace backups with different configs")
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
				restoreConfigs := []struct {
					namePrefix          string
					namespaceMapping    map[string]string
					storageClassMapping map[string]string
					replacePolicy       ReplacePolicyType
				}{
					{
						"test-restore-single-ns",
						make(map[string]string, 0),
						make(map[string]string, 0),
						ReplacePolicyRetain,
					},
					{
						"test-custom-restore-single-ns",
						map[string]string{bkpNamespaces[0]: "custom-" + bkpNamespaces[0]},
						make(map[string]string, 0),
						ReplacePolicyRetain,
					},
				}
				for _, config := range restoreConfigs {
					restoreName := fmt.Sprintf("%s-%s-%s", nonAdminUserName, config.namePrefix, RandomString(4))
					restoreNameMap[nonAdminUserName] = restoreName
					log.InfoD("Restoring single namespace backup [%s] in cluster [%s] with restore [%s] and namespace mapping %v for user [%s]", singleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, restoreName, config.namespaceMapping, nonAdminUserName)
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], singleNamespaceBackupsMap[nonAdminUserName][0], config.namespaceMapping, config.storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of single namespace backup [%s] in cluster [%s] by user [%s]", restoreNameMap[nonAdminUserName], singleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
				}
			}
			wg.Wait()
		})
		Step("Restore a multiple namespace backups", func() {
			log.InfoD("Restore a multiple namespace backups")
			for _, nonAdminUserName := range userNames {
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
				restoreName := fmt.Sprintf("%s-multiple-ns-restore-%s", nonAdminUserName, RandomString(4))
				restoreNameMap[nonAdminUserName] = restoreName
				log.InfoD("Restoring multiple namespace backup [%s] in cluster [%s] with restore name [%s] for user [%s] ", multipleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, restoreNameMap[nonAdminUserName], nonAdminUserName)
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], multipleNamespaceBackupsMap[nonAdminUserName][0], namespaceMapping, storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of multiple namespace schedule backup [%s] in cluster [%s] for user [%s]", restoreNameMap[nonAdminUserName], multipleNamespaceBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
			}
		})
		Step("Restore a namespace label backups", func() {
			log.InfoD("Restore a namespace label backups")
			for _, nonAdminUserName := range userNames {
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, "Fetching px-central-admin ctx")
				restoreName := fmt.Sprintf("%s-multiple-ns-label-restore-%s", nonAdminUserName, RandomString(4))
				restoreNameMap[nonAdminUserName] = restoreName
				log.InfoD("Restoring multiple namespace backup [%s] in cluster [%s] with restore name [%s] ", multipleNamespaceLabelBackupsMap[nonAdminUserName][0], destinationClusterName, restoreNameMap[nonAdminUserName])
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[nonAdminUserName], multipleNamespaceLabelBackupsMap[nonAdminUserName][0], namespaceMapping, storageClassMapping, destinationClusterName, orgID, appContextsToBackup)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying restoration [%s] of multiple namespace schedule backup [%s] in cluster [%s] for user [%s]", restoreNameMap[nonAdminUserName], multipleNamespaceLabelBackupsMap[nonAdminUserName][0], destinationClusterName, nonAdminUserName))
			}
		})
		log.InfoD("Deletion of all backups,restores,schedules,clusters of users when user is present in keycloak ")
		Step(fmt.Sprintf("Listing and Deletion of backup of non-admin user from px-admin user"), func() {
			log.InfoD("Listing and Deletion of backup of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:3] {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupNamesByOwnerID(userIdMap[nonAdminUserName], orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupNamesMapFromAdmin[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNamesMapFromAdmin[nonAdminUserName]))
			}
			for _, nonAdminUserName := range userNames[:3] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupNamesMapFromAdmin[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Deletion of backup schedules of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of backup schedules of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:3] {
				log.InfoD(fmt.Sprintf("Verifying listing of backup schedule of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user from px-admin user"))
				userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
				log.Infof(fmt.Sprintf("the list of user [%s ]backup schedules from px-admin user %v", nonAdminUserName, userBackupSchedulesMap[nonAdminUserName]))
				for _, backupName := range userBackupNamesMap[nonAdminUserName] {
					if !IsPresent(userBackupNamesMapFromAdmin[nonAdminUserName], backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesMapFromAdmin[nonAdminUserName])
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			for _, nonAdminUserName := range userNames[:3] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
						backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, adminCtx)
						log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
						err = DeleteScheduleWithUIDAndWait(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Deletion of restores of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of restores of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:3] {
				log.InfoD(fmt.Sprintf("Verifying  listing of restores of non-admin user [%s] from px-admin user", nonAdminUserName))
				userRestores, err := GetAllRestoresForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching restores of user ffrom px-admin user"))
				userRestoresMap[nonAdminUserName] = userRestores
				log.Infof(fmt.Sprintf("the list of user [%s] restores from px-admin user %v", nonAdminUserName, userRestoresMap[nonAdminUserName]))
			}
			for _, nonAdminUserName := range userNames[:3] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, restoreName := range userRestoresMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying  Deletion of restores [%s] of non-admin user [%s] from px-admin user", restoreName, nonAdminUserName))
						restoreUid, _ := Inst().Backup.GetRestoreUID(adminCtx, restoreName, orgID)
						err := DeleteRestoreWithUID(restoreName, restoreUid, orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting restore [%s] of user [%s] from px-admin user", restoreName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Deletion of clusters of non-admin user from px-admin user"), func() {
			log.InfoD("Deletion of clusters of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[:3] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					err = DeleteClusterWithUID(SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
					err = DeleteClusterWithUID(destinationClusterName, clusterUidMap[nonAdminUserName][destinationClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		log.InfoD("Deletion of all backups,restores,schedules,clusters of users when user is deleted from keycloak ")
		Step(fmt.Sprintf("Verifying deletion of non-admin user from keycloak"), func() {
			log.InfoD("Verifying deletion of non-admin user from keycloak")
			for _, nonAdminUserName := range userNames[3:6] {
				log.InfoD(fmt.Sprintf("Verifying deletion of user  [%s] from keycloak", nonAdminUserName))
				log.Infof(fmt.Sprintf("Fetching user [%s] backup schedules and restore before user deletion ", nonAdminUserName))
				userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user from px-admin user"))
				userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
				log.Infof(fmt.Sprintf("the list of user [%s] backup schedules [%s] ", nonAdminUserName, userBackupSchedulesMap[nonAdminUserName]))
				userRestores, err := GetAllRestoresForUser(nonAdminUserName, commonPassword)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching restores of user ffrom px-admin user"))
				userRestoresMap[nonAdminUserName] = userRestores
				log.Infof(fmt.Sprintf("the list of user [%s] restores [%s] ", nonAdminUserName, userRestoresMap[nonAdminUserName]))
				err = backup.DeleteUser(nonAdminUserName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying the deletion of the user [%s]", nonAdminUserName))
			}
		})
		Step(fmt.Sprintf("Listing and deletion of backup of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Listing and deletion of backup of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[3:6] {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupNamesByOwnerID(userIdMap[nonAdminUserName], orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupNamesMapFromAdmin[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNamesMapFromAdmin[nonAdminUserName]))
				for _, backupName := range userBackupNamesMap[nonAdminUserName] {
					if !IsPresent(userBackupNamesMapFromAdmin[nonAdminUserName], backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesMapFromAdmin[nonAdminUserName])
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			for _, nonAdminUserName := range userNames[3:6] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupNamesMapFromAdmin[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Verifying  deletion of backup schedule of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of backup schedule of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[3:6] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
						backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, adminCtx)
						log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
						err = DeleteScheduleWithUIDAndWait(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Verifying  deletion of restore of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of restore of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[3:6] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, restoreName := range userRestoresMap[nonAdminUserName] {
						log.InfoD(fmt.Sprintf("Verifying  Deletion of restores [%s] of non-admin user [%s] from px-admin user", restoreName, nonAdminUserName))
						restoreUid, _ := Inst().Backup.GetRestoreUID(adminCtx, restoreName, orgID)
						err := DeleteRestoreWithUID(restoreName, restoreUid, orgID, adminCtx)
						dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting restore [%s] of user [%s] from px-admin user", restoreName, nonAdminUserName))
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})
		Step(fmt.Sprintf("Verifying  deletion of clusters of deleted non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of clusters of deleted non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames[3:6] {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					log.InfoD(fmt.Sprintf("Verifying  deletion of clusters of deleted non-admin user [%s] from px-admin user", nonAdminUserName))
					err = DeleteClusterWithUID(SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
					err = DeleteClusterWithUID(destinationClusterName, clusterUidMap[nonAdminUserName][destinationClusterName], orgID, adminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
				}(nonAdminUserName)
			}
			wg.Wait()
		})
	})

	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err = DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		log.Infof("Deleting backup schedule policy")
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policy %s ", []string{periodicSchedulePolicyName}))
		log.Infof("Deleting pre and post exec rules")
		if preRuleName != "" {
			err = Inst().Backup.DeleteRuleForBackup(orgID, preRuleName)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting pre exec rule %s ", preRuleName))
		}
		if postRuleName != "" {
			err = Inst().Backup.DeleteRuleForBackup(orgID, postRuleName)
			dash.VerifySafely(err, nil, fmt.Sprintf("Deleting post exec rule %s ", postRuleName))
		}
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// UpdatesBackupOfUserFromAdmin updates backups of non admin user from px-admin with valid/in-valid cloud account.
var _ = Describe("{UpdatesBackupOfUserFromAdmin}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87568
	var (
		scheduledAppContexts           []*scheduler.Context
		backupLocationUID              string
		credName                       string
		cloudCredUID                   string
		invalidCloudCredUID            string
		invalidCredName                string
		srcClusterUid                  string
		destClusterUid                 string
		backupLocationName             string
		nonAdminUserName               string
		periodicSchedulePolicyName     string
		periodicSchedulePolicyInterval int64
		periodicSchedulePolicyUid      string
		bkpNamespaces                  = make([]string, 0)
		backupLocationMap              = make(map[string]string)
		providers                      = getProviders()
		userBackupNames                = make([]string, 0)
		controlChannel                 chan string
		errorGroup                     *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("UpdatesBackupOfUserFromAdmin",
			"Updates backups of non admin user from px-admin with valid/in-valid account", nil, 87568, Ak, Q3FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})

	It("Updates Backups and Cluster of user from px-admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})

		Step("Create a non-admin user", func() {
			log.InfoD(fmt.Sprintf("Create a non-admin user"))
			nonAdminUserName = createUsers(1)[0]
			err := backup.AddRoleToUser(nonAdminUserName, backup.InfrastructureOwner, fmt.Sprintf("Adding %v role to %s", backup.InfrastructureOwner, nonAdminUserName))
			log.FailOnError(err, "Failed to add role for user - %s", nonAdminUserName)
		})

		Step(fmt.Sprintf("Adding Credentials and Backup Location from non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating cloud credentials and backup location from non-adminuser"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non-admin ctx")
				cloudCredUID = uuid.New()
				backupLocationUID = uuid.New()
				credName = fmt.Sprintf("autogenerated-cred-%s-%s", nonAdminUserName, RandomString(5))
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, nonAdminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%s-%s", nonAdminUserName, RandomString(5))
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Create schedule policy from non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating a schedule policy from non-admin [%s] user", nonAdminUserName))
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin user ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%s-%s", "periodic", RandomString(5), nonAdminUserName)
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval = 15
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, nonAdminCtx, false, false)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s] for user [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyName, nonAdminUserName))

		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on %s ", nonAdminUserName), func() {
			log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
			destClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
		})

		Step(fmt.Sprintf("Taking manual backup and schedule backup of applications for user %s", nonAdminUserName), func() {
			log.InfoD(fmt.Sprintf("Taking manual backup and schedule backup of applications for user%s", nonAdminUserName))
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			labelSelectors := make(map[string]string, 0)
			backupName := fmt.Sprintf("%s-manual-%s-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
				labelSelectors, orgID, srcClusterUid, "", "", "", "")
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupName))
			userBackupNames = append(userBackupNames, backupName)

			scheduleName := fmt.Sprintf("%s-schedule-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
			log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
			appContextsToBackup = FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleName, SourceClusterName, backupLocationName, backupLocationUID, appContextsToBackup,
				labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyName, periodicSchedulePolicyUid)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
			userBackupNames = append(userBackupNames, scheduleBackupName)
		})

		Step("Create invalid credential for cluster and backup object", func() {
			log.InfoD("Create invalid credential for cluster and backup object")
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			invalidCloudCredUID = uuid.New()
			backupLocationUID = uuid.New()
			invalidCredName = fmt.Sprintf("invalid-autogenerated-cred-%s-%s", nonAdminUserName, RandomString(5))
			err = createInvalidAWSCloudCredential(invalidCredName, invalidCloudCredUID, orgID, nonAdminCtx)
			log.FailOnError(err, "Failed to create invalid cloud credential - %s", err)
		})

		Step("Verifying listing and update of backup of non-admin user from px-admin", func() {
			log.InfoD("Verifying listing and update of backup of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			userUID, err := backup.FetchIDOfUser(nonAdminUserName)
			userBackupNamesFromAdmin, err := GetAllBackupNamesByOwnerID(userUID, orgID, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNamesFromAdmin, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNamesFromAdmin))
			for _, backupName := range userBackupNames {
				if !IsPresent(userBackupNamesFromAdmin, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
			for _, backupName := range userBackupNames {
				bkpUid, _ := Inst().Backup.GetBackupUID(adminCtx, backupName, orgID)
				_, err = UpdateBackup(backupName, bkpUid, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of update of backup [%v] of user [%s] from px-admin user", backupName, nonAdminUserName))
			}
		})

		Step("Verifying deletion of backup of non-admin user from px-admin", func() {
			log.InfoD("Verifying deletion of backup of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching admin ctx")
			userUID, err := backup.FetchIDOfUser(nonAdminUserName)
			userBackupNamesFromAdmin, err := GetAllBackupNamesByOwnerID(userUID, orgID, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNamesFromAdmin, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupNamesFromAdmin))
			for _, backupName := range userBackupNames {
				if !IsPresent(userBackupNamesFromAdmin, backupName) {
					err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupNamesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
			for _, backupName := range userBackupNamesFromAdmin {
				backupUID, _ := Inst().Backup.GetBackupUID(adminCtx, backupName, orgID)
				_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, srcClusterUid, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
				err = DeleteBackupAndWait(backupName, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
			}
		})

		Step("Verifying deletion of backup schedule of non-admin user from px-admin", func() {
			log.InfoD("Verifying deletion of backup schedule of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching admin ctx")
			userBackupScheduleNames, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupScheduleNames, nonAdminUserName))
			log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin %v", nonAdminUserName, userBackupScheduleNames))
			for _, userBackupScheduleName := range userBackupScheduleNames {
				log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] from px-admin user", userBackupScheduleName, nonAdminUserName))
				backupScheduleUid, err := GetScheduleUID(userBackupScheduleName, orgID, adminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", userBackupScheduleName))
				err = DeleteScheduleWithUIDAndWait(userBackupScheduleName, backupScheduleUid, SourceClusterName, srcClusterUid, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", userBackupScheduleName, nonAdminUserName))
			}
		})

		Step("Verifying update of cluster of non-admin user from px-admin", func() {
			log.InfoD("Verifying update of cluster of non-admin user from px-admin")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			srcClusterConfigPath, err := GetSourceClusterConfigPath()
			log.FailOnError(err, "Fetching source clusterconfigpath")
			_, err = UpdateCluster(SourceClusterName, srcClusterUid, srcClusterConfigPath, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
			dash.VerifyFatal(strings.Contains(err.Error(), "failed to validate access to the cluster"), true,
				fmt.Sprintf("Verification of update of cluster [%s] of user [%s] with wrong credentials is expected to fail", SourceClusterName, nonAdminUserName))
			dstClusterConfigPath, err := GetDestinationClusterConfigPath()
			log.FailOnError(err, "Fetching destination clusterconfigpath")
			_, err = UpdateCluster(destinationClusterName, destClusterUid, dstClusterConfigPath, orgID, invalidCredName, invalidCloudCredUID, adminCtx)
			dash.VerifyFatal(strings.Contains(err.Error(), "failed to validate access to the cluster"), true,
				fmt.Sprintf("Verification of update of cluster [%s] of user [%s] with wrong credentials is expected to fail", destinationClusterName, nonAdminUserName))
		})

		Step(fmt.Sprintf("Verifying  deletion of clusters of non-admin user from px-admin user"), func() {
			log.InfoD("Verifying  deletion of clusters of non-admin user from px-admin user")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			err = DeleteClusterWithUID(SourceClusterName, srcClusterUid, orgID, adminCtx, false)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", SourceClusterName))
			err = DeleteClusterWithUID(destinationClusterName, destClusterUid, orgID, adminCtx, false)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting cluster %s", destinationClusterName))
		})
	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		ctx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
		log.FailOnError(err, "Fetching px-central-admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err = DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		log.Infof("Deleting backup schedule policy")
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		CleanupCloudSettingsAndClusters(backupLocationMap, credName, cloudCredUID, ctx)
	})
})

// DeleteBackupSharedByMultipleUsersFromAdmin deletes backups non admin user from px-admin when backup is shared by multiple users.
var _ = Describe("{DeleteBackupSharedByMultipleUsersFromAdmin}", func() {
	// testrailID corresponds to: https://portworx.testrail.net/index.php?/cases/view/87565

	var (
		scheduledAppContexts           []*scheduler.Context
		backupLocationUID              string
		adminCredName                  string
		userName                       string
		adminCloudCredUID              string
		srcClusterUid                  string
		backupLocationName             string
		periodicSchedulePolicyName     string
		periodicSchedulePolicyInterval int64
		periodicSchedulePolicyUid      string
		appAdminUserName               string
		infraAdminUserName             string
		appUserName                    string
		userNames                      []string
		wg                             sync.WaitGroup
		mutex                          sync.Mutex
		bkpNamespaces                  = make([]string, 0)
		timeBetweenConsecutiveBackups  = 10 * time.Second
		backupLocationMap              = make(map[string]string)
		providers                      = getProviders()
		userIdMap                      = make(map[string]string)
		backupLocationUserMap          = make(map[string]string)
		backupLocationUidUserMap       = make(map[string]string)
		clusterUidMap                  = make(map[string]map[string]string)
		scheduleNameMap                = make(map[string]string)
		userBackupSchedulesMap         = make(map[string][]string)
		userBackupsMapFromAdmin        = make(map[string][]string)
		userBackupsMap                 = make(map[string][]string)
		backupDriver                   = Inst().Backup
		controlChannel                 chan string
		errorGroup                     *errgroup.Group
	)

	JustBeforeEach(func() {
		StartPxBackupTorpedoTest("DeleteBackupSharedByMultipleUsersFromAdmin",
			"Delete backups of non admin user from px-admin when backup is shared by multiple users", nil, 87565, Ak, Q3FY24)
		log.InfoD("Deploy applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, ctx := range appContexts {
				ctx.ReadinessTimeout = appReadinessTimeout
				namespace := GetAppNamespace(ctx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
				scheduledAppContexts = append(scheduledAppContexts, ctx)
			}
		}
		log.InfoD("Created namespaces %v", bkpNamespaces)
	})

	It("Delete backups of non admin user from px-admin", func() {
		Step("Validate applications", func() {
			log.InfoD("Validate applications")
			ctx, _ := backup.GetAdminCtxFromSecret()
			controlChannel, errorGroup = ValidateApplicationsStartData(scheduledAppContexts, ctx)
		})

		Step("Create a non-admin users to create the backups and restore", func() {
			log.InfoD(fmt.Sprintf("Create a non-admin users to create the backups and restore"))
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for _, role := range roles {
				userName = createUsers(1)[0]
				err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
				log.FailOnError(err, "Failed to add role for user - %s", userName)
				if role == backup.ApplicationOwner {
					appAdminUserName = userName
				} else if role == backup.InfrastructureOwner {
					infraAdminUserName = userName
				} else {
					appUserName = userName
				}
				userNames = append(userNames, userName)
				userUID, err := backup.FetchIDOfUser(userName)
				log.FailOnError(err, "Failed to fetch uid for - %s", userName)
				userIdMap[userName] = userUID
			}
		})

		Step(fmt.Sprintf("Adding Credentials from px-admin user and sharing with required users"), func() {
			log.InfoD(fmt.Sprintf("Adding Credentials from px-admin user and sharing with required users"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, provider := range providers {
				adminCloudCredUID = uuid.New()
				adminCredName = fmt.Sprintf("autogenerated-cred-%s", RandomString(5))
				err = CreateCloudCredential(provider, adminCredName, adminCloudCredUID, orgID, adminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				log.Infof("Updating cloud credential ownership for non-admin users")
				if provider != drivers.ProviderNfs {
					err = AddCloudCredentialOwnership(adminCredName, adminCloudCredUID, []string{appAdminUserName}, nil, Read, Invalid, adminCtx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying ownership update for cloud credential %s to user %s", adminCredName, []string{appAdminUserName}))
				}
			}
		})

		Step(fmt.Sprintf("Adding backup location from px-admin user and sharing with app users"), func() {
			log.InfoD(fmt.Sprintf("Adding backup location  from px-admin user and sharing with app users"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, provider := range providers {
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%s", RandomString(5))
				backupLocationUID = uuid.New()
				err := CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", adminCtx, true)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				log.Infof("Updating backup location ownership for non-admin users")
				err = AddBackupLocationOwnership(backupLocationName, backupLocationUID, []string{appUserName}, nil, Read, Invalid, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying ownership update for backup location %s to user %s", backupLocationName, []string{appUserName}))
				backupLocationUserMap[appUserName] = backupLocationName
				backupLocationUidUserMap[appUserName] = backupLocationUID
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Adding backup location for app-admin user and shared cloud cred from px-admin"), func() {
			log.InfoD(fmt.Sprintf("Adding backup location for app-admin user and shared cloud cred from px-admin"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching px-admin ctx")
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%s-%s", appAdminUserName, RandomString(5))
				backupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationUserMap[appAdminUserName] = backupLocationName
				backupLocationUidUserMap[appAdminUserName] = backupLocationUID
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Adding cloud credentials and backup location for infra-admin users"), func() {
			log.InfoD(fmt.Sprintf("Adding cloud credentials and backup location for infra-admin users"))
			for _, provider := range providers {
				nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching px-admin ctx")
				cloudCredUID := uuid.New()
				credName := fmt.Sprintf("autogenerated-cred-%s-%s", infraAdminUserName, RandomString(5))
				err = CreateCloudCredential(provider, credName, cloudCredUID, orgID, nonAdminCtx)
				log.FailOnError(err, "Failed to create cloud credential - %s", err)
				backupLocationName = fmt.Sprintf("autogenerated-backup-location-%s-%s", infraAdminUserName, RandomString(5))
				backupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationName, backupLocationUID, credName, cloudCredUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx, true)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", backupLocationName, provider)
				backupLocationUserMap[infraAdminUserName] = backupLocationName
				backupLocationUidUserMap[infraAdminUserName] = backupLocationUID
				backupLocationMap[backupLocationUID] = backupLocationName
			}
		})

		Step(fmt.Sprintf("Create schedule policy from px-admin user"), func() {
			log.InfoD(fmt.Sprintf("Creating a schedule policy from px-admin user"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%s", "periodic", RandomString(5))
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval = 15
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, adminCtx, false, false)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s] for px-admin ", periodicSchedulePolicyInterval, periodicSchedulePolicyName))
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyName, periodicSchedulePolicyUid, userNames, nil, Read, Invalid, adminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying update of owbership for SchedulePolicy- %s", periodicSchedulePolicyName))

		})

		Step(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Register source and destination cluster for backup on non-admin user"))
			for _, nonAdminUserName := range userNames {
				log.InfoD("Registering Source and Destination clusters as user : %s and verifying the status", nonAdminUserName)
				nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
				log.FailOnError(err, "Fetching non admin ctx")
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "Failed creating source and destination cluster for user : %s", nonAdminUserName)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				srcClusterUid, err = Inst().Backup.GetClusterUID(nonAdminCtx, orgID, SourceClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
				destClusterUid, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, destinationClusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", destinationClusterName))
				clusterInfo := make(map[string]string)
				clusterInfo[SourceClusterName] = srcClusterUid
				clusterInfo[destinationClusterName] = destClusterUid
				clusterUidMap[nonAdminUserName] = clusterInfo
			}
		})

		Step(fmt.Sprintf("Taking manual backup of applications as non-admin user"), func() {
			log.InfoD(fmt.Sprintf("Taking manual backup of applications as non-admin user"))
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					labelSelectors := make(map[string]string, 0)
					backupName := fmt.Sprintf("%s-manual-%s-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
					err = CreateBackupWithValidation(nonAdminCtx, backupName, SourceClusterName, backupLocationUserMap[nonAdminUserName], backupLocationUidUserMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, clusterUidMap[nonAdminUserName][SourceClusterName], "", "", "", "")
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", backupName))
					userBackupsMap[nonAdminUserName] = SafeAppend(&mutex, userBackupsMap[nonAdminUserName], backupName).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step(fmt.Sprintf("Taking schedule backup of applications as non-admin user "), func() {
			log.InfoD(fmt.Sprintf("Taking schedule backup of applications as non-admin user"))
			for _, nonAdminUserName := range userNames {
				time.Sleep(timeBetweenConsecutiveBackups)
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
					log.FailOnError(err, "Fetching non admin ctx")
					log.InfoD("Taking schedule backup of single namespace as user : %s without-rules", nonAdminUserName)
					scheduleName := fmt.Sprintf("%s-schedule-single-ns-%s-without-rules-%s", BackupNamePrefix, nonAdminUserName, RandomString(4))
					scheduleNameMap[nonAdminUserName] = scheduleName
					labelSelectors := make(map[string]string, 0)
					log.InfoD("Creating a schedule backup of namespace [%s] without pre and post exec rules", bkpNamespaces[0])
					appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, []string{bkpNamespaces[0]})
					scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, scheduleNameMap[nonAdminUserName], SourceClusterName, backupLocationUserMap[nonAdminUserName], backupLocationUidUserMap[nonAdminUserName], appContextsToBackup,
						labelSelectors, orgID, "", "", "", "", periodicSchedulePolicyName, periodicSchedulePolicyUid)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup [%s]", scheduleBackupName))
					err = suspendBackupSchedule(scheduleNameMap[nonAdminUserName], periodicSchedulePolicyName, orgID, nonAdminCtx)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[nonAdminUserName], nonAdminUserName))
					userBackupsMap[nonAdminUserName] = SafeAppend(&mutex, userBackupsMap[nonAdminUserName], scheduleBackupName).([]string)
				}(nonAdminUserName)
			}
			wg.Wait()
		})

		Step("Sharing of backup of app-user user with app-admin and infra-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of app-user user with app-admin and infra-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(appUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing app-user [%s] backups [%v] with app-admin and infra-admin", appUserName, userBackupsMap[appUserName]))
			for _, appUserBackupName := range userBackupsMap[appUserName] {
				err := ShareBackup(appUserBackupName, nil, []string{appAdminUserName, infraAdminUserName}, 1, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", appUserBackupName, appUserName))
			}
		})

		Step("Sharing of backup of app-admin user with app-user and infra-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of app-admin user with app-user and infra-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing app-admin user [%s] backups [%v] with app-user and infra-admin", appAdminUserName, userBackupsMap[appAdminUserName]))
			for _, appAdminUserBackupName := range userBackupsMap[appAdminUserName] {
				err := ShareBackup(appAdminUserBackupName, nil, []string{appUserName, infraAdminUserName}, 1, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", appAdminUserBackupName, appAdminUserName))
			}
		})

		Step("Sharing of backup of infra-admin user with app-user and app-admin user", func() {
			log.InfoD(fmt.Sprintf("Sharing of backup of infra-admin user with app-user and app-admin user"))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non-admin ctx")
			log.Infof(fmt.Sprintf("Sharing infra-admin user [%s] backups [%v] with app-admin and app-user", infraAdminUserName, userBackupsMap[infraAdminUserName]))
			for _, infraAdminUserBackupName := range userBackupsMap[infraAdminUserName] {
				err := ShareBackup(infraAdminUserBackupName, nil, []string{appAdminUserName, appUserName}, 3, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of sharing backup [%v] of user [%s] ", infraAdminUserBackupName, infraAdminUserName))
			}
		})

		Step(fmt.Sprintf("Listing and Deletion of shared backup of non-admin users from px-admin user"), func() {
			log.InfoD(fmt.Sprintf("Listing and Deletion of shared backup of non-admin users from px-admin user"))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "Fetching px-admin ctx")
			for _, nonAdminUserName := range userNames {
				log.InfoD(fmt.Sprintf("Verifying listing backups of non-admin user [%s] from px-admin user", nonAdminUserName))
				userBackupNames, err := GetAllBackupNamesByOwnerID(userIdMap[nonAdminUserName], orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verification of fetching backups [%v] of user [%s] from px-admin user", userBackupNames, nonAdminUserName))
				userBackupsMapFromAdmin[nonAdminUserName] = userBackupNames
				log.Infof(fmt.Sprintf("The list of user [%s] backups from px-admin [%v]", nonAdminUserName, userBackupsMapFromAdmin[nonAdminUserName]))
				for _, backupName := range userBackupsMap[nonAdminUserName] {
					if !IsPresent(userBackupsMapFromAdmin[nonAdminUserName], backupName) {
						err := fmt.Errorf("backup %s is not listed in backup names %s", backupName, userBackupsMapFromAdmin[nonAdminUserName])
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			for _, nonAdminUserName := range userNames {
				wg.Add(1)
				go func(nonAdminUserName string) {
					defer GinkgoRecover()
					defer wg.Done()
					for _, backupName := range userBackupsMapFromAdmin[nonAdminUserName] {
						wg.Add(1)
						go func(backupName string) {
							defer GinkgoRecover()
							defer wg.Done()
							log.InfoD(fmt.Sprintf("Verifying deletion backup [%s] of non-admin user [%s] from px-admin user", backupName, nonAdminUserName))
							backupUID, _ := backupDriver.GetBackupUID(adminCtx, backupName, orgID)
							_, err = DeleteBackupWithClusterUID(backupName, backupUID, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, adminCtx)
							log.FailOnError(err, "Failed to delete backup - %s", backupName)
							err = DeleteBackupAndWait(backupName, adminCtx)
							log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
						}(backupName)
					}
				}(nonAdminUserName)
			}
			wg.Wait()
		})

	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		err := DestroyAppsWithData(scheduledAppContexts, opts, controlChannel, errorGroup)
		log.FailOnError(err, "Data validations failed")
		for _, nonAdminUserName := range userNames {
			userBackupSchedules, err := GetAllBackupSchedulesForUser(nonAdminUserName, commonPassword)
			dash.VerifySafely(err, nil, fmt.Sprintf("Verification of fetching backup schedules of user "))
			userBackupSchedulesMap[nonAdminUserName] = userBackupSchedules
		}
		for _, nonAdminUserName := range userNames {
			nonAdminCtx, err := backup.GetNonAdminCtx(nonAdminUserName, commonPassword)
			log.FailOnError(err, "Fetching non admin ctx")
			wg.Add(1)
			go func(nonAdminUserName string) {
				defer GinkgoRecover()
				defer wg.Done()
				for _, backupScheduleName := range userBackupSchedulesMap[nonAdminUserName] {
					log.InfoD(fmt.Sprintf("Verifying deletion of backup schedule [%s] of non-admin user [%s] ", backupScheduleName, nonAdminUserName))
					backupScheduleUid, err := GetScheduleUID(backupScheduleName, orgID, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("Fetching schedule uid for shedule [%s]", backupScheduleName))
					err = DeleteScheduleWithUIDAndWait(backupScheduleName, backupScheduleUid, SourceClusterName, clusterUidMap[nonAdminUserName][SourceClusterName], orgID, nonAdminCtx)
					dash.VerifySafely(err, nil, fmt.Sprintf("Verification of deleting backup scheudle [%s] of user [%s] from px-admin user", backupScheduleName, nonAdminUserName))
				}
			}(nonAdminUserName)
		}
		wg.Wait()
		log.Infof("Deleting backup schedule policy")
		err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
		dash.VerifySafely(err, nil, fmt.Sprintf("Deleting backup schedule policies %s ", []string{periodicSchedulePolicyName}))
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "Fetching non admin ctx")
		CleanupCloudSettingsAndClusters(backupLocationMap, adminCredName, adminCloudCredUID, ctx)
	})
})

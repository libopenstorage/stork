package tests

import (
	"fmt"
	"strings"
	"sync"
	"time"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// VerifyRBACforInfraAdmin Validates the RBAC operation for infra-admin user.
var _ = Describe("{VerifyRBACforInfraAdmin}", func() {
	var (
		scheduledAppContexts          []*scheduler.Context
		backupLocationMap             = make(map[string]string)
		backupLocationNameMap         = make(map[string]string)
		backupLocationUIDMap          = make(map[string]string)
		cloudCredentialNameMap        = make(map[string]string)
		cloudCredentialUIDMap         = make(map[string]string)
		scheduleNameMap               = make(map[string]string)
		periodicSchedulePolicyNameMap = make(map[string]string)
		periodicSchedulePolicyUidMap  = make(map[string]string)
		preRuleNameMap                = make(map[string]string)
		postRuleNameMap               = make(map[string]string)
		preRuleUidMap                 = make(map[string]string)
		postRuleUidMap                = make(map[string]string)
		numOfUsers                    = 3
		infraAdminUser                string
		customUser                    string
		customInfraRoleName           backup.PxBackupRole
		customRoleName                backup.PxBackupRole
		userClusterMap                = make(map[string]map[string]string)
		backupNameMap                 = make(map[string]string)
		restoreNameMap                = make(map[string]string)
		userBackupNamesMap            = make(map[string][]string)
		cloudCredentialFromAdmin      []string
		backupLocationsFromAdmin      []string
		userNames                     = make([]string, 0)
		providers                     = getProviders()
		bkpNamespaces                 []string
		infraAdminRole                backup.PxBackupRole = backup.InfrastructureOwner
		labelSelectors                map[string]string
		mutex                         sync.Mutex
	)

	JustBeforeEach(func() {
		StartTorpedoTest("VerifyRBACforInfraAdmin", "Validates the RBAC operation for infra-admin user.", nil, 87886)
		backupLocationMap = make(map[string]string)
		log.InfoD("scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, appCtx := range appContexts {
				appCtx.ReadinessTimeout = appReadinessTimeout
				scheduledAppContexts = append(scheduledAppContexts, appCtx)
				namespace := GetAppNamespace(appCtx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Validates the RBAC operation for infra-admin user", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step(fmt.Sprintf("Create a user with %s role", infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating a user with %s role", infraAdminRole))
			infraAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(infraAdminUser, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, infraAdminUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
		})

		Step("Verify Infra-Admin User has permission to create cloud credential  and backup location", func() {
			log.InfoD("Verify Infra-Admin User has permission to create cloud credential and backup location")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				cloudCredentialNameMap[infraAdminUser] = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				cloudCredentialUIDMap[infraAdminUser] = uuid.New()
				err = CreateCloudCredential(provider, cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create cloud credential %s using provider %s for the user", cloudCredentialNameMap[infraAdminUser], provider))
				backupLocationNameMap[infraAdminUser] = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationUIDMap[infraAdminUser] = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", backupLocationNameMap[infraAdminUser], provider)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create backup location %s using provider %s for the user", backupLocationNameMap[infraAdminUser], provider))
				backupLocationMap[backupLocationUIDMap[infraAdminUser]] = backupLocationNameMap[infraAdminUser]
			}
		})

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create a schedule policy"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create a schedule policy")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			periodicSchedulePolicyNameMap[infraAdminUser] = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchedulePolicyUidMap[infraAdminUser] = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser], orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[infraAdminUser]))
		})

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create pre and post exec rules for applications")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			preRuleNameMap[infraAdminUser], postRuleNameMap[infraAdminUser], err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from px-admin"))
			if preRuleNameMap[infraAdminUser] != "" {
				preRuleUidMap[infraAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, preRuleNameMap[infraAdminUser])
				log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleNameMap[infraAdminUser])
				log.Infof("Pre backup rule [%s] uid: [%s]", preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser])
			}
			if postRuleNameMap[infraAdminUser] != "" {
				postRuleUidMap[infraAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, postRuleNameMap[infraAdminUser])
				log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleNameMap[infraAdminUser])
				log.Infof("Post backup rule [%s] uid: [%s]", postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser])
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can list RBAC resources created by Infra-Admin User"), func() {
			log.InfoD("Verify px-admin group user can list RBAC resources created by Infra-Admin User")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					cloudCredentials, err := getAllCloudCredentials(adminCtx)
					log.FailOnError(err, "Fetching cloud credential from px-admin")
					for _, cloudCredentialName := range cloudCredentials {
						cloudCredentialFromAdmin = append(cloudCredentialFromAdmin, cloudCredentialName)
					}
					if !IsPresent(cloudCredentialFromAdmin, cloudCredentialNameMap[infraAdminUser]) {
						err := fmt.Errorf("Cloud Credential[%s] is not listed in cloud credentials from admin %s", cloudCredentialNameMap[infraAdminUser], cloudCredentialFromAdmin)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			backupLocations, err := getAllBackupLocations(adminCtx)
			log.FailOnError(err, "Fetching backup location from px-admin")
			for _, backupLocationName := range backupLocations {
				backupLocationsFromAdmin = append(backupLocationsFromAdmin, backupLocationName)
			}
			if !IsPresent(backupLocationsFromAdmin, backupLocationNameMap[infraAdminUser]) {
				err := fmt.Errorf("backup location [%s] is not listed in backup location names from admin %s", backupLocationNameMap[infraAdminUser], backupLocationsFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}
			schedulePoliciesFromAdmin, err := Inst().Backup.GetAllSchedulePolicies(adminCtx, orgID)
			log.FailOnError(err, "Fetching backup schedules from px-admin")
			if !IsPresent(schedulePoliciesFromAdmin, periodicSchedulePolicyNameMap[infraAdminUser]) {
				err := fmt.Errorf("schedule policy [%s] is not listed in schedule policies  from admin %s", periodicSchedulePolicyNameMap[infraAdminUser], schedulePoliciesFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}

			rulesFromAdmin, err := Inst().Backup.GetAllRules(adminCtx, orgID)
			log.FailOnError(err, "Fetching rules from px-admin")
			if preRuleNameMap[infraAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, preRuleNameMap[infraAdminUser]) {
					err := fmt.Errorf("pre rule [%s] is not listed in rules from admin %s", preRuleNameMap[infraAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
			if postRuleNameMap[infraAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, postRuleNameMap[infraAdminUser]) {
					err := fmt.Errorf("post rule [%s] is not listed in rules from admin %s", postRuleNameMap[infraAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})

		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for i := 1; i <= numOfUsers/3; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					userNames = append(userNames, userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
				}
			}
		})

		Step("Verify Infra-Admin User has permission to share RBAC resources with non-admin users", func() {
			log.InfoD("Verify Infra-Admin User has permission to share RBAC resources with non-admin users")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					log.Infof("Update CloudAccount - %s ownership for users - [%v]", cloudCredentialNameMap[infraAdminUser], userNames)
					err = AddCloudCredentialOwnership(cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for CloudCredential- %s", cloudCredentialNameMap[infraAdminUser]))
				}
			}
			log.InfoD("Update BackupLocation - %s ownership for users - [%v]", backupLocationNameMap[infraAdminUser], userNames)
			err = AddBackupLocationOwnership(backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for backuplocation - %s", backupLocationNameMap[infraAdminUser]))
			log.InfoD("Update SchedulePolicy - %s ownership for users - [%v]", periodicSchedulePolicyNameMap[infraAdminUser], userNames)
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for schedulepolicy - %s", periodicSchedulePolicyNameMap[infraAdminUser]))
			log.InfoD("Update Application Rules ownership for users - [%v]", userNames)
			if preRuleNameMap[infraAdminUser] != "" {
				err = AddRuleOwnership(preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for pre-rule of application"))
			}
			if postRuleNameMap[infraAdminUser] != "" {
				err = AddRuleOwnership(postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for post-rule of application"))
			}
		})

		createObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				backupName := fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, user, RandomString(4))
				backupNameMap[user] = backupName
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[user], SourceClusterName, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], appContextsToBackup, labelSelectors, orgID, userClusterMap[user][SourceClusterName], preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, bkpNamespaces))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], backupNameMap[user]).([]string)
			})

			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", time.Now().Unix())
				scheduleNameMap[user] = userScheduleName
				scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], scheduledAppContexts, make(map[string]string), orgID, preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser], periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", userScheduleName))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], scheduleBackupName).([]string)
				err = suspendBackupSchedule(scheduleNameMap[user], periodicSchedulePolicyNameMap[infraAdminUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
		}
		err := TaskHandler(userNames, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")

		cleanupUserObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Delete user %s backups from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, backupName := range userBackupNamesMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackup(backupName, backupUid, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					err = DeleteBackupAndWait(backupName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
				}
			})
			Step(fmt.Sprintf("Delete user %s backup schedule ", user), func() {
				log.InfoD(fmt.Sprintf("Delete user %s backup schedule ", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = DeleteSchedule(scheduleNameMap[user], SourceClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
					err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
					log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
				}
			})
		}
		err = TaskHandler(userNames, cleanupUserObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create new custom role"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create new custom role")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			customInfraRoleName = backup.PxBackupRole(fmt.Sprintf("custom-infra-admin-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation, Role}
			apis := []RoleApis{All}
			err = CreateRole(customInfraRoleName, services, apis, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of role [%s] by the infra-admin user", customInfraRoleName))
		})
		Step(fmt.Sprintf("Create a new user with custom role [%s]", customInfraRoleName), func() {
			log.InfoD(fmt.Sprintf("Create a new user with custom role [%s]", customInfraRoleName))
			customUser = createUsers(1)[0]
			err := backup.AddRoleToUser(customUser, customInfraRoleName, fmt.Sprintf("Adding %v role to %s", customInfraRoleName, customUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
			log.Infof("username %s common password %s", infraAdminUser, commonPassword)
		})

		Step("Verify custom user has permission to create cloud credential and backup location", func() {
			log.InfoD("Verify custom user has permission to create cloud credential and backup location")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			for _, provider := range providers {
				cloudCredentialNameMap[customUser] = fmt.Sprintf("autogenerated-cred-%v", time.Now().Unix())
				cloudCredentialUIDMap[customUser] = uuid.New()
				err = CreateCloudCredential(provider, cloudCredentialNameMap[customUser], cloudCredentialUIDMap[customUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of cloud credential %s using provider %s for the user", cloudCredentialNameMap[customUser], provider))
				backupLocationNameMap[customUser] = fmt.Sprintf("autogenerated-backup-location-%v", time.Now().Unix())
				backupLocationUIDMap[customUser] = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], cloudCredentialNameMap[customUser], cloudCredentialUIDMap[customUser], getGlobalBucketName(provider), orgID, "", "", nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup location %s using provider %s for the custom user [%s]", backupLocationNameMap[customUser], provider, customUser))
			}
		})

		Step(fmt.Sprintf("Verify custom user has permission to create a schedule policy"), func() {
			log.InfoD("Verify custom user has permission to create a schedule policy")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			periodicSchedulePolicyNameMap[customUser] = fmt.Sprintf("%s-%v", "periodic", time.Now().Unix())
			periodicSchedulePolicyUidMap[customUser] = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[customUser], periodicSchedulePolicyUidMap[customUser], orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[customUser]))
		})

		Step(fmt.Sprintf("Verify custom user has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify custom user has permission to create pre and post exec rules for applications")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			preRuleNameMap[customUser], postRuleNameMap[customUser], err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from custom user [%s]", customUser))
		})

		Step(fmt.Sprintf("Verify custom user doesn't have permission to create roles"), func() {
			log.InfoD("Verify custom user doesn't have permission to create roles")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			customRoleName = backup.PxBackupRole(fmt.Sprintf("custom-user-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation, Role}
			apis := []RoleApis{All}
			err = CreateRole(customRoleName, services, apis, nonAdminCtx)
			dash.VerifyFatal(strings.Contains(err.Error(), "PermissionDenied desc = Access denied for [Resource: role]"), true, fmt.Sprintf("Verifying custom user doesnt have permission for creating role [%s]", customRoleName))
		})
		Step(fmt.Sprintf("Create source and destination cluster from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", customUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[customUser] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[customUser][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			backupNameMap[customUser] = fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, customUser, RandomString(4))
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[customUser], SourceClusterName, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], appContextsToBackup, labelSelectors, orgID, userClusterMap[customUser][SourceClusterName], "", "", "", "")
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupNameMap[customUser], bkpNamespaces))
		})

		Step(fmt.Sprintf("Take restore of applications from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Taking restore of applications from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			restoreNameMap[customUser] = fmt.Sprintf("%s-%s", restoreNamePrefix, backupNameMap[customUser])
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[customUser], backupNameMap[customUser], make(map[string]string), make(map[string]string), destinationClusterName, orgID, appContextsToBackup)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreNameMap[customUser], backupNameMap[customUser]))
		})

		Step(fmt.Sprintf("Delete user %s backups from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupNameMap[customUser], orgID)
			log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupNameMap[customUser], customUser)
			_, err = DeleteBackup(backupNameMap[customUser], backupUid, orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete backup %s of the user %s", backupNameMap[customUser], customUser)
			err = DeleteBackupAndWait(backupNameMap[customUser], nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupNameMap[customUser]))
		})

		Step(fmt.Sprintf("Delete user %s restores from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s restores from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			err = DeleteRestore(restoreNameMap[customUser], orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete restore %s of the user %s", restoreNameMap[customUser], customUser)
		})
		Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, customUser))
				err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
				log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by customUser [%s]", customUser), func() {
			log.InfoD(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by customUser [%s]", customUser))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			log.Infof("Verify deletion of backup location [%s] of user [%s] from px-admin", backupLocationNameMap[customUser], customUser)
			err = DeleteBackupLocation(backupLocationNameMap[customUser], backupLocationUIDMap[customUser], orgID, true)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of backup location [%s] of the user %s", backupLocationNameMap[customUser], customUser))
			err = Inst().Backup.WaitForBackupLocationDeletion(adminCtx, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], orgID, backupLocationDeleteTimeout, backupLocationDeleteRetryTime)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying waiting for backup location [%s]  deletion of the user %s", backupLocationNameMap[customUser], customUser))
			log.Infof("Verify deletion of schedule policy [%s] of user [%s] from px-admin", periodicSchedulePolicyNameMap[customUser], customUser)
			err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyNameMap[customUser]})
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of the user %s", periodicSchedulePolicyNameMap[customUser], customUser))
			log.Infof("Verify deletion of rules of user [%s] from px-admin", customUser)
			customUserRules, _ := Inst().Backup.GetAllRules(nonAdminCtx, orgID)
			for _, ruleName := range customUserRules {
				err := DeleteRule(ruleName, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the user %s", ruleName, customUser))
			}
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					log.Infof("Verify deletion of cloud credential [%s] of user [%s] from px-admin", cloudCredentialNameMap[customUser], customUser)
					err = DeleteCloudCredential(cloudCredentialNameMap[customUser], orgID, cloudCredentialUIDMap[customUser])
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cloud credential [%s] of the user %s", cloudCredentialNameMap[customUser], customUser))
				}
			}
		})

		Step(fmt.Sprintf("Verify infra-admin user [%s] can delete RBAC resources created ", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verify infra-admin user [%s] can delete RBAC resources created ", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			log.Infof("Verify deletion of schedule policy [%s] of user [%s] ", periodicSchedulePolicyNameMap[infraAdminUser], infraAdminUser)
			err = DeleteBackupSchedulePolicyWithContext(orgID, []string{periodicSchedulePolicyNameMap[infraAdminUser]}, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of the user %s", periodicSchedulePolicyNameMap[infraAdminUser], infraAdminUser))
			log.Infof("Verify deletion of rules of user [%s] ", infraAdminUser)
			userRules, _ := Inst().Backup.GetAllRules(nonAdminCtx, orgID)
			for _, ruleName := range userRules {
				err := DeleteRule(ruleName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the user %s", ruleName, infraAdminUser))
			}
			log.Infof("Verify deletion of role [%s] created by user [%s] ", customInfraRoleName, infraAdminUser)
			err = DeleteRole(customInfraRoleName, orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of role [%s] created by user  %s", customInfraRoleName, infraAdminUser))
		})

	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
		log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Deleting the px-backup objects")
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], nonAdminCtx)
		log.InfoD("Switching context to destination cluster for clean up")
		err = SetDestinationKubeConfig()
		log.FailOnError(err, "Unable to switch context to destination cluster [%s]", destinationClusterName)
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Switching back context to Source cluster")
		err = SetSourceKubeConfig()
		log.FailOnError(err, "Unable to switch context to source cluster [%s]", SourceClusterName)
	})
})

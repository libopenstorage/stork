package tests

import (
	"fmt"
	"strings"
	"sync"

	. "github.com/onsi/ginkgo"
	"github.com/pborman/uuid"
	api "github.com/portworx/px-backup-api/pkg/apis/v1"
	"github.com/portworx/torpedo/drivers"
	"github.com/portworx/torpedo/drivers/backup"
	"github.com/portworx/torpedo/drivers/scheduler"
	"github.com/portworx/torpedo/pkg/log"
	. "github.com/portworx/torpedo/tests"
)

// VerifyRBACforInfraAdmin Validates the RBAC operation for infra-admin user.
var _ = Describe("{VerifyRBACforInfraAdmin}", func() {
	var (
		scheduledAppContexts          []*scheduler.Context
		backupLocationMap             = make(map[string]string)
		backupLocationNameMap         = make(map[string]string)
		backupLocationUIDMap          = make(map[string]string)
		cloudCredentialNameMap        = make(map[string]string)
		cloudCredentialUIDMap         = make(map[string]string)
		scheduleNameMap               = make(map[string]string)
		periodicSchedulePolicyNameMap = make(map[string]string)
		periodicSchedulePolicyUidMap  = make(map[string]string)
		preRuleNameMap                = make(map[string]string)
		postRuleNameMap               = make(map[string]string)
		preRuleUidMap                 = make(map[string]string)
		postRuleUidMap                = make(map[string]string)
		numOfUsers                    = 3
		infraAdminUser                string
		customUser                    string
		customInfraRoleName           backup.PxBackupRole
		customRoleName                backup.PxBackupRole
		userClusterMap                = make(map[string]map[string]string)
		backupNameMap                 = make(map[string]string)
		restoreNameMap                = make(map[string]string)
		userBackupNamesMap            = make(map[string][]string)
		cloudCredentialFromAdmin      []string
		backupLocationsFromAdmin      []string
		userNames                     = make([]string, 0)
		providers                     = getProviders()
		bkpNamespaces                 []string
		infraAdminRole                backup.PxBackupRole = backup.InfrastructureOwner
		labelSelectors                map[string]string
		mutex                         sync.Mutex
	)

	JustBeforeEach(func() {
		StartTorpedoTest("VerifyRBACforInfraAdmin", "Validates the RBAC operation for infra-admin user.", nil, 87886)
		backupLocationMap = make(map[string]string)
		log.InfoD("scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, appCtx := range appContexts {
				appCtx.ReadinessTimeout = appReadinessTimeout
				scheduledAppContexts = append(scheduledAppContexts, appCtx)
				namespace := GetAppNamespace(appCtx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Validates the RBAC operation for infra-admin user", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step(fmt.Sprintf("Create a user with %s role", infraAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating a user with %s role", infraAdminRole))
			infraAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(infraAdminUser, infraAdminRole, fmt.Sprintf("Adding %v role to %s", infraAdminRole, infraAdminUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
		})

		Step("Verify Infra-Admin User has permission to create cloud credential  and backup location", func() {
			log.InfoD("Verify Infra-Admin User has permission to create cloud credential and backup location")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				cloudCredentialNameMap[infraAdminUser] = fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
				cloudCredentialUIDMap[infraAdminUser] = uuid.New()
				err = CreateCloudCredential(provider, cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create cloud credential %s using provider %s for the user", cloudCredentialNameMap[infraAdminUser], provider))
				backupLocationNameMap[infraAdminUser] = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
				backupLocationUIDMap[infraAdminUser] = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], getGlobalBucketName(provider), orgID, "", nonAdminCtx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", backupLocationNameMap[infraAdminUser], provider)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create backup location %s using provider %s for the user", backupLocationNameMap[infraAdminUser], provider))
				backupLocationMap[backupLocationUIDMap[infraAdminUser]] = backupLocationNameMap[infraAdminUser]
			}
		})

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create a schedule policy"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create a schedule policy")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			periodicSchedulePolicyNameMap[infraAdminUser] = fmt.Sprintf("%s-%v", "periodic", RandomString(5))
			periodicSchedulePolicyUidMap[infraAdminUser] = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser], orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[infraAdminUser]))
		})

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create pre and post exec rules for applications")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			preRuleNameMap[infraAdminUser], postRuleNameMap[infraAdminUser], err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from px-admin"))
			if preRuleNameMap[infraAdminUser] != "" {
				preRuleUidMap[infraAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, preRuleNameMap[infraAdminUser])
				log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleNameMap[infraAdminUser])
				log.Infof("Pre backup rule [%s] uid: [%s]", preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser])
			}
			if postRuleNameMap[infraAdminUser] != "" {
				postRuleUidMap[infraAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, postRuleNameMap[infraAdminUser])
				log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleNameMap[infraAdminUser])
				log.Infof("Post backup rule [%s] uid: [%s]", postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser])
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can list RBAC resources created by Infra-Admin User"), func() {
			log.InfoD("Verify px-admin group user can list RBAC resources created by Infra-Admin User")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					cloudCredentials, err := getAllCloudCredentials(adminCtx)
					log.FailOnError(err, "Fetching cloud credential from px-admin")
					for _, cloudCredentialName := range cloudCredentials {
						cloudCredentialFromAdmin = append(cloudCredentialFromAdmin, cloudCredentialName)
					}
					if !IsPresent(cloudCredentialFromAdmin, cloudCredentialNameMap[infraAdminUser]) {
						err := fmt.Errorf("Cloud Credential[%s] is not listed in cloud credentials from admin %s", cloudCredentialNameMap[infraAdminUser], cloudCredentialFromAdmin)
						log.FailOnError(fmt.Errorf(""), err.Error())
					}
				}
			}
			backupLocations, err := getAllBackupLocations(adminCtx)
			log.FailOnError(err, "Fetching backup location from px-admin")
			for _, backupLocationName := range backupLocations {
				backupLocationsFromAdmin = append(backupLocationsFromAdmin, backupLocationName)
			}
			if !IsPresent(backupLocationsFromAdmin, backupLocationNameMap[infraAdminUser]) {
				err := fmt.Errorf("backup location [%s] is not listed in backup location names from admin %s", backupLocationNameMap[infraAdminUser], backupLocationsFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}
			schedulePoliciesFromAdmin, err := Inst().Backup.GetAllSchedulePolicies(adminCtx, orgID)
			log.FailOnError(err, "Fetching backup schedules from px-admin")
			if !IsPresent(schedulePoliciesFromAdmin, periodicSchedulePolicyNameMap[infraAdminUser]) {
				err := fmt.Errorf("schedule policy [%s] is not listed in schedule policies  from admin %s", periodicSchedulePolicyNameMap[infraAdminUser], schedulePoliciesFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}

			rulesFromAdmin, err := Inst().Backup.GetAllRules(adminCtx, orgID)
			log.FailOnError(err, "Fetching rules from px-admin")
			if preRuleNameMap[infraAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, preRuleNameMap[infraAdminUser]) {
					err := fmt.Errorf("pre rule [%s] is not listed in rules from admin %s", preRuleNameMap[infraAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
			if postRuleNameMap[infraAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, postRuleNameMap[infraAdminUser]) {
					err := fmt.Errorf("post rule [%s] is not listed in rules from admin %s", postRuleNameMap[infraAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})

		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for i := 1; i <= numOfUsers/3; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					userNames = append(userNames, userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
				}
			}
		})

		Step("Verify Infra-Admin User has permission to share RBAC resources with non-admin users", func() {
			log.InfoD("Verify Infra-Admin User has permission to share RBAC resources with non-admin users")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					log.Infof("Update CloudAccount - %s ownership for users - [%v]", cloudCredentialNameMap[infraAdminUser], userNames)
					err = AddCloudCredentialOwnership(cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for CloudCredential- %s", cloudCredentialNameMap[infraAdminUser]))
				}
			}
			log.InfoD("Update BackupLocation - %s ownership for users - [%v]", backupLocationNameMap[infraAdminUser], userNames)
			err = AddBackupLocationOwnership(backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for backuplocation - %s", backupLocationNameMap[infraAdminUser]))
			log.InfoD("Update SchedulePolicy - %s ownership for users - [%v]", periodicSchedulePolicyNameMap[infraAdminUser], userNames)
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for schedulepolicy - %s", periodicSchedulePolicyNameMap[infraAdminUser]))
			log.InfoD("Update Application Rules ownership for users - [%v]", userNames)
			if preRuleNameMap[infraAdminUser] != "" {
				err = AddRuleOwnership(preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for pre-rule of application"))
			}
			if postRuleNameMap[infraAdminUser] != "" {
				err = AddRuleOwnership(postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for post-rule of application"))
			}
		})

		createObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				backupName := fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, user, RandomString(4))
				backupNameMap[user] = backupName
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[user], SourceClusterName, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], appContextsToBackup, labelSelectors, orgID, userClusterMap[user][SourceClusterName], preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, bkpNamespaces))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], backupNameMap[user]).([]string)
			})

			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", RandomString(5))
				scheduleNameMap[user] = userScheduleName
				scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, backupLocationNameMap[infraAdminUser], backupLocationUIDMap[infraAdminUser], scheduledAppContexts, make(map[string]string), orgID, preRuleNameMap[infraAdminUser], preRuleUidMap[infraAdminUser], postRuleNameMap[infraAdminUser], postRuleUidMap[infraAdminUser], periodicSchedulePolicyNameMap[infraAdminUser], periodicSchedulePolicyUidMap[infraAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", userScheduleName))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], scheduleBackupName).([]string)
				err = suspendBackupSchedule(scheduleNameMap[user], periodicSchedulePolicyNameMap[infraAdminUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
		}
		err := TaskHandler(userNames, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")

		cleanupUserObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Delete user %s backups from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, backupName := range userBackupNamesMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackup(backupName, backupUid, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					err = DeleteBackupAndWait(backupName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
				}
			})
			Step(fmt.Sprintf("Delete user %s backup schedule ", user), func() {
				log.InfoD(fmt.Sprintf("Delete user %s backup schedule ", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = DeleteSchedule(scheduleNameMap[user], SourceClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
					err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
					log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
				}
			})
		}
		err = TaskHandler(userNames, cleanupUserObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from admin")

		Step(fmt.Sprintf("Verify Infra-Admin User has permission to create new custom role"), func() {
			log.InfoD("Verify Infra-Admin User has permission to create new custom role")
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			customInfraRoleName = backup.PxBackupRole(fmt.Sprintf("custom-infra-admin-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation}
			apis := []RoleApis{All}
			err = CreateRole(customInfraRoleName, services, apis, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of role [%s] by the infra-admin user", customInfraRoleName))
		})
		Step(fmt.Sprintf("Create a new user with custom role [%s]", customInfraRoleName), func() {
			log.InfoD(fmt.Sprintf("Create a new user with custom role [%s]", customInfraRoleName))
			customUser = createUsers(1)[0]
			err := backup.AddRoleToUser(customUser, customInfraRoleName, fmt.Sprintf("Adding %v role to %s", customInfraRoleName, customUser))
			log.FailOnError(err, "failed to add role %s to the user %s", infraAdminRole, infraAdminUser)
			log.Infof("username %s common password %s", infraAdminUser, commonPassword)
		})

		Step("Verify custom user has permission to create cloud credential and backup location", func() {
			log.InfoD("Verify custom user has permission to create cloud credential and backup location")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			for _, provider := range providers {
				cloudCredentialNameMap[customUser] = fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
				cloudCredentialUIDMap[customUser] = uuid.New()
				err = CreateCloudCredential(provider, cloudCredentialNameMap[customUser], cloudCredentialUIDMap[customUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of cloud credential %s using provider %s for the user", cloudCredentialNameMap[customUser], provider))
				backupLocationNameMap[customUser] = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
				backupLocationUIDMap[customUser] = uuid.New()
				err = CreateBackupLocationWithContext(provider, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], cloudCredentialNameMap[customUser], cloudCredentialUIDMap[customUser], getGlobalBucketName(provider), orgID, "", nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of backup location %s using provider %s for the custom user [%s]", backupLocationNameMap[customUser], provider, customUser))
			}
		})

		Step(fmt.Sprintf("Verify custom user has permission to create a schedule policy"), func() {
			log.InfoD("Verify custom user has permission to create a schedule policy")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			periodicSchedulePolicyNameMap[customUser] = fmt.Sprintf("%s-%v", "periodic", RandomString(5))
			periodicSchedulePolicyUidMap[customUser] = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[customUser], periodicSchedulePolicyUidMap[customUser], orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[customUser]))
		})

		Step(fmt.Sprintf("Verify custom user has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify custom user has permission to create pre and post exec rules for applications")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			preRuleNameMap[customUser], postRuleNameMap[customUser], err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from custom user [%s]", customUser))
		})

		Step(fmt.Sprintf("Verify custom user doesn't have permission to create roles"), func() {
			log.InfoD("Verify custom user doesn't have permission to create roles")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			customRoleName = backup.PxBackupRole(fmt.Sprintf("custom-user-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation, Role}
			apis := []RoleApis{All}
			err = CreateRole(customRoleName, services, apis, nonAdminCtx)
			dash.VerifyFatal(strings.Contains(err.Error(), "PermissionDenied desc = Access denied for [Resource: role]"), true, fmt.Sprintf("Verifying custom user doesnt have permission for creating role [%s]", customRoleName))
		})
		Step(fmt.Sprintf("Create source and destination cluster from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", customUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[customUser] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[customUser][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			backupNameMap[customUser] = fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, customUser, RandomString(4))
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[customUser], SourceClusterName, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], appContextsToBackup, labelSelectors, orgID, userClusterMap[customUser][SourceClusterName], "", "", "", "")
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupNameMap[customUser], bkpNamespaces))
		})

		Step(fmt.Sprintf("Take restore of applications from the custom user %s", customUser), func() {
			log.InfoD(fmt.Sprintf("Taking restore of applications from the custom user %s", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			restoreNameMap[customUser] = fmt.Sprintf("%s-%s", restoreNamePrefix, backupNameMap[customUser])
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[customUser], backupNameMap[customUser], make(map[string]string), make(map[string]string), destinationClusterName, orgID, appContextsToBackup)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreNameMap[customUser], backupNameMap[customUser]))
		})

		Step(fmt.Sprintf("Delete user %s backups from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupNameMap[customUser], orgID)
			log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupNameMap[customUser], customUser)
			_, err = DeleteBackup(backupNameMap[customUser], backupUid, orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete backup %s of the user %s", backupNameMap[customUser], customUser)
			err = DeleteBackupAndWait(backupNameMap[customUser], nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupNameMap[customUser]))
		})

		Step(fmt.Sprintf("Delete user %s restores from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s restores from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			err = DeleteRestore(restoreNameMap[customUser], orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete restore %s of the user %s", restoreNameMap[customUser], customUser)
		})
		Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", customUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", customUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, customUser))
				err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
				log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by customUser [%s]", customUser), func() {
			log.InfoD(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by customUser [%s]", customUser))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			nonAdminCtx, err := backup.GetNonAdminCtx(customUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", customUser)
			log.Infof("Verify deletion of backup location [%s] of user [%s] from px-admin", backupLocationNameMap[customUser], customUser)
			err = DeleteBackupLocation(backupLocationNameMap[customUser], backupLocationUIDMap[customUser], orgID, true)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of backup location [%s] of the user %s", backupLocationNameMap[customUser], customUser))
			err = Inst().Backup.WaitForBackupLocationDeletion(adminCtx, backupLocationNameMap[customUser], backupLocationUIDMap[customUser], orgID, backupLocationDeleteTimeout, backupLocationDeleteRetryTime)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying waiting for backup location [%s]  deletion of the user %s", backupLocationNameMap[customUser], customUser))
			log.Infof("Verify deletion of schedule policy [%s] of user [%s] from px-admin", periodicSchedulePolicyNameMap[customUser], customUser)
			err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyNameMap[customUser]})
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of the user %s", periodicSchedulePolicyNameMap[customUser], customUser))
			log.Infof("Verify deletion of rules of user [%s] from px-admin", customUser)
			customUserRules, _ := Inst().Backup.GetAllRules(nonAdminCtx, orgID)
			for _, ruleName := range customUserRules {
				err := DeleteRule(ruleName, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the user %s", ruleName, customUser))
			}
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					log.Infof("Verify deletion of cloud credential [%s] of user [%s] from px-admin", cloudCredentialNameMap[customUser], customUser)
					err = DeleteCloudCredential(cloudCredentialNameMap[customUser], orgID, cloudCredentialUIDMap[customUser])
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cloud credential [%s] of the user %s", cloudCredentialNameMap[customUser], customUser))
				}
			}
		})

		Step(fmt.Sprintf("Verify infra-admin user [%s] can delete RBAC resources created ", infraAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verify infra-admin user [%s] can delete RBAC resources created ", infraAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
			log.Infof("Verify deletion of schedule policy [%s] of user [%s] ", periodicSchedulePolicyNameMap[infraAdminUser], infraAdminUser)
			err = DeleteBackupSchedulePolicyWithContext(orgID, []string{periodicSchedulePolicyNameMap[infraAdminUser]}, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of the user %s", periodicSchedulePolicyNameMap[infraAdminUser], infraAdminUser))
			log.Infof("Verify deletion of rules of user [%s] ", infraAdminUser)
			userRules, _ := Inst().Backup.GetAllRules(nonAdminCtx, orgID)
			for _, ruleName := range userRules {
				err := DeleteRule(ruleName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the user %s", ruleName, infraAdminUser))
			}
			log.Infof("Verify deletion of role [%s] created by user [%s] ", customInfraRoleName, infraAdminUser)
			err = DeleteRole(customInfraRoleName, orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of role [%s] created by user  %s", customInfraRoleName, infraAdminUser))
		})

	})
	JustAfterEach(func() {
		defer EndPxBackupTorpedoTest(scheduledAppContexts)
		nonAdminCtx, err := backup.GetNonAdminCtx(infraAdminUser, commonPassword)
		log.FailOnError(err, "failed to fetch user %s ctx", infraAdminUser)
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Deleting the px-backup objects")
		CleanupCloudSettingsAndClusters(backupLocationMap, cloudCredentialNameMap[infraAdminUser], cloudCredentialUIDMap[infraAdminUser], nonAdminCtx)
		log.InfoD("Switching context to destination cluster for clean up")
		err = SetDestinationKubeConfig()
		log.FailOnError(err, "Unable to switch context to destination cluster [%s]", destinationClusterName)
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Switching back context to Source cluster")
		err = SetSourceKubeConfig()
		log.FailOnError(err, "Unable to switch context to source cluster [%s]", SourceClusterName)
	})
})

// VerifyRBACForPxAdmin Validates the RBAC operation for px-admin group user.
var _ = Describe("{VerifyRBACForPxAdmin}", func() {
	var (
		scheduledAppContexts       []*scheduler.Context
		adminBackupLocationName    string
		adminBackupLocationUID     string
		adminCloudCredentialName   string
		adminCloudCredentialUID    string
		scheduleNameMap            = make(map[string]string)
		periodicSchedulePolicyName string
		periodicSchedulePolicyUid  string
		preRuleName                string
		postRuleName               string
		preRuleUid                 string
		postRuleUid                string
		adminBackupName            string
		adminRestoreName           string
		srcClusterUid              string
		numOfUsers                 = 3
		customRoleName             backup.PxBackupRole
		userClusterMap             = make(map[string]map[string]string)
		backupNameMap              = make(map[string]string)
		userBackupNamesMap         = make(map[string][]string)
		backupLocationMap          = make(map[string]string)
		userNames                  = make([]string, 0)
		providers                  = getProviders()
		bkpNamespaces              []string
		labelSelectors             map[string]string
		mutex                      sync.Mutex
	)

	JustBeforeEach(func() {
		StartTorpedoTest("VerifyRBACForPxAdmin", "Validates the RBAC operation for px-admin group user.", nil, 87887)
		log.InfoD("scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, appCtx := range appContexts {
				appCtx.ReadinessTimeout = appReadinessTimeout
				scheduledAppContexts = append(scheduledAppContexts, appCtx)
				namespace := GetAppNamespace(appCtx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Validates the RBAC operation for px-admin group user.", func() {
		Step("Validate applications", func() {
			ValidateApplications(scheduledAppContexts)
		})

		Step("Verify Px-Admin group user has permission to create cloud credential  and backup location", func() {
			log.InfoD("Verify Px-Admin group user has permission to create cloud credential and backup location")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			for _, provider := range providers {
				adminCloudCredentialName = fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
				adminCloudCredentialUID = uuid.New()
				err = CreateCloudCredential(provider, adminCloudCredentialName, adminCloudCredentialUID, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create cloud credential %s using provider %s for the px-admin", adminCloudCredentialName, provider))
				adminBackupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
				adminBackupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, adminBackupLocationName, adminBackupLocationUID, adminCloudCredentialName, adminCloudCredentialUID, getGlobalBucketName(provider), orgID, "", ctx)
				log.FailOnError(err, "failed to create backup location %s using provider %s for the user", adminBackupLocationName, provider)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of create backup location %s using provider %s for the px-admin", adminBackupLocationName, provider))
				backupLocationMap[adminBackupLocationUID] = adminBackupLocationName
			}
		})

		Step(fmt.Sprintf("Verify Px-Admin User has permission to create a schedule policy"), func() {
			log.InfoD("Verify Px-Admin User has permission to create a schedule policy")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			periodicSchedulePolicyName = fmt.Sprintf("%s-%v", "periodic", RandomString(5))
			periodicSchedulePolicyUid = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyName, periodicSchedulePolicyUid, orgID, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyName))
		})

		Step(fmt.Sprintf("Verify Px-Admin User has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify Px-Admin User has permission to create pre and post exec rules for applications")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			preRuleName, postRuleName, err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from px-admin"))
			if preRuleName != "" {
				preRuleUid, err = Inst().Backup.GetRuleUid(orgID, ctx, preRuleName)
				log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleName)
				log.Infof("Pre backup rule [%s] uid: [%s]", preRuleName, preRuleUid)
			}
			if postRuleName != "" {
				postRuleUid, err = Inst().Backup.GetRuleUid(orgID, ctx, postRuleName)
				log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleName)
				log.Infof("Post backup rule [%s] uid: [%s]", postRuleName, postRuleUid)
			}
		})

		Step(fmt.Sprintf("Verify Px-Admin User has permission to create new custom role"), func() {
			log.InfoD("Verify Px-Admin User has permission to create new custom role")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			customRoleName = backup.PxBackupRole(fmt.Sprintf("custom-px-admin-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation}
			apis := []RoleApis{All}
			err = CreateRole(customRoleName, services, apis, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of role [%s] by the px-admin", customRoleName))
		})

		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for i := 1; i <= numOfUsers/3; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					userNames = append(userNames, userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
				}
			}
		})

		Step("Verify px-admin User has permission to share RBAC resources with non-admin users", func() {
			log.InfoD("Verify px-admin User has permission to share RBAC resources with non-admin users")
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					log.Infof("Update CloudAccount - %s ownership for users - [%v]", adminCloudCredentialName, userNames)
					err = AddCloudCredentialOwnership(adminCloudCredentialName, adminCloudCredentialUID, userNames, nil, Read, Invalid, ctx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of owbership for CloudCredential- %s", adminCloudCredentialName))
				}
			}
			log.InfoD("Update BackupLocation - %s ownership for users - [%v]", adminBackupLocationName, userNames)
			err = AddBackupLocationOwnership(adminBackupLocationName, adminBackupLocationUID, userNames, nil, Read, Invalid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for backuplocation - %s", adminBackupLocationName))
			log.InfoD("Update SchedulePolicy - %s ownership for users - [%v]", periodicSchedulePolicyName, userNames)
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyName, periodicSchedulePolicyUid, userNames, nil, Read, Invalid, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for schedulepolicy - %s", periodicSchedulePolicyName))
			log.InfoD("Update Application Rules ownership for users - [%v]", userNames)
			if preRuleName != "" {
				err = AddRuleOwnership(preRuleName, preRuleUid, userNames, nil, Read, Invalid, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for pre-rule of application"))
			}
			if postRuleName != "" {
				err = AddRuleOwnership(postRuleName, postRuleUid, userNames, nil, Read, Invalid, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for post-rule of application"))
			}
		})

		Step(fmt.Sprintf("Create source and destination cluster from the px-admin"), func() {
			log.InfoD(fmt.Sprintf("Create source and destination cluster from the px-admin"))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			err = CreateApplicationClusters(orgID, "", "", ctx)
			log.FailOnError(err, "failed create source and destination cluster from px-admin")
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, ctx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			srcClusterUid, err = Inst().Backup.GetClusterUID(ctx, orgID, SourceClusterName)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", SourceClusterName))
		})
		Step(fmt.Sprintf("Take backup of applications from the px-admin"), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the px-admin"))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			adminBackupName = fmt.Sprintf("%s-manual-single-ns-with-rules-%s", BackupNamePrefix, RandomString(4))
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateBackupWithValidation(ctx, adminBackupName, SourceClusterName, adminBackupLocationName, adminBackupLocationUID, appContextsToBackup, labelSelectors, orgID, srcClusterUid, "", "", "", "")
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", adminBackupName, bkpNamespaces))
		})

		Step(fmt.Sprintf("Take restore of applications from the px-admin"), func() {
			log.InfoD(fmt.Sprintf("Taking restore of applications from the px-admin"))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			adminRestoreName = fmt.Sprintf("%s-%s", restoreNamePrefix, adminBackupName)
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateRestoreWithValidation(ctx, adminRestoreName, adminBackupName, make(map[string]string), make(map[string]string), destinationClusterName, orgID, appContextsToBackup)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", adminRestoreName, adminBackupName))
		})

		Step(fmt.Sprintf("Delete px-admin backup from the px-admin context"), func() {
			log.InfoD(fmt.Sprintf("Deleting px-admin backup from the px-admin context"))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			backupUid, err := Inst().Backup.GetBackupUID(ctx, adminBackupName, orgID)
			log.FailOnError(err, "failed to fetch backup %s uid of the px-admin", adminBackupName)
			_, err = DeleteBackup(adminBackupName, backupUid, orgID, ctx)
			log.FailOnError(err, "failed to delete backup %s of the px-admin", adminBackupName)
			err = DeleteBackupAndWait(adminBackupName, ctx)
			log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", adminBackupName))
		})

		Step(fmt.Sprintf("Delete px-admin restore from the px-admin context"), func() {
			log.InfoD(fmt.Sprintf("Deleting  px-admin restore from the px-admin context"))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			err = DeleteRestore(adminRestoreName, orgID, ctx)
			log.FailOnError(err, "failed to delete restore %s of the px-admin", adminRestoreName)
		})

		createObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				backupName := fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, user, RandomString(4))
				backupNameMap[user] = backupName
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[user], SourceClusterName, adminBackupLocationName, adminBackupLocationUID, appContextsToBackup, labelSelectors, orgID, userClusterMap[user][SourceClusterName], preRuleName, preRuleUid, postRuleName, postRuleUid)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, bkpNamespaces))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], backupNameMap[user]).([]string)
			})

			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", RandomString(5))
				scheduleNameMap[user] = userScheduleName
				scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, adminBackupLocationName, adminBackupLocationUID, scheduledAppContexts, make(map[string]string), orgID, preRuleName, preRuleUid, postRuleName, postRuleUid, periodicSchedulePolicyName, periodicSchedulePolicyUid)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", userScheduleName))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], scheduleBackupName).([]string)
				err = suspendBackupSchedule(scheduleNameMap[user], periodicSchedulePolicyName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
		}
		err := TaskHandler(userNames, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")

		cleanupUserObjectsFromUser := func(user string) {
			defer GinkgoRecover()
			Step(fmt.Sprintf("Delete user %s backups from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, backupName := range userBackupNamesMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackup(backupName, backupUid, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					err = DeleteBackupAndWait(backupName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
				}
			})
			Step(fmt.Sprintf("Delete user %s backup schedule ", user), func() {
				log.InfoD(fmt.Sprintf("Delete user %s backup schedule ", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = DeleteSchedule(scheduleNameMap[user], SourceClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
					err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
					log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
				}
			})
		}
		err = TaskHandler(userNames, cleanupUserObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")

		Step(fmt.Sprintf("Verify px-admin group can delete RBAC resources created "), func() {
			log.InfoD(fmt.Sprintf("Verify px-admin group can delete RBAC resources created "))
			ctx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch px-admin ctx")
			log.Infof("Verify deletion of schedule policy [%s] of px-admin", periodicSchedulePolicyName)
			err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyName})
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of px-admin", periodicSchedulePolicyName))
			log.Infof("Verify deletion of rules of px-admin")
			pxadminRules, _ := Inst().Backup.GetAllRules(ctx, orgID)
			for _, ruleName := range pxadminRules {
				err := DeleteRule(ruleName, orgID, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the px-admin", ruleName))
			}
			log.Infof("Verify deletion of custom roles created by px-admin")
			err = DeleteRole(customRoleName, orgID, ctx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of custom role [%v] from px-admin", customRoleName))
		})
	})
	JustAfterEach(func() {
		defer func() {
			err := SetSourceKubeConfig()
			log.FailOnError(err, "Unable to switch context to source cluster [%s]", SourceClusterName)
			EndPxBackupTorpedoTest(scheduledAppContexts)
		}()
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "failed to fetch px-admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Deleting the px-backup objects")
		CleanupCloudSettingsAndClusters(backupLocationMap, adminCloudCredentialName, adminCloudCredentialUID, ctx)
		log.InfoD("Switching context to destination cluster for clean up")
		err = SetDestinationKubeConfig()
		log.FailOnError(err, "Unable to switch context to destination cluster [%s]", destinationClusterName)
		DestroyApps(scheduledAppContexts, opts)
	})
})

// VerifyRBACForAppAdmin Validates the RBAC operation for app-admin user.
var _ = Describe("{VerifyRBACForAppAdmin}", func() {
	var (
		scheduledAppContexts          []*scheduler.Context
		scheduleNameMap               = make(map[string]string)
		periodicSchedulePolicyNameMap = make(map[string]string)
		periodicSchedulePolicyUidMap  = make(map[string]string)
		preRuleNameMap                = make(map[string]string)
		postRuleNameMap               = make(map[string]string)
		preRuleUidMap                 = make(map[string]string)
		postRuleUidMap                = make(map[string]string)
		numOfUsers                    = 3
		appAdminUser                  string
		adminCredName                 string
		adminCloudCredUID             string
		adminBackupLocationName       string
		adminBackupLocationUID        string
		appAdminBackupLocationName    string
		appAdminBackupLocationUID     string
		customRoleName                backup.PxBackupRole
		userClusterMap                = make(map[string]map[string]string)
		backupNameMap                 = make(map[string]string)
		restoreNameMap                = make(map[string]string)
		userBackupNamesMap            = make(map[string][]string)
		backupLocationMap             = make(map[string]string)
		backupLocationsFromAdmin      []string
		userNames                     = make([]string, 0)
		providers                     = getProviders()
		bkpNamespaces                 []string
		appAdminRole                  backup.PxBackupRole = backup.ApplicationOwner
		labelSelectors                map[string]string
		mutex                         sync.Mutex
	)

	JustBeforeEach(func() {
		StartTorpedoTest("VerifyRBACForAppAdmin", "Validates the RBAC operation for app-admin user.", nil, 87888)
		log.InfoD("scheduling applications")
		scheduledAppContexts = make([]*scheduler.Context, 0)
		for i := 0; i < Inst().GlobalScaleFactor; i++ {
			taskName := fmt.Sprintf("%s-%d", taskNamePrefix, i)
			appContexts := ScheduleApplications(taskName)
			for _, appCtx := range appContexts {
				appCtx.ReadinessTimeout = appReadinessTimeout
				scheduledAppContexts = append(scheduledAppContexts, appCtx)
				namespace := GetAppNamespace(appCtx, taskName)
				bkpNamespaces = append(bkpNamespaces, namespace)
			}
		}
	})

	It("Validates the RBAC operation for app-admin user", func() {
		Step("Validate applications", func() {
			log.InfoD("Validating applications")
			ValidateApplications(scheduledAppContexts)
		})

		Step(fmt.Sprintf("Create a user with %s role", appAdminRole), func() {
			log.InfoD(fmt.Sprintf("Creating a user with %s role", appAdminRole))
			appAdminUser = createUsers(1)[0]
			err := backup.AddRoleToUser(appAdminUser, appAdminRole, fmt.Sprintf("Adding %v role to %s", appAdminRole, appAdminUser))
			dash.VerifyFatal(err, nil, fmt.Sprintf("failed to add role %s to the user %s", appAdminRole, appAdminUser))
		})

		Step("Verify App-Admin User doesnt have permission to create cloud credential", func() {
			log.InfoD("Verify App-Admin User doesnt have permission to create cloud credential")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					cloudCredentialName := fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
					cloudCredentialUID := uuid.New()
					err = CreateCloudCredential(provider, cloudCredentialName, cloudCredentialUID, orgID, nonAdminCtx)
					dash.VerifyFatal(strings.Contains(err.Error(), "PermissionDenied desc = Access denied for [Resource: cloudcredential]"), true, fmt.Sprintf("Verifying creation failure of cloud credential %s using provider %s for the user", cloudCredentialName, provider))
				}
			}
		})

		Step("Verify App-Admin User doesnt have permission to create role", func() {
			log.InfoD("Verify App-Admin User doesnt have permission to create role")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			customRoleName = backup.PxBackupRole(fmt.Sprintf("custom-user-role-%s", RandomString(4)))
			services := []RoleServices{SchedulePolicy, Rules, Cloudcredential, BackupLocation, Role}
			apis := []RoleApis{All}
			err = CreateRole(customRoleName, services, apis, nonAdminCtx)
			dash.VerifyFatal(strings.Contains(err.Error(), "PermissionDenied desc = Access denied for [Resource: role]"), true, fmt.Sprintf("Verifying app-user doesnt have permission for creating role [%s]", customRoleName))
		})

		Step(fmt.Sprintf("Adding Credentials and BackupLocation from px-admin user and making it public"), func() {
			log.InfoD(fmt.Sprintf("Adding Credentials and BackupLocation from px-admin user and making it public"))
			for _, provider := range providers {
				ctx, err := backup.GetAdminCtxFromSecret()
				log.FailOnError(err, "Fetching px-admin ctx")
				adminCloudCredUID = uuid.New()
				adminCredName = fmt.Sprintf("autogenerated-cred-%v", RandomString(5))
				if provider != drivers.ProviderNfs {
					err = CreateCloudCredential(provider, adminCredName, adminCloudCredUID, orgID, ctx)
					log.FailOnError(err, "Failed to create cloud credential - %s", err)
					err = AddCloudCredentialOwnership(adminCredName, adminCloudCredUID, nil, nil, Invalid, Read, ctx, orgID)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying public ownership update for cloud credential %s ", adminCredName))
				}
				adminBackupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
				adminBackupLocationUID = uuid.New()
				err = CreateBackupLocationWithContext(provider, adminBackupLocationName, adminBackupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", ctx)
				log.FailOnError(err, "Failed to add backup location %s using provider %s for px-admin user", adminBackupLocationName, provider)
				backupLocationMap[adminBackupLocationUID] = adminBackupLocationName
				err = AddBackupLocationOwnership(adminBackupLocationName, adminBackupLocationUID, nil, nil, Invalid, Read, ctx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying public ownership update for backup location %s", adminBackupLocationName))
			}
		})

		Step(fmt.Sprintf("Verify App-Admin User can create backup location with cloud cred shared from px-admin"), func() {
			log.InfoD("Verify App-Admin User can create backup location with cloud cred shared from px-admin")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			appAdminBackupLocationName = fmt.Sprintf("autogenerated-backup-location-%v", RandomString(5))
			appAdminBackupLocationUID = uuid.New()
			for _, provider := range providers {
				err = CreateBackupLocationWithContext(provider, appAdminBackupLocationName, appAdminBackupLocationUID, adminCredName, adminCloudCredUID, getGlobalBucketName(provider), orgID, "", nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Failed to add backup location %s using provider %s for px-admin user", appAdminBackupLocationName, provider))
			}
		})

		Step(fmt.Sprintf("Verify App-Admin User can't share backup location created with shared cloud cred from px-admin"), func() {
			log.InfoD("Verify App-Admin User can't share backup location created with shared cloud cred from px-admin")
			for _, provider := range providers {
				if provider != drivers.ProviderNfs {
					nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
					err = AddBackupLocationOwnership(appAdminBackupLocationName, appAdminBackupLocationUID, nil, nil, Invalid, Read, nonAdminCtx)
					dash.VerifyFatal(strings.Contains(err.Error(), "failed to create backup location: rpc error: code = Unknown desc = cannot share backup location name/UID"), true, fmt.Sprintf("Verifying ownership update failure for backup location %s ", appAdminBackupLocationName))
				}
			}
		})

		Step(fmt.Sprintf("Verify App-Admin User has permission to create a schedule policy"), func() {
			log.InfoD("Verify App-Admin User has permission to create a schedule policy")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			periodicSchedulePolicyNameMap[appAdminUser] = fmt.Sprintf("%s-%v", "periodic", RandomString(5))
			periodicSchedulePolicyUidMap[appAdminUser] = uuid.New()
			periodicSchedulePolicyInterval := int64(15)
			err = CreateBackupScheduleIntervalPolicy(5, periodicSchedulePolicyInterval, 5, periodicSchedulePolicyNameMap[appAdminUser], periodicSchedulePolicyUidMap[appAdminUser], orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of periodic schedule policy of interval [%v] minutes named [%s]", periodicSchedulePolicyInterval, periodicSchedulePolicyNameMap[appAdminUser]))
		})

		Step(fmt.Sprintf("Verify App-Admin User has permission to create pre and post exec rules for applications"), func() {
			log.InfoD("Verify App-Admin User has permission to create pre and post exec rules for applications")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			preRuleNameMap[appAdminUser], postRuleNameMap[appAdminUser], err = CreateRuleForBackupWithMultipleApplications(orgID, Inst().AppList, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of pre and post exec rules for applications from px-admin"))
			if preRuleNameMap[appAdminUser] != "" {
				preRuleUidMap[appAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, preRuleNameMap[appAdminUser])
				log.FailOnError(err, "Fetching pre backup rule [%s] uid", preRuleNameMap[appAdminUser])
				log.Infof("Pre backup rule [%s] uid: [%s]", preRuleNameMap[appAdminUser], preRuleUidMap[appAdminUser])
			}
			if postRuleNameMap[appAdminUser] != "" {
				postRuleUidMap[appAdminUser], err = Inst().Backup.GetRuleUid(orgID, nonAdminCtx, postRuleNameMap[appAdminUser])
				log.FailOnError(err, "Fetching post backup rule [%s] uid", postRuleNameMap[appAdminUser])
				log.Infof("Post backup rule [%s] uid: [%s]", postRuleNameMap[appAdminUser], postRuleUidMap[appAdminUser])
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can list RBAC resources created by app-Admin User"), func() {
			log.InfoD("Verify px-admin group user can list RBAC resources created by app-Admin User")
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			backupLocations, err := getAllBackupLocations(adminCtx)
			log.FailOnError(err, "Fetching backup location from px-admin")
			for _, backupLocationName := range backupLocations {
				backupLocationsFromAdmin = append(backupLocationsFromAdmin, backupLocationName)
			}
			if !IsPresent(backupLocationsFromAdmin, appAdminBackupLocationName) {
				err := fmt.Errorf("backup location [%s] is not listed in backup location names from admin %s", appAdminBackupLocationName, backupLocationsFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}
			schedulePoliciesFromAdmin, err := Inst().Backup.GetAllSchedulePolicies(adminCtx, orgID)
			log.FailOnError(err, "Fetching backup schedules from px-admin")
			if !IsPresent(schedulePoliciesFromAdmin, periodicSchedulePolicyNameMap[appAdminUser]) {
				err := fmt.Errorf("schedule policy [%s] is not listed in schedule policies  from admin %s", periodicSchedulePolicyNameMap[appAdminUser], schedulePoliciesFromAdmin)
				log.FailOnError(fmt.Errorf(""), err.Error())
			}

			rulesFromAdmin, err := Inst().Backup.GetAllRules(adminCtx, orgID)
			log.FailOnError(err, "Fetching rules from px-admin")
			if preRuleNameMap[appAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, preRuleNameMap[appAdminUser]) {
					err := fmt.Errorf("pre rule [%s] is not listed in rules from admin %s", preRuleNameMap[appAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
			if postRuleNameMap[appAdminUser] != "" {
				if !IsPresent(rulesFromAdmin, postRuleNameMap[appAdminUser]) {
					err := fmt.Errorf("post rule [%s] is not listed in rules from admin %s", postRuleNameMap[appAdminUser], rulesFromAdmin)
					log.FailOnError(fmt.Errorf(""), err.Error())
				}
			}
		})

		Step("Create Users with Different types of roles", func() {
			log.InfoD("Create Users with Different types of roles")
			roles := [3]backup.PxBackupRole{backup.ApplicationOwner, backup.InfrastructureOwner, backup.ApplicationUser}
			for i := 1; i <= numOfUsers/3; i++ {
				for _, role := range roles {
					userName := createUsers(1)[0]
					err := backup.AddRoleToUser(userName, role, fmt.Sprintf("Adding %v role to %s", role, userName))
					log.FailOnError(err, "Failed to add role for user - %s", userName)
					userNames = append(userNames, userName)
					log.FailOnError(err, "Failed to fetch uid for - %s", userName)
					log.Infof(fmt.Sprintf("Added role %v to user %s", role, userName))
				}
			}
		})

		Step("Verify App-Admin User has permission to share schedule-policy and rules with non-admin users", func() {
			log.InfoD("Verify App-Admin User has permission to share schedule-policy and rules with non-admin users")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			log.InfoD("Update SchedulePolicy - %s ownership for users - [%v]", periodicSchedulePolicyNameMap[appAdminUser], userNames)
			err = AddSchedulePolicyOwnership(periodicSchedulePolicyNameMap[appAdminUser], periodicSchedulePolicyUidMap[appAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for schedulepolicy - %s", periodicSchedulePolicyNameMap[appAdminUser]))
			log.InfoD("Update Application Rules ownership for users - [%v]", userNames)
			if preRuleNameMap[appAdminUser] != "" {
				err = AddRuleOwnership(preRuleNameMap[appAdminUser], preRuleUidMap[appAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for pre-rule of application"))
			}
			if postRuleNameMap[appAdminUser] != "" {
				err = AddRuleOwnership(postRuleNameMap[appAdminUser], postRuleUidMap[appAdminUser], userNames, nil, Read, Invalid, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying updation of ownership for post-rule of application"))
			}
		})

		createObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Create source and destination cluster from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Creating source and destination cluster from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
				log.FailOnError(err, "failed create source and destination cluster from the user %s", user)
				clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
				log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
				dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
				userClusterMap[user] = make(map[string]string)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
					userClusterMap[user][clusterName] = userClusterUID
				}
			})
			Step(fmt.Sprintf("Take backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				backupName := fmt.Sprintf("%s-manual-single-ns-%s-with-rules-%s", BackupNamePrefix, user, RandomString(4))
				backupNameMap[user] = backupName
				appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
				err = CreateBackupWithValidation(nonAdminCtx, backupNameMap[user], SourceClusterName, adminBackupLocationName, adminBackupLocationUID, appContextsToBackup, labelSelectors, orgID, userClusterMap[user][SourceClusterName], preRuleNameMap[appAdminUser], preRuleUidMap[appAdminUser], postRuleNameMap[appAdminUser], postRuleUidMap[appAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of backup [%s] of namespace (scheduled Context) [%s]", backupName, bkpNamespaces))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], backupNameMap[user]).([]string)
			})

			Step(fmt.Sprintf("Take schedule backup of applications from the user %s", user), func() {
				log.InfoD(fmt.Sprintf("Taking schedule backup of applications from the user %s", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				userScheduleName := fmt.Sprintf("backup-schedule-%v", RandomString(5))
				scheduleNameMap[user] = userScheduleName
				scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, adminBackupLocationName, adminBackupLocationUID, scheduledAppContexts, make(map[string]string), orgID, preRuleNameMap[appAdminUser], preRuleUidMap[appAdminUser], postRuleNameMap[appAdminUser], postRuleUidMap[appAdminUser], periodicSchedulePolicyNameMap[appAdminUser], periodicSchedulePolicyUidMap[appAdminUser])
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", userScheduleName))
				userBackupNamesMap[user] = SafeAppend(&mutex, userBackupNamesMap[user], scheduleBackupName).([]string)
				err = suspendBackupSchedule(scheduleNameMap[user], periodicSchedulePolicyNameMap[appAdminUser], orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Suspending Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
		}
		err := TaskHandler(userNames, createObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to create objects from user")

		cleanupUserObjectsFromUser := func(user string) {
			Step(fmt.Sprintf("Delete user %s backups from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s backups from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, backupName := range userBackupNamesMap[user] {
					backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, backupName, orgID)
					log.FailOnError(err, "failed to fetch backup %s uid of the user %s", backupName, user)
					_, err = DeleteBackup(backupName, backupUid, orgID, nonAdminCtx)
					log.FailOnError(err, "failed to delete backup %s of the user %s", backupName, user)
					err = DeleteBackupAndWait(backupName, nonAdminCtx)
					log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", backupName))
				}
			})
			Step(fmt.Sprintf("Delete user %s backup schedule ", user), func() {
				log.InfoD(fmt.Sprintf("Delete user %s backup schedule ", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				err = DeleteSchedule(scheduleNameMap[user], SourceClusterName, orgID, nonAdminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Backup Schedule [%s] for user [%s]", scheduleNameMap[user], user))
			})
			Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", user), func() {
				log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", user))
				nonAdminCtx, err := backup.GetNonAdminCtx(user, commonPassword)
				log.FailOnError(err, "failed to fetch user %s ctx", user)
				for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
					err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
					dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, user))
					err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
					log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
				}
			})
		}
		err = TaskHandler(userNames, cleanupUserObjectsFromUser, Parallel)
		log.FailOnError(err, "failed to cleanup user objects from user")

		Step(fmt.Sprintf("Create source and destination cluster from the app-admin user %s", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Creating source and destination cluster from the app-admin user %s", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			err = CreateApplicationClusters(orgID, "", "", nonAdminCtx)
			log.FailOnError(err, "failed create source and destination cluster from the user %s", appAdminUser)
			clusterStatus, err := Inst().Backup.GetClusterStatus(orgID, SourceClusterName, nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("Fetching [%s] cluster status", SourceClusterName))
			dash.VerifyFatal(clusterStatus, api.ClusterInfo_StatusInfo_Online, fmt.Sprintf("Verifying if [%s] cluster is online", SourceClusterName))
			userClusterMap[appAdminUser] = make(map[string]string)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				userClusterUID, err := Inst().Backup.GetClusterUID(nonAdminCtx, orgID, clusterName)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Fetching [%s] cluster uid", clusterName))
				userClusterMap[appAdminUser][clusterName] = userClusterUID
			}
		})
		Step(fmt.Sprintf("Take backup of applications from the App-admin user %s", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking backup of applications from the app-admin user %s", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			userScheduleName := fmt.Sprintf("backup-schedule-%v", RandomString(5))
			scheduleNameMap[appAdminUser] = userScheduleName
			scheduleBackupName, err := CreateScheduleBackupWithValidation(nonAdminCtx, userScheduleName, SourceClusterName, appAdminBackupLocationName, appAdminBackupLocationUID, scheduledAppContexts, make(map[string]string), orgID, preRuleNameMap[appAdminUser], preRuleUidMap[appAdminUser], postRuleNameMap[appAdminUser], postRuleUidMap[appAdminUser], periodicSchedulePolicyNameMap[appAdminUser], periodicSchedulePolicyUidMap[appAdminUser])
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation and validation of schedule backup with schedule name [%s]", userScheduleName))
			userBackupNamesMap[appAdminUser] = SafeAppend(&mutex, userBackupNamesMap[appAdminUser], scheduleBackupName).([]string)
		})

		Step(fmt.Sprintf("Take restore of applications from the App-admin user %s", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Taking restore of applications from the App-admin user %s", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			restoreNameMap[appAdminUser] = fmt.Sprintf("%s-%s", restoreNamePrefix, userBackupNamesMap[appAdminUser][0])
			appContextsToBackup := FilterAppContextsByNamespace(scheduledAppContexts, bkpNamespaces)
			err = CreateRestoreWithValidation(nonAdminCtx, restoreNameMap[appAdminUser], userBackupNamesMap[appAdminUser][0], make(map[string]string), make(map[string]string), destinationClusterName, orgID, appContextsToBackup)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying creation of restore %s of backup %s", restoreNameMap[appAdminUser], userBackupNamesMap[appAdminUser][0]))
		})

		Step(fmt.Sprintf("Delete app-admin user %s backups from the user context", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting app-admin user %s backups from the user context", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			backupUid, err := Inst().Backup.GetBackupUID(nonAdminCtx, userBackupNamesMap[appAdminUser][0], orgID)
			log.FailOnError(err, "failed to fetch backup %s uid of the user %s", userBackupNamesMap[appAdminUser][0], appAdminUser)
			_, err = DeleteBackup(userBackupNamesMap[appAdminUser][0], backupUid, orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete backup %s of the user %s", userBackupNamesMap[appAdminUser][0], appAdminUser)
			err = DeleteBackupAndWait(userBackupNamesMap[appAdminUser][0], nonAdminCtx)
			log.FailOnError(err, fmt.Sprintf("waiting for backup [%s] deletion", userBackupNamesMap[appAdminUser][0]))
		})

		Step(fmt.Sprintf("Delete app-admin user %s restores from the user context", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting app-admin user %s restores from the user context", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			err = DeleteRestore(restoreNameMap[appAdminUser], orgID, nonAdminCtx)
			log.FailOnError(err, "failed to delete restore %s of the user %s", restoreNameMap[appAdminUser], appAdminUser)
		})
		Step(fmt.Sprintf("Delete App-admin user %s backup schedule ", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Delete App-admin user %s backup schedule ", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			err = DeleteSchedule(scheduleNameMap[appAdminUser], SourceClusterName, orgID, nonAdminCtx)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Deleting Backup Schedule [%s] for user [%s]", scheduleNameMap[appAdminUser], appAdminUser))
		})
		Step(fmt.Sprintf("Delete user %s source and destination cluster from the user context", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Deleting user %s source and destination cluster from the user context", appAdminUser))
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			for _, clusterName := range []string{SourceClusterName, destinationClusterName} {
				err := DeleteCluster(clusterName, orgID, nonAdminCtx, false)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of cluster [%s] of the user %s", clusterName, appAdminUser))
				err = Inst().Backup.WaitForClusterDeletion(nonAdminCtx, clusterName, orgID, clusterDeleteTimeout, clusterCreationRetryTime)
				log.FailOnError(err, fmt.Sprintf("waiting for cluster [%s] deletion", clusterName))
			}
		})

		Step(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by app-admin user [%s]", appAdminUser), func() {
			log.InfoD(fmt.Sprintf("Verify px-admin group user can delete RBAC resources created by app-admin user [%s]", appAdminUser))
			adminCtx, err := backup.GetAdminCtxFromSecret()
			log.FailOnError(err, "failed to fetch admin ctx")
			nonAdminCtx, err := backup.GetNonAdminCtx(appAdminUser, commonPassword)
			log.FailOnError(err, "failed to fetch user %s ctx", appAdminUser)
			log.Infof("Verify deletion of backup location [%s] of user [%s] from px-admin", appAdminBackupLocationName, appAdminUser)
			err = DeleteBackupLocation(appAdminBackupLocationName, appAdminBackupLocationUID, orgID, true)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of backup location [%s] of the user %s", appAdminBackupLocationName, appAdminUser))
			err = Inst().Backup.WaitForBackupLocationDeletion(adminCtx, appAdminBackupLocationName, appAdminBackupLocationUID, orgID, backupLocationDeleteTimeout, backupLocationDeleteRetryTime)
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying waiting for backup location [%s]  deletion of the user %s", appAdminBackupLocationName, appAdminUser))
			log.Infof("Verify deletion of schedule policy [%s] of user [%s] from px-admin", periodicSchedulePolicyNameMap[appAdminUser], appAdminUser)
			err = Inst().Backup.DeleteBackupSchedulePolicy(orgID, []string{periodicSchedulePolicyNameMap[appAdminUser]})
			dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of schedule policy [%s] of the user %s", periodicSchedulePolicyNameMap[appAdminUser], appAdminUser))
			log.Infof("Verify deletion of rules of user [%s] from px-admin", appAdminUser)
			appAdminRules, _ := Inst().Backup.GetAllRules(nonAdminCtx, orgID)
			for _, ruleName := range appAdminRules {
				err := DeleteRule(ruleName, orgID, adminCtx)
				dash.VerifyFatal(err, nil, fmt.Sprintf("Verifying deletion of rule [%s] of the user %s", ruleName, appAdminUser))
			}
		})
	})
	JustAfterEach(func() {
		defer func() {
			err := SetSourceKubeConfig()
			log.FailOnError(err, "Unable to switch context to source cluster [%s]", SourceClusterName)
			EndPxBackupTorpedoTest(scheduledAppContexts)
		}()
		ctx, err := backup.GetAdminCtxFromSecret()
		log.FailOnError(err, "failed to fetch admin ctx")
		log.InfoD("Deleting the deployed apps after the testcase")
		opts := make(map[string]bool)
		opts[SkipClusterScopedObjects] = true
		DestroyApps(scheduledAppContexts, opts)
		log.InfoD("Deleting the px-backup objects")
		CleanupCloudSettingsAndClusters(backupLocationMap, adminCredName, adminCloudCredUID, ctx)
		log.InfoD("Switching context to destination cluster for clean up")
		err = SetDestinationKubeConfig()
		log.FailOnError(err, "Unable to switch context to destination cluster [%s]", destinationClusterName)
		DestroyApps(scheduledAppContexts, opts)
	})
})
